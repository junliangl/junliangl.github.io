<!DOCTYPE html>
<html>
  <head>
     
    <meta charset="UTF-8">
    <title>测试用例设计方法 - onepiece</title>
    <link rel="shortcut icon" href="/junliangl/junliangl.github.io/static/img/icon.png">
    <link rel="icon" href="/static/img/icon.png" sizes="192x192"/>
    
<link rel="stylesheet" href="/junliangl/junliangl.github.io/static/kico.css">
<link rel="stylesheet" href="/junliangl/junliangl.github.io/static/hingle.css">

    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

    <meta name="viewport" content="width=device-width, maximum-scale=1, initial-scale=1"/>
    <meta property="og:site_name" content="onepiece">
    <meta property="og:title" content="测试用例设计方法"/>
    
    <style>body:before{ content: ''; background-image: url(https://github.com/junliangl/hexo-back/blob/master/images/images/%E6%9D%8F%E6%9E%9D.jpg?raw=true) }</style>
    
<meta name="generator" content="Hexo 6.3.0"></head>

  <body class="dark-theme">
    <header>
    <div class="head-title">
        <h4>onepiece</h4>
    </div>
    <div class="head-action">
        <div class="toggle-btn"></div>
        <div class="light-btn"></div>
        <div class="search-btn"></div>
    </div>
    <form class="head-search" method="post">
        <input type="text" name="s" placeholder="暂时不支持搜索哦">
    </form>
    <nav class="head-menu">
        <a href="/junliangl/junliangl.github.io/">首页</a>
        <div class="has-child">
            <a>分类</a>
            <div class="sub-menu">
				<a href="/junliangl/junliangl.github.io/categories/python/">python</a>
				<a href="/junliangl/junliangl.github.io/categories/linux">linux</a>
				<a href="/junliangl/junliangl.github.io/categories/test-theory">测试理论</a>
            </div>
        </div>
        
            <a href="/junliangl/junliangl.github.io/about">关于我</a>
        
    </nav>
</header>

    <main>
    <div class="wrap min">
        <section class="post-title">
            <h2>测试用例设计方法</h2>
            <div class="post-meta">
                <time class="date">2022.12.05</time>
            
                <span class="category"><a class="category-link" href="/junliangl/junliangl.github.io/categories/test-theory/">测试理论</a></span>
            
            </div>
        </section>
        <article class="post-content">
        
            <p>测试用例设计方法</p>
<ul>
<li>测试用例该如何设计呢</li>
<li>测试上可以分为黑盒测试和白盒测试两种<ul>
<li><p>黑盒测试</p>
<ul>
<li><img src="/junliangl/junliangl.github.io/./images/test-theory/Testcase-Designer/1.png"></li>
</ul>
</li>
<li><p>白盒测试</p>
<ul>
<li><img src="/junliangl/junliangl.github.io/./images/test-theory/Testcase-Designer/1.png"></li>
</ul>
</li>
</ul>
</li>
<li>等价类划分法（简称等价类）<ul>
<li>定义<ul>
<li>将输入（输出）域划分成若干个子集合中，从划分的子集合中选取代表数据进行测试，如果选取的数据测试没有问题，就认为其他数据测试的效果是等价的</li>
</ul>
</li>
<li>分为 <ul>
<li>有效等价类</li>
<li>无效等价类</li>
</ul>
</li>
<li>等价类划分原则<ul>
<li>如果输入（输出）是一个取值范围或者某个值的个数时，则划分成一个有效等价类和两个无效等价类<ul>
<li>举例<ul>
<li>某个大厦招聘保安，年龄要求18~60周岁（包括18和60）<ul>
<li>一个有效等价类：18~60</li>
<li>两个无效等价类：&lt;18；&gt;60</li>
</ul>
</li>
<li>并且从以上区间选取带有标志性的数据测试<ul>
<li>如有效等价类区间里选取 18 60 50…..，无效等价类里选取 10 70 80 …..</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>如果输入（输出）是一个有限集合或者必须如何的条件，则划分成一个有效等价类和一个无效等价类<ul>
<li>举例<ul>
<li>一个集合：以下城市进入上海需要提供核酸检测报告（沈阳；大连；深圳；广州；合肥；六安；营口；瑞丽）<ul>
<li>一个有效等价类：集合内；</li>
<li>一个无效等价类：集合外（菏泽）</li>
</ul>
</li>
<li>并且从以上区间选取带有标志性的数据测试<ul>
<li>如有效等价类选取大连……，无效等价类选取 菏泽……</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>如果输入（输出）是一个布尔量，则划分成一个有效等价类和一个无效等价类<ul>
<li>举例<ul>
<li>某个问卷调查 App 如果性别选项选择男请转到第五题：<ul>
<li>一个有效：男</li>
<li>一个无效：女</li>
</ul>
</li>
<li>如果性别选项选择女请转到第二题：<ul>
<li>一个有效：女</li>
<li>一个无效：男</li>
</ul>
</li>
</ul>
</li>
<li>很明显布尔类型是第二种等价类的特殊情况</li>
</ul>
</li>
<li>如果输入（输出）已经划分出有效和无效等价类，针对有效等价类部分不同的取值处理方式不一样，细分成多个有效等价类和一个无效等价类<ul>
<li>举例<ul>
<li>某个认证考试百分制；60分及格可以获得认证证书<ul>
<li>一个有效等价类：&gt;&#x3D;60分<ul>
<li>细化等价类：   60<del>69分—合格；70</del>79分—中等；80<del>89分—良好；90</del>99分—优秀；100分—完美</li>
</ul>
</li>
<li>一个无效等价类：&lt;60分</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>如果输入（输出）要同时满足多个条件，则划分成一个有效等价类和多个无效等价类<ul>
<li>举例<ul>
<li>学习系统登录密码修改：6~12位；<ul>
<li>一个有效等价类：大小写字母与数字的组合满足所有要求</li>
<li>多个无效等价类：少于6位；大于12位；缺少数字；缺少小写字母；缺少大写字母；含有其他字母</li>
</ul>
</li>
</ul>
</li>
<li>很明显从以上看出当有限集合数量过于庞大时，我们不采用第二种等价类划分法，采用当前的划分方法</li>
</ul>
</li>
</ul>
</li>
<li>使用步骤<ul>
<li>分析需求<ul>
<li>将软件需求规格说明书划分成需求子片段</li>
<li>分析需求子片段，找出输入条件</li>
</ul>
</li>
<li>分析输入条件，判定是否需要结合等价类划分原则划分等价，需要则继续</li>
<li>为了防止测试遗漏，为划分的等价类进行编号</li>
<li>从划分的等价类中选取代表数据进行测试，直到所有的等价类全部被覆盖</li>
<li>将选取的数据结合测试用例写作格式完成最终测试用例的编写</li>
<li>值得注意的是<ul>
<li>一条测试用例尽量覆盖多个有效等价类；</li>
<li>一条测试用例只覆盖一个无效等价类；</li>
<li>这符合之前等价类设计方法的最后一条，因为实际输入要么是庞大的集合，要么是无穷的区间。总之应该以有效等价类覆盖越多越好</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>边界值<ul>
<li>对于等价类划分法的问题是等价类划分法追求有效等价类覆盖率和数量，然而拥有无穷数的区间却使用一个等价类设计思路，这显然和宗旨相悖。基于以上问题，那么边界值设计方法可以对以上问题进行补充</li>
<li>边界值有三个重要的参数<ul>
<li>上点：区间边界的点</li>
<li>离点：离区间边界点最近的点<ul>
<li>如果是开区间离点落在区间内，如果是闭区间离点落在区间外<ul>
<li>即离点不能落在区间里</li>
</ul>
</li>
</ul>
</li>
<li>内点：落在区间内任意的点</li>
<li>举例<ul>
<li>某个大厦招聘保安，年龄要求[18，60]周岁<ul>
<li>上点：18；60</li>
<li>离点：17；61</li>
<li>内点：30</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>通过以上三个重要参数介绍基于边界值的选取原则<ul>
<li>如果输入（输出）是一个取值范围时，则以边界和边界附近的值作为测试用例数据优先选取<ul>
<li>这就是对等价类不足的设计手段，因为等价类不能精确地锁定哪些数据需要拿来测试。</li>
</ul>
</li>
<li>如果输入（输出）是一个有序的集合，则以第一个元素和最后一个元素作为测试用例<ul>
<li>这个是基于对第二种等价类划分原则进行补充。</li>
</ul>
</li>
<li>如果输入（输出）的值的个数是个取值范围，则以最大个数、最大个数+1、最小个数、最小个数-1作为测试用例数据优先选取；<ul>
<li>这个是对以上两条内容的补充</li>
</ul>
</li>
</ul>
</li>
<li>使用步骤<ul>
<li>分析需求<ul>
<li>将软件需求规格说明书划分成需求子片段</li>
<li>分析需求子片段，找出输入条件</li>
</ul>
</li>
<li>分析输入条件，判定是否需要边界值法，如果需要结合等价类划分原则划分等价类<ul>
<li>很明显，边界值划分法是基于等价类划分法的补充，一定要优先择取等价类划分，根据划分情况选择合适的数据</li>
</ul>
</li>
<li>判断是否需要边界值和需要哪种边界值方法<ul>
<li>分析等价类，是否需要边界值补充</li>
<li>结合边界值数据选取原则确定边界值的选取</li>
</ul>
</li>
<li>将选取的数据结合测试用例写作格式完成最终测试用例的编写</li>
</ul>
</li>
<li>等价类和边界值适用范围<ul>
<li>特点：不测试各种组合。测试效率比较高，效果一般。比较容易理解和易于使用的一种方法</li>
<li>适用范围：功能测试；性能测试；界面测试（GUI测试）；兼容测试</li>
<li>注意接口测试一般不选取等价类划分法去测试，一般功能测试可以使用等价类划分法</li>
</ul>
</li>
</ul>
</li>
<li>判定表<ul>
<li>分析和表达多种输入条件下完成不同动作的一种工具，这种方法能够将具有复杂逻辑关系和多种条件组合的情况表达清晰。</li>
<li>很显然，判定表是针对有限布尔集合或者输入是处于多个有限集合而言的。而一般功能的输出的集合一般只有一两个元素，然后由于有 switch-case 这种情况的出现，我们就可以考虑由判定表方法完成</li>
<li>判定表一样有三个重要的参数<ul>
<li>条件桩：输入条件<ul>
<li>表示输入取值的集合</li>
</ul>
</li>
<li>条件项：输入条件的取值<ul>
<li>表示具体输入的集合元素</li>
</ul>
</li>
<li>动作桩：输出结果<ul>
<li>表示输出的取值集合</li>
</ul>
</li>
<li>动作项：输出结果的取值<ul>
<li>表示具体输出的集合元素</li>
</ul>
</li>
</ul>
</li>
<li>使用步骤<ul>
<li>分析需求<ul>
<li>将软件需求规格说明书划分成需求子片段；</li>
</ul>
</li>
<li>分析输入条件，判定是否需要判定表设计方法，如果需要则继续</li>
<li>找出条件桩、条件项、动作桩、动作项；</li>
<li>将条件项进行组合，确定测试组合数量（条件项的个数相乘），得出测试规则；</li>
<li>分析生成的规则，对相似规则进行合并化简（合并有风险，化简需谨慎—对软件系统内部的逻辑结构非常了解；资源有限）；</li>
<li>分析每条生成的规则，必要时结合等价类边界值生成最终的测试用例。</li>
</ul>
</li>
<li>判定表适用范围<ul>
<li>从以上分析我们不难发现，判定表只使用输入输出为一个少元素或者布尔值的集合，因为如果输入输出量太大，那么根据组合数原理，测试用例量将会特别多影响测试效率。</li>
<li>所以适合功能测试，如修改密码成功与否，登录成功与否，下单成功与否。</li>
</ul>
</li>
<li>判定表特点<ul>
<li>条件桩的顺序对生成规则没有影响</li>
<li>动作桩的顺序对生成的规则没有影响</li>
<li>每条规则都是独立的相互之间没有影响</li>
</ul>
</li>
<li>判定表写法<ul>
<li><img src="/junliangl/junliangl.github.io/./images/test-theory/Testcase-Designer/3.png"></li>
<li>以上不难分析出理论上有 2**条件项的测试用例产生。</li>
</ul>
</li>
</ul>
</li>
<li>因果图<ul>
<li>因果图属于对判定表的一种补充。如果边界值法是对等价类划分法无穷转化为有穷的补充，那么因果图就是对判定表复杂的逻辑输入输出到简化的逻辑输入输出的补充</li>
<li>因果图顾名思义为 因—果 键值对，那么它有三个重要参数<ul>
<li>原因 : C（course）</li>
<li>结果:  R（result）</li>
<li>中间项：当多个原因之间不是单纯的与和或的关系，可以利用中间节点存取中间结果，使得因果图更加清晰</li>
</ul>
</li>
<li>因果有了，因果关系如下<ul>
<li>逻辑关系<ul>
<li>恒等<ul>
<li>图标<ul>
<li><img src="/junliangl/junliangl.github.io/./images/test-theory/Testcase-Designer/4.png"></li>
</ul>
</li>
</ul>
</li>
<li>与<ul>
<li>图标<ul>
<li><img src="/junliangl/junliangl.github.io/./images/test-theory/Testcase-Designer/5.png"></li>
</ul>
</li>
</ul>
</li>
<li>或<ul>
<li>图标<ul>
<li><img src="/junliangl/junliangl.github.io/./images/test-theory/Testcase-Designer/6.png"></li>
</ul>
</li>
</ul>
</li>
<li>非<ul>
<li>图标<ul>
<li><img src="/junliangl/junliangl.github.io/./images/test-theory/Testcase-Designer/7.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>制约关系<ul>
<li>互斥<ul>
<li>Exclusive</li>
<li>有多个输入(原因)，至多只能有一个为真，不可以同时都为真，可以同时都为假</li>
</ul>
</li>
<li>包容<ul>
<li>Inclusive</li>
<li>有多个输入(原因)，至少有一个为真，可以同时都为真，不可以同时都为假</li>
</ul>
</li>
<li>唯一<ul>
<li>Only</li>
<li>有多个输入(原因)，有且只能有一个为真，不可以同时都为真，不可以同时都为假</li>
</ul>
</li>
<li>要求<ul>
<li>Require</li>
<li>有两个输入(原因)，A为真，B为真；A为假，B不做要求</li>
</ul>
</li>
<li>强制<ul>
<li>Mandatory</li>
<li>有两个输入(原因)，A为真，B为假；A为假，B不做要求</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>使用步骤<ul>
<li>分析需求<ul>
<li>将软件需求规格说明书划分成需求子片段；</li>
</ul>
</li>
<li>分析输入输出，判定是否需要判定表设计方法，如果需要则是否需要借助因果图，如果需要则继续</li>
<li>分析原因和结果之间的关系，画出因果图</li>
<li>分析原因之间是否存在制约关系，做出标识</li>
<li>根据有因果图生成判定表</li>
<li>分析判定表，进行合并和化简</li>
<li>必要时结合等价类、边界值生成最终的测试用例</li>
</ul>
</li>
<li>因果图画法<ul>
<li><img src="/junliangl/junliangl.github.io/./images/test-theory/Testcase-Designer/8.png"></li>
</ul>
</li>
</ul>
</li>
<li>正交表<ul>
<li>正交表起源于伽罗瓦的数学理论。因为输入的是一组有限集合，那么多组输入可以简化。所以正交表是对判定表和因果测试用例数的简化</li>
<li>使用步骤<ul>
<li>需求分析<ul>
<li>将软件需求规格说明书划分成需求子片段</li>
</ul>
</li>
<li>分析输入输出，看是否需要用到判定表和因果图，如果需要：找出因子和状态，构造一张因子状态表</li>
<li>使用正交表工具 allpairs 进行输出测试用例<ul>
<li>正交表工具使用方法参考<ul>
<li><a target="_blank" rel="noopener" href="https://quip.com/47tSAq3WmZ9P">https://quip.com/47tSAq3WmZ9P</a></li>
</ul>
</li>
</ul>
</li>
<li>必要时可以结合等价类边界值生成最终的测试用例</li>
</ul>
</li>
<li>特点和适用范围<ul>
<li>很明显正交表极大地简化了判定表的测试用例量，所以基本判定表都会使用正交表</li>
<li>特别适合做兼容性测试，表单，配置测试等</li>
</ul>
</li>
</ul>
</li>
<li>状态迁移图<ul>
<li>定义<ul>
<li>在给定的条件下状态能够正确的跳转以及是否有非法转移和未可达的状态</li>
</ul>
</li>
<li>相关关键词如下<ul>
<li>有限状态机<ul>
<li>拥有有限个数量的状态，每个状态可以迁移到零个或多个状态</li>
</ul>
</li>
<li>状态<ul>
<li>某一时刻的表现</li>
</ul>
</li>
<li>跳转条件<ul>
<li>输入（使得状态发生变化的操作）</li>
</ul>
</li>
<li>迁移<ul>
<li>状态变化的过程</li>
</ul>
</li>
</ul>
</li>
<li>使用步骤<ul>
<li>将软件需求规格说明书划分成需求子片段</li>
<li>分析需求子片段，找出状态和条状条件</li>
<li>假定一个初始状态，以圆圈（代表状态）为节点以箭线（输入）为跳转条件画出状态迁移图</li>
<li>根据状态迁移图得出状态事件转换表（第一列代表上一状态；第二列代表跳转条件；第三列代表下一状态；第四列代表输出结果）</li>
<li>通过状态转换事件表得出状态转换树（矩形框代表状态）</li>
<li>通过状态转换树找出测试路径</li>
<li>添加一些非法测试</li>
<li>必要时可以结合等价类和边界值进行测试</li>
</ul>
</li>
</ul>
</li>
<li>场景测试法</li>
</ul>

        </article>
        <section class="post-near">
            <ul>
                
                    <li>上一篇: <a href="/junliangl/junliangl.github.io/2022/12/05/linux/docker/">docker</a></li>
                
                
                    <li>下一篇: <a href="/junliangl/junliangl.github.io/2022/12/05/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/%E6%AD%A3%E4%BA%A4%E8%A1%A8%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/">正交表工具使用方法</a></li>
                
            </ul>
        </section>
        
    
        <section class="post-author">
        
            <figure class="author-avatar">
                <img src="https://github.com/junliangl/hexo-back/blob/master/images/icon/myhead.jpg?raw=true# 作者头像" alt="Junliangl" />
            </figure>
        
            <div class="author-info">
                <h4>Junliangl</h4>
                <p>请在这里设置你的作者信息</p>
            </div>
        </section>
    
    </div>
</main>

    <footer>
    <div class="buttons">
        <a class="to-top" href="#"></a>
    </div>
    <div class="wrap min">
        <section class="widget">
            <div class="row">
                <div class="col-m-4">
                    <h3 class="title-recent">最新文章：</h3>
                    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/junliangl/junliangl.github.io/2022/12/05/python/python%E8%BF%90%E7%AE%97%E7%AC%A6/">python 运算符</a></li><li class="post-list-item"><a class="post-list-link" href="/junliangl/junliangl.github.io/2022/12/05/python/pytest/">Python pytest 模块单元测试</a></li><li class="post-list-item"><a class="post-list-link" href="/junliangl/junliangl.github.io/2022/12/05/linux/docker/">docker</a></li><li class="post-list-item"><a class="post-list-link" href="/junliangl/junliangl.github.io/2022/12/05/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/">测试用例设计方法</a></li><li class="post-list-item"><a class="post-list-link" href="/junliangl/junliangl.github.io/2022/12/05/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/%E6%AD%A3%E4%BA%A4%E8%A1%A8%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/">正交表工具使用方法</a></li><li class="post-list-item"><a class="post-list-link" href="/junliangl/junliangl.github.io/2022/12/05/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E6%A8%A1%E5%9E%8B/">软件质量模型</a></li></ul>
                </div>
                <div class="col-m-4">
                    <h3 class="title-date">历史：</h3>
                    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/junliangl/junliangl.github.io/archives/2022/12/">十二月 2022</a></li></ul>
                </div>
                <div class="col-m-4">
                    <h3 class="title-tags">标签云：</h3>
                    
                </div>
            </div>
        </section>
        <section class="sub-footer">
            <p>© 2022 <a href="/junliangl/junliangl.github.io/">onepiece</a>. All Rights Reserved. Theme By <a href="https://github.com/Dreamer-Paul/Hingle" target="_blank" rel="nofollow">Hingle</a>.</p>
        </section>
    </div>
</footer>


<script src="/junliangl/junliangl.github.io/static/kico.js"></script>
<script src="/junliangl/junliangl.github.io/static/hingle.js"></script>


<script>var hingle = new Paul_Hingle({"copyright":true,"night":true});</script>

  </body>
</html>
