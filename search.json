[{"title":"docker","url":"/2022/12/05/linux/docker/","content":"<h1 id=\"docker详解\"><a href=\"#docker详解\" class=\"headerlink\" title=\"docker详解\"></a>docker详解</h1>","categories":["linux"],"tags":["continer"]},{"title":"Python 虚拟环境 venv 的创建","url":"/2022/12/05/python/python%20venv%20%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/","content":"<h1 id=\"引入原因\"><a href=\"#引入原因\" class=\"headerlink\" title=\"引入原因\"></a>引入原因</h1><p>python 项目为了类似 docker 一样隔离提供 venv 虚拟环境</p>\n<h1 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h1><p><code>python -m venv【params】venvpath</code></p>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><p><img src=\"/./images/python/venv/1.png\"></p>\n<h2 id=\"一般情况\"><a href=\"#一般情况\" class=\"headerlink\" title=\"一般情况\"></a>一般情况</h2><p><code>python -m venv --upgrade-deps venvpath</code></p>\n<p>除非需要之前的一些 site-package 否则不加 <code>--system-site-package</code></p>\n<h2 id=\"建议\"><a href=\"#建议\" class=\"headerlink\" title=\"建议\"></a>建议</h2><p>建议加上 <code>--upgrade-deps</code></p>\n<ul>\n<li>这样无需手动更新 pip 造成无权限问题而导致原来的 pip 被删除</li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"进入虚拟环境\"><a href=\"#进入虚拟环境\" class=\"headerlink\" title=\"进入虚拟环境\"></a>进入虚拟环境</h2><p>安装好以后可以打开 Scripts&#x2F; 目录下的 <code>activate.bat</code> 批处理文件进入虚拟环境</p>\n<ul>\n<li><p><code>activate</code></p>\n<p>  <img src=\"/./images/python/venv/2.png\"></p>\n</li>\n</ul>\n<h2 id=\"其他方式进入虚拟环境\"><a href=\"#其他方式进入虚拟环境\" class=\"headerlink\" title=\"其他方式进入虚拟环境\"></a>其他方式进入虚拟环境</h2><p>也可以在 git-bash 里用 source 命令执行</p>\n<p><img src=\"/./images/python/venv/3.png\"></p>\n<h2 id=\"查看是否进入虚拟环境\"><a href=\"#查看是否进入虚拟环境\" class=\"headerlink\" title=\"查看是否进入虚拟环境\"></a>查看是否进入虚拟环境</h2><p>可以用 pip list 查看包情况判断是否进入 python 虚拟环境</p>\n<h2 id=\"退出虚拟环境\"><a href=\"#退出虚拟环境\" class=\"headerlink\" title=\"退出虚拟环境\"></a>退出虚拟环境</h2><p>同样在虚环境里执行 deactivate.bat </p>\n<p><img src=\"/./images/python/venv/4.png\"></p>\n<h2 id=\"pycharm-中使用虚拟环境\"><a href=\"#pycharm-中使用虚拟环境\" class=\"headerlink\" title=\"pycharm 中使用虚拟环境\"></a>pycharm 中使用虚拟环境</h2><p>只需新建项目里配置虚拟环境解释器路径</p>\n","categories":["python"],"tags":["python","虚拟环境"]},{"title":"Python pytest 模块单元测试","url":"/2022/12/05/python/pytest/","content":"<h1 id=\"pytest-准备工作\"><a href=\"#pytest-准备工作\" class=\"headerlink\" title=\"pytest 准备工作\"></a>pytest 准备工作</h1><p>准备 requirements.txt 写入以下插件和包，</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">`pytest`</span><br><span class=\"line\">`pytest-html`</span><br><span class=\"line\">`pytest-xdist`</span><br><span class=\"line\">`pytest-ordering`</span><br><span class=\"line\">`pytest-rerunfailures`</span><br><span class=\"line\">`allure-pytest`</span><br></pre></td></tr></table></figure>\n\n<p>安装插件</p>\n<ul>\n<li><code>pip install -r requirements.txt</code></li>\n</ul>\n<span id=\"more\"></span>\n\n<p>编写一个简单的测试脚本 test.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pytest</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestCase</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_number</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> <span class=\"literal\">True</span> <span class=\"keyword\">is</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n\n<p>运行 pytest </p>\n<ul>\n<li><code>pytest -vs test.py</code></li>\n</ul>\n<p>运行结果如下</p>\n<p><img src=\"/./images/python/pytest/1.png\"></p>\n<h1 id=\"pytest-使用方法\"><a href=\"#pytest-使用方法\" class=\"headerlink\" title=\"pytest 使用方法\"></a>pytest 使用方法</h1><h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>python test.py 脚本下 写入 main 方法调用 pytest.main() 去执行</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    pytest.main([<span class=\"string\">&#x27;-s&#x27;</span>, <span class=\"string\">&#x27;./test_number.py&#x27;</span>])</span><br></pre></td></tr></table></figure>\n\n<p>终端模式下也可以通过 pytest 命令执行</p>\n<ul>\n<li><code>pytest -vs test.py</code></li>\n</ul>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><p>默认不加参数即运行</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    pytest.main()</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>pytest test.py</code></li>\n</ul>\n<p>以上默认运行以下测试用例</p>\n<ul>\n<li>名字带有 test 开头或 test 结尾的 python 模块</li>\n<li>名字以 Test 开头且不能含有 <strong>init</strong> 方法的类</li>\n<li>名字以 test 开头的方法</li>\n</ul>\n<h3 id=\"常用的参数解释\"><a href=\"#常用的参数解释\" class=\"headerlink\" title=\"常用的参数解释\"></a>常用的参数解释</h3><p><code>-s</code></p>\n<ul>\n<li>打印输出调试信息</li>\n</ul>\n<p><code>-v</code></p>\n<ul>\n<li>输出更详细的信息</li>\n</ul>\n<p><code>-n number</code> (输入几个线程)</p>\n<ul>\n<li>多线程或分布式运行</li>\n</ul>\n<p><code>--reruns number</code> (输入重跑次数)</p>\n<ul>\n<li>运行用例失败重跑</li>\n</ul>\n<p><code>-x</code></p>\n<ul>\n<li>只要一个用例失败那么停止测试</li>\n</ul>\n<p><code>--maxfail=number</code></p>\n<ul>\n<li>出现 number 次用例失败就停止测试</li>\n</ul>\n<p><code>-k string</code></p>\n<ul>\n<li>根据测试用例的部分字符串(string)指定</li>\n</ul>\n<p><code>-rA</code></p>\n<ul>\n<li>测试结果的简单统计</li>\n</ul>\n<p><code>-m</code></p>\n<ul>\n<li>指定被 <code>pytest.mark</code> 标记过的方法</li>\n</ul>\n<h3 id=\"编辑配置文件\"><a href=\"#编辑配置文件\" class=\"headerlink\" title=\"编辑配置文件\"></a>编辑配置文件</h3><p>编辑 pytest.ini 配置文件达到命令行运行的效果。配置好后 只需要 pytest 即可一键运行</p>\n<p>系统根目录下创建 pytest.ini 配置文件</p>\n<ul>\n<li><code>touch pytest.ini</code></li>\n</ul>\n<p>修改该文件编码格式为 ANSI 格式，创建好需要更改编码格式</p>\n<p>作用</p>\n<ul>\n<li>改变 pytest 的默认行为，无需命令行输出冗余命令</li>\n</ul>\n<p>运行规则</p>\n<ul>\n<li><p>pytest 自动读取 pytest.ini 配置文件并按照配置文件规则执行</p>\n</li>\n<li><p>一些具体参数如下 pytest.ini</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">`[pytest]`</span><br><span class=\"line\">`#encoding = ANSI`</span><br><span class=\"line\"></span><br><span class=\"line\">`#命令行参数，用空格分隔`</span><br><span class=\"line\">`addopts = -vs` </span><br><span class=\"line\">`#测试用例的文件路径`</span><br><span class=\"line\">`testpaths = .`</span><br><span class=\"line\">`#配置测试搜素的 python 文件名称`</span><br><span class=\"line\">`python_files = test*.py</span><br><span class=\"line\">#配置测试搜索的测试类名</span><br><span class=\"line\">python_classes = Test*`</span><br><span class=\"line\">`#配置测试搜索的测试函数名`</span><br><span class=\"line\">`python_functions = test*`</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"常用的装饰器\"><a href=\"#常用的装饰器\" class=\"headerlink\" title=\"常用的装饰器\"></a>常用的装饰器</h2><p>有时候我们希望某个方法有专门的作用和不同的作用那么就可以采用 pytest装饰器修饰</p>\n<ul>\n<li><p><code>@pytest.mark.yourname</code></p>\n<p>  用该装饰器装饰的方法可以用 <code>pytest -m &quot;yourname&quot;</code>进行操作</p>\n<p>  多个被 mark 过的方法 可以使用逻辑运算符and or not进行连接</p>\n<ul>\n<li><p>如 <code>pytest -m &quot;first or second&quot;</code></p>\n<p>  表示 first 方法 和 second 方法都被执行</p>\n</li>\n</ul>\n</li>\n<li><p><code>@pytest.mark.skip(reason=yourreasons)</code></p>\n<ul>\n<li>用该装饰器装饰的方法会被 pytest 无条件跳过</li>\n</ul>\n</li>\n<li><p><code>@pytest.mark.skipif(condition=yourcondition, reason=yourreasons)</code></p>\n<ul>\n<li>用该装饰器装饰的方法会被 pytest 判定:如果 condition 表达式为 True，则跳过该测试，反之则不跳过</li>\n</ul>\n</li>\n<li><p><code>@pytest.mark.run(order=number)</code></p>\n<ul>\n<li>用该装饰器装饰的方法会被 pytest 识别并依照 number 的值的顺序跑测试用例</li>\n</ul>\n</li>\n<li><p><code>@pytest.fixture(scope=scope, params=params, autouse=bool, ids=ids, name=name)</code></p>\n<p>  用fixtrue标记的方法一般用于前置和后置处理，类似 setup &amp; teardown 的功能</p>\n<p>  其中 scope 参数有以下四个值:</p>\n<ul>\n<li><p>“function”</p>\n<p>  代表着作用于 方法</p>\n</li>\n<li><p>“class”</p>\n<p>  代表着作用于 类</p>\n</li>\n<li><p>“modules”</p>\n<p>  代表着作用于一个 python 文件</p>\n</li>\n<li><p>“sessions”</p>\n<p>  代表着作用于整个 pytest 测试流程</p>\n</li>\n</ul>\n<p>  其中 autouse 参数有 True 和 False 两个 bool 值</p>\n<ul>\n<li>如果 autouse&#x3D;True，那么默认测试用例方法都会执行fixture，前提是在自己的scope里</li>\n</ul>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@pytest.fixture(<span class=\"params\">scope=<span class=\"string\">&quot;function&quot;</span>, autouse=<span class=\"literal\">True</span>, params=[(<span class=\"params\"><span class=\"string\">&quot;这是&quot;</span>, <span class=\"string\">&quot;first&quot;</span></span>), (<span class=\"params\"><span class=\"string\">&quot;这是&quot;</span>, <span class=\"string\">&quot;second&quot;</span></span>)]</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">sayhello</span>(<span class=\"params\">request</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;测试开始&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> request.param</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;测试结束&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestCase</span>:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @pytest.mark.run(<span class=\"params\">order=<span class=\"number\">3</span></span>)</span></span><br><span class=\"line\">    <span class=\"comment\"># @pytest.mark.first</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_number</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果 autouse&#x3D;Flase，那么测试用例方法参数需要添加 fixture 修饰的方法名字  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@pytest.fixture(<span class=\"params\">scope=<span class=\"string\">&quot;function&quot;</span>, autouse=<span class=\"literal\">False</span>, params=[(<span class=\"params\"><span class=\"string\">&quot;这是&quot;</span>, <span class=\"string\">&quot;first&quot;</span></span>), (<span class=\"params\"><span class=\"string\">&quot;这是&quot;</span>, <span class=\"string\">&quot;second&quot;</span></span>)]</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">sayhello</span>(<span class=\"params\">request</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;测试开始&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> request.param</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;测试结束&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestCase</span>:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @pytest.mark.run(<span class=\"params\">order=<span class=\"number\">3</span></span>)</span></span><br><span class=\"line\">    <span class=\"comment\"># @pytest.mark.first</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_number</span>(<span class=\"params\">self, sayhello</span>):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>params 参数控制着传参</p>\n<p><code>params=[(&quot;这是&quot;, &quot;first&quot;), (&quot;这是&quot;, &quot;second&quot;)]</code></p>\n<p>其中 params 可以等于一个 列表或字典，或者 字典列表与元祖列表</p>\n<p>如果要获得 params 的参数，则fxiture修饰的方法需要添加固定的 request 参数，且返回request.param 用于测试方法接受</p>\n<p>如果测试方法要接收 params 参数，即时autouse&#x3D;True，也要在测试方法参数上添加需要的fixture方法名</p>\n<ul>\n<li><p>未加方法名结果</p>\n<p>  <img src=\"/./images/python/pytest/2.png\"></p>\n</li>\n<li><p>添加方法名结果</p>\n<p>  <img src=\"/./images/python/pytest/3.png\"></p>\n</li>\n</ul>\n</li>\n<li><p>借助python yeild 生成器控制前置和后置输出</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@pytest.fixture(<span class=\"params\">scope=<span class=\"string\">&quot;function&quot;</span>, autouse=<span class=\"literal\">True</span>, params=[(<span class=\"params\"><span class=\"string\">&quot;这是&quot;</span>, <span class=\"string\">&quot;first&quot;</span></span>), (<span class=\"params\"><span class=\"string\">&quot;这是&quot;</span>, <span class=\"string\">&quot;second&quot;</span></span>)]</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">sayhello</span>(<span class=\"params\">request</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;测试开始&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> request.param</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;测试结束&quot;</span>)</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>实际使用情况</p>\n<p>一般情况下 pytest 有一个机制:即把 fixture 集中放入一个名叫 conftest.py 的文件下，pytest会自动识别该文件并作出相应的响应作用域</p>\n<p>该文件可以存放在任何目录下且只对当前目录及当前路径以下的目录下起作用</p>\n<p><img src=\"/./images/python/pytest/4.png\"></p>\n</li>\n</ul>\n</li>\n<li><p><code>@pytest.mark.parametrize(argsname，argsvalues)</code></p>\n<p>  用该装饰器修饰的方法可以进行参数化</p>\n<p>  argsname 代表着参数名，argsvalues代表参数值</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pytest</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestCase2</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">​    @pytest.mark.parametrize(argnames=<span class=\"string\">&quot;a&quot;</span>, argvalues=[<span class=\"string\">&quot;FIRST&quot;</span>, <span class=\"string\">&quot;SECOND&quot;</span>])</span><br><span class=\"line\">​    <span class=\"keyword\">def</span> <span class=\"title function_\">test_number</span>(<span class=\"params\">self, a: <span class=\"built_in\">list</span></span>):</span><br><span class=\"line\">​        <span class=\"built_in\">print</span>(a)</span><br></pre></td></tr></table></figure>\n\n<p>  结果</p>\n<p>  <img src=\"/./images/python/pytest/5.png\"></p>\n</li>\n</ul>\n","categories":["python","测试"],"tags":["python","pytest","测试工具"]},{"title":"python 变量的作用域","url":"/2022/12/08/python/python%20%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/","content":"<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><ul>\n<li><p><a href=\"https://www.bilibili.com/video/BV1xv4y1S7ov/?spm_id_from=333.880.my_history.page.click&amp;vd_source=f9937d98d0a8cc08ef5248c3c127d588\">https://www.bilibili.com/video/BV1xv4y1S7ov/?spm_id_from=333.880.my_history.page.click&amp;vd_source=f9937d98d0a8cc08ef5248c3c127d588</a></p>\n</li>\n<li><p><a href=\"https://www.bilibili.com/video/BV1vQ4y1D7Ct/?p=2&amp;spm_id_from=pageDriver&amp;vd_source=f9937d98d0a8cc08ef5248c3c127d588\">https://www.bilibili.com/video/BV1vQ4y1D7Ct/?p=2&amp;spm_id_from=pageDriver&amp;vd_source=f9937d98d0a8cc08ef5248c3c127d588</a></p>\n</li>\n<li><p><a href=\"https://www.runoob.com/python3/python3-namespace-scope.html\">https://www.runoob.com/python3/python3-namespace-scope.html</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/cadi2011/article/details/52457754\">https://blog.csdn.net/cadi2011/article/details/52457754</a></p>\n<p><img src=\"/./images/python/variable/1.png\"></p>\n</li>\n</ul>\n<p>变量分为 内置变量，全局变量，类变量，实例变量，局部变量</p>\n<p>python 使用变量作用域一般要遵循 LEGB（本地，上层嵌套，全局，内置）</p>\n<span id=\"more\"></span>\n\n<h1 id=\"内置变量\"><a href=\"#内置变量\" class=\"headerlink\" title=\"内置变量\"></a>内置变量</h1><h2 id=\"概念和范围\"><a href=\"#概念和范围\" class=\"headerlink\" title=\"概念和范围\"></a>概念和范围</h2><p>Python 语言内置的名称，比如函数名 <code>abs</code>、<code>char</code> 和异常名称 <code>BaseException</code>、<code>Exception</code> 等等</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(Exception)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/2.png\"></p>\n<h1 id=\"全局变量\"><a href=\"#全局变量\" class=\"headerlink\" title=\"全局变量\"></a>全局变量</h1><h2 id=\"概念和范围-1\"><a href=\"#概念和范围-1\" class=\"headerlink\" title=\"概念和范围\"></a>概念和范围</h2><p>模块内、所有方法外、所有类外。一般全局变量都不会在任何结构体内，一般位于 python 文件的最外层。可以被本模块的所有结构体给访问</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">global_arg = <span class=\"string\">&quot;全局变量&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test1</span>(<span class=\"params\">cls</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;test1可以访问<span class=\"subst\">&#123;global_arg&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">test2</span>():</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;test2可以访问<span class=\"subst\">&#123;global_arg&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">def</span> <span class=\"title function_\">test3</span>():</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;test3可以访问<span class=\"subst\">&#123;global_arg&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            test3()</span><br><span class=\"line\"></span><br><span class=\"line\">        test2()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    A.test1() </span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/3.png\"></p>\n<p>以上可以看出在一个类里的方法，和方法里的内部方法都可以访问最外层的 global_arg 全局变量</p>\n<h2 id=\"全局变量的声明\"><a href=\"#全局变量的声明\" class=\"headerlink\" title=\"全局变量的声明\"></a>全局变量的声明</h2><p>如果是对局部变量 读 的操作，可以省去 <code>global</code> 关键字的声明，但是，为了区分局部变量和全局变量，建议使用全局变量都应该申明 <code>global</code></p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">global_arg = <span class=\"string\">&quot;全局变量&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test1</span>(<span class=\"params\">cls</span>):</span><br><span class=\"line\">        global_arg = <span class=\"string\">&quot;局部变量1&quot;</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;test1可以访问<span class=\"subst\">&#123;global_arg&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">test2</span>():</span><br><span class=\"line\">            global_arg = <span class=\"string\">&quot;局部变量2&quot;</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;test2可以访问<span class=\"subst\">&#123;global_arg&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">def</span> <span class=\"title function_\">test3</span>():</span><br><span class=\"line\">                global_arg = <span class=\"string\">&quot;局部变量3&quot;</span></span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;test3可以访问<span class=\"subst\">&#123;global_arg&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            test3()</span><br><span class=\"line\"></span><br><span class=\"line\">        test2()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    A.test1()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/4.png\"></p>\n<p>从以上结果我们可以分析出当存在局部变量重名时优先使用的是局部变量</p>\n<p>给全局变量声明 <code>global</code> 关键字</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">global_arg = <span class=\"string\">&quot;全局变量&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test1</span>(<span class=\"params\">cls</span>):</span><br><span class=\"line\">        global_arg = <span class=\"string\">&quot;局部变量1&quot;</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;test1可以访问<span class=\"subst\">&#123;global_arg&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">test2</span>():</span><br><span class=\"line\">            <span class=\"keyword\">global</span> global_arg</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;test2可以访问<span class=\"subst\">&#123;global_arg&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">def</span> <span class=\"title function_\">test3</span>():</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;test3可以访问<span class=\"subst\">&#123;global_arg&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">            test3()</span><br><span class=\"line\"></span><br><span class=\"line\">        test2()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    A.test1()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/5.png\"></p>\n<p>通过以上信息发现，声明 <code>global</code> 关键字后该变量以后的所有局部作用域都会使用声明的全局变量</p>\n<p>如果是对局部变量有操作，如赋值等的操作，一定不能 <code>global</code> 关键字的声明，否则会抛出 <code>UnboundLocalError</code> 错误</p>\n<h3 id=\"声明全局变量的好处\"><a href=\"#声明全局变量的好处\" class=\"headerlink\" title=\"声明全局变量的好处\"></a>声明全局变量的好处</h3><p>声明全局变量的好处是避免未定义局部变量的异常，来看下面的例子</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">global_arg = <span class=\"string\">&quot;全局变量&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(global_arg)</span><br><span class=\"line\">        global_arg = global_arg + <span class=\"string\">&quot;局部变量&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> UnboundLocalError <span class=\"keyword\">as</span> u:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(u)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/6.png\"></p>\n<h3 id=\"global-正确使用方法\"><a href=\"#global-正确使用方法\" class=\"headerlink\" title=\"global 正确使用方法\"></a>global 正确使用方法</h3><p>即使 <code>print(global_arg)</code>在前，依旧无法打印出来，因为后面语句有赋值操作，解释器默认以为 <code>global_arg</code> 为局部变量，而又没有声明全局变量，则会抛出异常</p>\n<p>以下为正确使用方法</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">global_arg = <span class=\"string\">&quot;全局变量&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    <span class=\"keyword\">global</span> global_arg</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(global_arg)</span><br><span class=\"line\">        global_arg = global_arg + <span class=\"string\">&quot;局部变量&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> UnboundLocalError <span class=\"keyword\">as</span> u:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(u)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(global_arg)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/7.png\"></p>\n<p>以上不难发现不会抛出异常了，并且全局变量的修改影响到了其他作用域</p>\n<h3 id=\"全局变量的其他性质\"><a href=\"#全局变量的其他性质\" class=\"headerlink\" title=\"全局变量的其他性质\"></a>全局变量的其他性质</h3><p>全局全量还有一个性质，可以通过导包的方式给其他 python 模块使用，这使得自定义变量得以很好的跨模块使用</p>\n<p>参考链接</p>\n<ul>\n<li><a href=\"https://www.byhy.net/tut/py/basic/14/\">https://www.byhy.net/tut/py/basic/14/</a></li>\n</ul>\n<p>建立两个文件一个 test_global1.py，一个为 test_global2.py</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># test_global1.py</span></span><br><span class=\"line\"></span><br><span class=\"line\">test_int = <span class=\"number\">1</span></span><br><span class=\"line\">test_list = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    <span class=\"keyword\">global</span> test_int, test_list</span><br><span class=\"line\">    test_int += <span class=\"number\">1</span></span><br><span class=\"line\">    test_list.append(<span class=\"string\">&quot;new&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;test_global1.py中的test_int值:<span class=\"subst\">&#123;test_int&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;test_global1.py中的test_int的id值:<span class=\"subst\">&#123;<span class=\"built_in\">id</span>(test_int)&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;===========================&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;test_global1.py中的test_list值:<span class=\"subst\">&#123;test_list&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;test_global1.py中的test_list的id值:<span class=\"subst\">&#123;<span class=\"built_in\">id</span>(test_list)&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># test_global2.py</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> test_global1 <span class=\"keyword\">import</span> test_int, test_list, test</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;test_global2.py的test_int值:<span class=\"subst\">&#123;test_int&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;test_global2.py中的test_int的id值:<span class=\"subst\">&#123;<span class=\"built_in\">id</span>(test_int)&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;===========================&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;test_global2.py中的test_list值:<span class=\"subst\">&#123;test_list&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;test_global2.py中的test_list的id值:<span class=\"subst\">&#123;<span class=\"built_in\">id</span>(test_list)&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;*&quot;</span>*<span class=\"number\">80</span>)</span><br><span class=\"line\">    test_()</span><br></pre></td></tr></table></figure>\n\n<p>我们运行 test_global2.py 的后的结果</p>\n<p><img src=\"/./images/python/data-type/8.png\"></p>\n<p>我们发现成功导包成功了，但是这并不是通常意义的全局共享，而是 python 新开辟了命名空间，但是可变对象类型并没有开启新的内存空间，于是列表可以跟随变化。</p>\n<p><img src=\"/./images/python/data-type/9.png\"></p>\n<h1 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h1><h2 id=\"概念和范围-2\"><a href=\"#概念和范围-2\" class=\"headerlink\" title=\"概念和范围\"></a>概念和范围</h2><p>局部变量其实是一个狭义的概念，是相对全局变量而言的。一般我们指函数内部新定义的变量为局部变量</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">arg = <span class=\"string\">&quot;全局变量&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    arg = <span class=\"string\">&quot;局部变量&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(arg)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(arg)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/10.png\"></p>\n<p>以上不难发现，即使和全局变量重名，只要没有声明是 <code>global</code>，则它就是局部变量</p>\n<p>由于是局部变量，那么外部无法访问内部的局部变量，但是我们可以通过 闭包 的方式来访问内部的局部变量。</p>\n<ul>\n<li>参考 <a href=\"/2022/12/08/python/python%20%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/\" title=\"python 函数详解\">python 函数详解</a> 关于函数闭包的详解</li>\n</ul>\n<h2 id=\"局部变量的声明\"><a href=\"#局部变量的声明\" class=\"headerlink\" title=\"局部变量的声明\"></a>局部变量的声明</h2><p>局部变量本质如果想作为内部结构的全局变量而进行修改，但是又不能用 <code>global</code> 修饰符，因为那会声明一个全局变量，那我们就会用到另外一个关键字 <code>nonlocal</code></p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">arg = <span class=\"string\">&quot;全局变量&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test1</span>():</span><br><span class=\"line\">    arg = <span class=\"string\">&quot;局部变量1&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">inner_test1</span>():</span><br><span class=\"line\">        arg = <span class=\"string\">&quot;内部局部变量1&quot;</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(arg)</span><br><span class=\"line\"></span><br><span class=\"line\">    inner_test1()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(arg)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test2</span>():</span><br><span class=\"line\">    arg = <span class=\"string\">&quot;局部变量2&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">inner_test</span>():</span><br><span class=\"line\">        <span class=\"keyword\">nonlocal</span> arg</span><br><span class=\"line\">        arg = <span class=\"string\">&quot;内部局部变量2&quot;</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(arg)</span><br><span class=\"line\"></span><br><span class=\"line\">    inner_test()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(arg)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test1()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;********************&quot;</span>)</span><br><span class=\"line\">    test2()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;********************&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(arg)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/11.png\"></p>\n<p>从以上返回信息我们不难看出如果不加 <code>nonlocal</code> 关键字，那么将不会对之前外部的局部变量进行修改。而添加了 <code>nonlocal</code> 关键字后可以对外层的局部变量进行修改了</p>\n<p>值得注意的是：<code>nonlocal</code> 属于就近原则，默认声明上一层局部变量，所以函数嵌套不宜过多。</p>\n<h1 id=\"类变量\"><a href=\"#类变量\" class=\"headerlink\" title=\"类变量\"></a>类变量</h1><p>参考类相关文档</p>\n<ul>\n<li><a href=\"/2022/12/10/python/python%20%E7%B1%BB%E8%AF%A6%E8%A7%A3/\" title=\"python 类详解\">python 类详解</a></li>\n</ul>\n<h2 id=\"概念和范围-3\"><a href=\"#概念和范围-3\" class=\"headerlink\" title=\"概念和范围\"></a>概念和范围</h2><p>类变量本质是基于类的全局变量，但是它有独特的命名方式和访问权限</p>\n<p>类变量作用于是在全类，通过 <code>类名.变量名</code> 访问或者 <code>cls.变量名</code>或者<code> self.变量名</code>访问</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>:</span><br><span class=\"line\">    class_arg = <span class=\"string\">&quot;类变量&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test1</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(A.class_arg)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(self.class_arg)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test2</span>(<span class=\"params\">cls</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(A.class_arg)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(cls.class_arg)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    a = A()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(A.class_arg)</span><br><span class=\"line\">    a.test1()</span><br><span class=\"line\">    a.test2()</span><br></pre></td></tr></table></figure>\n\n<p>可以发现访问类变量的方式多种多样，单仅仅针对与该类或者它的子类或者外部用<code>类名.变量名</code> 的方式进行访问</p>\n<h2 id=\"类变量的命名特殊性\"><a href=\"#类变量的命名特殊性\" class=\"headerlink\" title=\"类变量的命名特殊性\"></a>类变量的命名特殊性</h2><p>类变量命名会影响其的作用域。</p>\n<p>用 __ 双下划线开头，且不以 __ 双下划线结尾的变量命名方式那么我们称之为私有的类变量，然而由于 python 的机制，这种私有只是显式的私有，并不能真正的私有</p>\n<ul>\n<li><p>参考 <a href=\"/2022/12/08/python/python%20%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/\" title=\"python 函数详解\">python 函数详解</a> 关于类方法的命名相关信息</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>:</span><br><span class=\"line\">    __class_arg = <span class=\"string\">&quot;私有类变量&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test1</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(A.__class_arg)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(self.__class_arg)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test2</span>(<span class=\"params\">cls</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(A.__class_arg)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(cls.__class_arg)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    a = A()</span><br><span class=\"line\">    a.test1()</span><br><span class=\"line\">    a.test2()</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(A.__class_arg__)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> AttributeError <span class=\"keyword\">as</span> a:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(a)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/12.png\"></p>\n</li>\n</ul>\n<p>​      以上不难看出通过私有化类变量后，外部对象 A 无法访问内部私有变量 <code>__class_arg</code></p>\n<h1 id=\"实例变量\"><a href=\"#实例变量\" class=\"headerlink\" title=\"实例变量\"></a>实例变量</h1><h2 id=\"概念和范围-4\"><a href=\"#概念和范围-4\" class=\"headerlink\" title=\"概念和范围\"></a>概念和范围</h2><p>实例变量一般来说当且仅当针对类而言。</p>\n<p>实例变量一般来说作用域也是整个类，但是实例变量的针对类的对象而言的，类变量是针对类而言的，虽然类的对象可以通过类指针的方式访问类变量，但是实例对象的访问必须是 <code>self.</code>，即对象本身去访问</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, name</span>):</span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    a = A(<span class=\"string\">&quot;实例变量&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a.name)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(A.name)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> AttributeError <span class=\"keyword\">as</span> at:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(at)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(A(<span class=\"string\">&quot;另一个实例变量&quot;</span>).name)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/13.png\"></p>\n<p>从上面我们可以看到实例变量一般由类的实例对象取访问，如果类本身去访问会报 AttributeError</p>\n<h2 id=\"实例变量的特殊性\"><a href=\"#实例变量的特殊性\" class=\"headerlink\" title=\"实例变量的特殊性\"></a>实例变量的特殊性</h2><p>对于一个类来说，实例变量一般是在构造方法中定义，因为类的初始化过程中一般要主动调用构造方法 <code>__init__()</code>，但是也可以在其他类的方法里构造实例方法，但不建议这么使用，因为不一定会调用其他类的方法</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, name</span>):</span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        self.age = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    a = A(<span class=\"string\">&quot;实例变量&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(a.age)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> AttributeError <span class=\"keyword\">as</span> at:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(at)</span><br><span class=\"line\">    a.test()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a.age)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/14.png\"></p>\n<p>以上不难发现可以在其他函数里定义实例变量，但是一定要运行了该函数才能被对象调用</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>python 一切皆为对象，那么类和函数依旧是对象，也可以作为变量传值。但是依旧会遵守上面相关的规定</p>\n<ul>\n<li>参考 <a href=\"/2022/12/08/python/python%20%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/\" title=\"python 函数详解\">python 函数详解</a> 关于高阶函数对于函数作为变量的解释</li>\n<li>参考 <a href=\"/2022/12/10/python/python%20%E7%B1%BB%E8%AF%A6%E8%A7%A3/\" title=\"python 类详解\">python 类详解</a> 关于类对象的解释</li>\n</ul>\n","categories":["python"],"tags":["python","变量"]},{"title":"python 内存详解","url":"/2022/12/10/python/python%20%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/","content":"<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><ul>\n<li><a href=\"https://docs.python.org/zh-cn/3/c-api/memory.html#overview\">https://docs.python.org/zh-cn/3/c-api/memory.html#overview</a></li>\n</ul>\n<p>本文可能会涉及 python 驻留机制，请参考</p>\n<ul>\n<li><a href=\"/2022/12/08/python/python%20%E9%A9%BB%E7%95%99%E6%9C%BA%E5%88%B6/\" title=\"python 驻留机制\">python 驻留机制</a></li>\n</ul>\n<p>前置知识</p>\n<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1VP4y1b7HJ/?spm_id_from=333.999.0.0&amp;vd_source=f9937d98d0a8cc08ef5248c3c127d588\">https://www.bilibili.com/video/BV1VP4y1b7HJ/?spm_id_from=333.999.0.0&amp;vd_source=f9937d98d0a8cc08ef5248c3c127d588</a></li>\n</ul>\n<h1 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h1><p>参考链接</p>\n<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1qV4y1J7gY/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f9937d98d0a8cc08ef5248c3c127d588\">https://www.bilibili.com/video/BV1qV4y1J7gY/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f9937d98d0a8cc08ef5248c3c127d588</a></li>\n</ul>\n<h2 id=\"python-官方原文\"><a href=\"#python-官方原文\" class=\"headerlink\" title=\"python 官方原文\"></a>python 官方原文</h2><p>在 Python 中，内存管理涉及到一个包含所有 Python 对象和数据结构的私有堆（heap）。这个私有堆的管理由内部的 <em>Python 内存管理器（Python memory manager）</em> 保证。Python 内存管理器有不同的组件来处理各种动态存储管理方面的问题，如共享、分割、预分配或缓存。在最底层，一个原始内存分配器通过与操作系统的内存管理器交互，确保私有堆中有足够的空间来存储所有与 Python 相关的数据。在原始内存分配器的基础上，几个对象特定的分配器在同一堆上运行，并根据每种对象类型的特点实现不同的内存管理策略。例如，整数对象在堆内的管理方式不同于字符串、元组或字典，因为整数需要不同的存储需求和速度与空间的权衡。因此，Python 内存管理器将一些工作分配给对象特定分配器，但确保后者在私有堆的范围内运行。</p>\n<h2 id=\"实际组成\"><a href=\"#实际组成\" class=\"headerlink\" title=\"实际组成\"></a>实际组成</h2><p>上面的名词 “私有堆”属于官方说法，但是实际上：一般由以下组成</p>\n<ol>\n<li>堆内存</li>\n<li>常量区</li>\n<li>方法区</li>\n</ol>\n<p>说明了 python 内存架构是只要是对象都会存储在堆（heap）中。这不同于 java 中的 数字类型（int…）。java 是存储在不太稳定的栈（stack）中，这也很好的说明了为什么 python 是动态语言类型</p>\n<p>具体有关动态类型机制请参考</p>\n<ul>\n<li><a href=\"/2022/12/10/python/python%20%E7%B1%BB%E8%AF%A6%E8%A7%A3/\" title=\"python 类详解\">python 类详解</a> 中关于动态绑定机制相关内容</li>\n</ul>\n<h2 id=\"python-堆内存管理\"><a href=\"#python-堆内存管理\" class=\"headerlink\" title=\"python 堆内存管理\"></a>python 堆内存管理</h2><p>Python 堆内存的管理是由解释器来执行，用户对它没有控制权，即使他们经常操作指向堆内内存块的对象指针，理解这一点十分重要。Python 对象和其他内部缓冲区的堆空间分配是由 Python 内存管理器按需通过 Python&#x2F;C API 函数进行的。</p>\n<p>这一点理解起来很容易，因为我们所能肉眼看见的都是对象的引用，只能操作对象的引用，即时使用 del 关键字，也是删除一个引用计数，并不能真正地释放该引用所指向的内存。因为真正释放内存是由 python 的解释器完成的，当某个对象被引用计数为0是，python 解释器会调用垃圾回收机制去释放它。</p>\n<h1 id=\"对象的引用和对象\"><a href=\"#对象的引用和对象\" class=\"headerlink\" title=\"对象的引用和对象\"></a>对象的引用和对象</h1><p>这两者是不同的概念。一般来说，我们人所设定且肉眼可见的变量，函数，类等都是属于对象的引用，而对象本身是存储在内存中的，并且有一个内存地址，我们通过对象的引用指向该内存地址来操作对象本身。</p>\n<h2 id=\"多数情况下\"><a href=\"#多数情况下\" class=\"headerlink\" title=\"多数情况下\"></a>多数情况下</h2><p>在很多情况下，我们说的对象基本指的对象的引用。</p>\n<p>python 和大多数语言一样，对象的引用（以下简称引用）是存放在 栈（stack）中的，而对象由上面内存管理机制得出，是存放在 堆内存（heap），常量池中。</p>\n<p>内存图关系如下</p>\n<p><img src=\"/./images/python/memory/1.png\"></p>\n<ul>\n<li>通过以上不难发现，堆和常量区中的对象由三部分组成：id，type，value。那么栈中的引用就会指向它们对象的 id ，通过这种方式操作对象，所以我们并没有直接操作对象而是操作引用。以下我们会简化内存的框图。</li>\n</ul>\n<h1 id=\"python一切皆对象\"><a href=\"#python一切皆对象\" class=\"headerlink\" title=\"python一切皆对象\"></a>python一切皆对象</h1><p>python 宗旨是一切都是对象，那么 python 的数据类型包括</p>\n<ol>\n<li>数字类型</li>\n<li>字符串类型</li>\n<li>列表类型</li>\n<li>元组类型</li>\n<li>字典类型</li>\n<li>集合类型</li>\n<li>函数类型</li>\n<li>类类型</li>\n</ol>\n<h1 id=\"数字类型\"><a href=\"#数字类型\" class=\"headerlink\" title=\"数字类型\"></a>数字类型</h1><h2 id=\"整数类型的内存机制\"><a href=\"#整数类型的内存机制\" class=\"headerlink\" title=\"整数类型的内存机制\"></a>整数类型的内存机制</h2><p>数字类型是不可变类型，是因为当变化数字类型的值时，实则是让引用指向了新的对象，这样它的内存地址就发生了变化。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">a: <span class=\"built_in\">int</span> = <span class=\"number\">1</span></span><br><span class=\"line\">b: <span class=\"built_in\">float</span> = <span class=\"number\">2.</span></span><br><span class=\"line\">c: <span class=\"built_in\">complex</span> = <span class=\"number\">3</span> + <span class=\"number\">4j</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;变化前a的id:<span class=\"subst\">&#123;<span class=\"built_in\">id</span>(a)&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;变化前b的id:<span class=\"subst\">&#123;<span class=\"built_in\">id</span>(b)&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;变化前c的id:<span class=\"subst\">&#123;<span class=\"built_in\">id</span>(c)&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">a: <span class=\"built_in\">int</span> = <span class=\"number\">10</span></span><br><span class=\"line\">b: <span class=\"built_in\">float</span> = <span class=\"number\">20.</span></span><br><span class=\"line\">c: <span class=\"built_in\">complex</span> = <span class=\"number\">30</span> + <span class=\"number\">40j</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;-&quot;</span>*<span class=\"number\">50</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;变化后a的id:<span class=\"subst\">&#123;<span class=\"built_in\">id</span>(a)&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;变化后b的id:<span class=\"subst\">&#123;<span class=\"built_in\">id</span>(b)&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;变化后c的id:<span class=\"subst\">&#123;<span class=\"built_in\">id</span>(c)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/memory/2.png\"><br>    - 以上不难看出当 a，b，c 的值发生改变后，a，b，c 三个引用都分别指向了新的对象。</p>\n<p>内存图如下</p>\n<p><img src=\"/./images/python/memory/3.png\"><br>    - 以上内存分析显示由于更改了值，那么引用指向了新的对象，所以内存地址发生了变化。</p>\n<h2 id=\"整数类型的特殊内存机制\"><a href=\"#整数类型的特殊内存机制\" class=\"headerlink\" title=\"整数类型的特殊内存机制\"></a>整数类型的特殊内存机制</h2><p>如果有两个不同的引用指向“相同”的对象，python 会判断是否启用驻留机制，但是 python 命令行和 pycharm会优化</p>\n<ul>\n<li>更多驻留机制请参考 <a href=\"/2022/12/08/python/python%20%E9%A9%BB%E7%95%99%E6%9C%BA%E5%88%B6/\" title=\"python 驻留机制\">python 驻留机制</a></li>\n</ul>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    a = <span class=\"number\">1</span></span><br><span class=\"line\">    b = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(a), <span class=\"built_in\">id</span>(b))</span><br><span class=\"line\">    c = <span class=\"number\">2500</span></span><br><span class=\"line\">    d = <span class=\"number\">2500</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(c), <span class=\"built_in\">id</span>(d))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>内存图如下</p>\n<p><img src=\"/./images/python/memory/4.png\"></p>\n<ul>\n<li>以上分析不难看出，如果在交互模式下运行，解释器会单独给 d&gt;256 再开一个内存空间。通常我们也称 -5~256 整数区间为小常量区</li>\n</ul>\n<h3 id=\"整数类型的引用删除再次新增引用\"><a href=\"#整数类型的引用删除再次新增引用\" class=\"headerlink\" title=\"整数类型的引用删除再次新增引用\"></a>整数类型的引用删除再次新增引用</h3><h4 id=\"小常量区\"><a href=\"#小常量区\" class=\"headerlink\" title=\"小常量区\"></a>小常量区</h4><p>对于小常量区我们如果 del 之前的引用，之后再引用指向相同的对象，地址是一直不变的</p>\n<p><img src=\"/./images/python/memory/5.png\"><br>        - 此时系统并未给 c 开辟单独的一个 50 内存空间</p>\n<p><img src=\"/./images/python/memory/6.png\"></p>\n<ul>\n<li>很明显看出没有新的内存空间 50</li>\n</ul>\n<h4 id=\"大常量区\"><a href=\"#大常量区\" class=\"headerlink\" title=\"大常量区\"></a>大常量区</h4><p>对于大常量区 &lt;5，&gt;256 的区间整数，在删除后新增引用的情况是保持和最新开辟空间的那个地址相同</p>\n<p><img src=\"/./images/python/memory/7.png\"></p>\n<ul>\n<li>以上不难看出，开辟了新的三个 900 内存空间，但是删除前 3 个 引用时，第四个引用并没有再单独开辟新的空间，而是继续指向最新的也就是第三个引用的内存地址。这点很重要，因为后面很多机制就会类似。</li>\n</ul>\n<p><img src=\"/./images/python/memory/8.png\"></p>\n<ul>\n<li>以上机制对于 pycharm 或命令行来说默认优化了，因为运行不是一行一行解释，而是优化后节省内存空间的方法因此，a，b，c，都会指向同一个 900</li>\n</ul>\n<h2 id=\"float-类型\"><a href=\"#float-类型\" class=\"headerlink\" title=\"float 类型\"></a><code>float</code> 类型</h2><p>由于 <code>float</code> 类型数字没有所谓的驻留机制，那么每单独定义一个引用，都会新开一个内存空间</p>\n<p><img src=\"/./images/python/memory/9.png\"></p>\n<p>内存图</p>\n<p><img src=\"/./images/python/memory/10.png\"></p>\n<ul>\n<li>可以看出就可以把 <code>float</code> 当做大常量区的数据处理就行</li>\n</ul>\n<h3 id=\"96-类型的引用删除再次新增引用\"><a href=\"#96-类型的引用删除再次新增引用\" class=\"headerlink\" title=\"&#96; 类型的引用删除再次新增引用\"></a>&#96; 类型的引用删除再次新增引用</h3><p>同大整数类型一般，不做过多赘述</p>\n<p>值得注意的是，pycharm 和命令行模式依旧会对该机制进行优化，显示还是指向了同一对象</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    a = <span class=\"number\">1000.0</span></span><br><span class=\"line\">    b = <span class=\"number\">1000.0</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a <span class=\"keyword\">is</span> b)</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">        test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/memory/11.png\"></p>\n<h2 id=\"complex-类型\"><a href=\"#complex-类型\" class=\"headerlink\" title=\"complex 类型\"></a><code>complex</code> 类型</h2><p> 对于 <code>complex</code> 类型的数字同 <code>float</code>，不做过多赘述</p>\n<p><img src=\"/./images/python/memory/12.png\"></p>\n<h1 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h1><h2 id=\"字符串的普通内存机制\"><a href=\"#字符串的普通内存机制\" class=\"headerlink\" title=\"字符串的普通内存机制\"></a>字符串的普通内存机制</h2><p>python 字符串有类似数字类型的内存机制</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">a: <span class=\"built_in\">str</span> = <span class=\"string\">&quot;hello&quot;</span><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;变化前a的id:<span class=\"subst\">&#123;<span class=\"built_in\">id</span>(a)&#125;</span>&quot;</span>)</span><br><span class=\"line\">a: <span class=\"built_in\">str</span> = <span class=\"string\">&quot;hello world&quot;</span><span class=\"built_in\">print</span>(<span class=\"string\">&quot;-&quot;</span>*<span class=\"number\">50</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;变化后a的id:<span class=\"subst\">&#123;<span class=\"built_in\">id</span>(a)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/memory/13.png\"><br>    - 以上不难看出依旧是内存地址发生了改变</p>\n<p>内存图如下</p>\n<p><img src=\"/./images/python/memory/14.png\"></p>\n<h2 id=\"字符串的特殊内存机制\"><a href=\"#字符串的特殊内存机制\" class=\"headerlink\" title=\"字符串的特殊内存机制\"></a>字符串的特殊内存机制</h2><p>由于字符串一样具有驻留机制，所以我们讨论没有驻留机制的情况</p>\n<p>由于对于字符串我们有字面量相加 和引用相加，那么就有两种情况</p>\n<h3 id=\"字面量相加\"><a href=\"#字面量相加\" class=\"headerlink\" title=\"字面量相加\"></a>字面量相加</h3><p>对于字面量相加的情况 python 会优先在常量区寻找有没有对应的内存，如果没有才开辟新的空间</p>\n<p><img src=\"/./images/python/memory/15.png\"></p>\n<ul>\n<li>内存图</li>\n</ul>\n<p><img src=\"/./images/python/memory/16.png\"></p>\n<ul>\n<li>注意这是针对满足驻留情况的，若不满足驻留情况则会单独开辟空间</li>\n</ul>\n<p><img src=\"/./images/python/memory/17.png\"><br><img src=\"/./images/python/memory/18.png\"></p>\n<p>对于以上的两种情况，pycharm 和命令行还是会进行优化</p>\n<h3 id=\"引用相加\"><a href=\"#引用相加\" class=\"headerlink\" title=\"引用相加\"></a>引用相加</h3><p>引用相加不同与整数类型，会产生一个新的对象，然而这新的对象并未在常量区，而是在堆内存里</p>\n<p><img src=\"/./images/python/memory/19.png\"><br><img src=\"/./images/python/memory/20.png\"></p>\n<p>添加多个的情况</p>\n<p><img src=\"/./images/python/memory/21.png\"><br><img src=\"/./images/python/memory/22.png\">          </p>\n<ul>\n<li>通过以上我们基本可以确定如果是引用相加或者调用方法形式会在堆中新开辟一个内存空间并且不会共享</li>\n</ul>\n<p>注意这个情况在 pycharm 中并没有被优化</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    a = <span class=\"string\">&quot;hello&quot;</span></span><br><span class=\"line\">    b = <span class=\"string\">&quot;world&quot;</span></span><br><span class=\"line\">    c = <span class=\"string\">&quot;helloworld&quot;</span></span><br><span class=\"line\">    d = a + b</span><br><span class=\"line\">    e = a + b</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(c <span class=\"keyword\">is</span> d)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(c <span class=\"keyword\">is</span> e)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(d <span class=\"keyword\">is</span> e)</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:        </span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/memory/23.png\"></p>\n<h3 id=\"字符串的引用删除再次新增引用\"><a href=\"#字符串的引用删除再次新增引用\" class=\"headerlink\" title=\"字符串的引用删除再次新增引用\"></a>字符串的引用删除再次新增引用</h3><p>和上述整数类型机制相同。即使是在堆内存中，删除引用后再次在堆内存开辟也一个空间，也是和最新的那一次相同</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    a = <span class=\"string\">&quot;hello&quot;</span></span><br><span class=\"line\">    b = <span class=\"string\">&quot;world&quot;</span></span><br><span class=\"line\">    c = <span class=\"string\">&quot;helloworld&quot;</span></span><br><span class=\"line\">    d = a + b</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(d))</span><br><span class=\"line\">    <span class=\"keyword\">del</span> d</span><br><span class=\"line\">    f = a + b</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(f))</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">      test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/memory/24.png\"></p>\n<h1 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h1><p>元组类型同样为不可变类型，原因是元组类型的每一个元素的引用都不可变化</p>\n<h2 id=\"元组的特殊内存机制\"><a href=\"#元组的特殊内存机制\" class=\"headerlink\" title=\"元组的特殊内存机制\"></a>元组的特殊内存机制</h2><p>元组类型和以上不同的是，它的对象是存储在堆内存中的。并且元组对象的元素本身存储的不是值，而是一个个引用</p>\n<p>内存图如下</p>\n<p><img src=\"/./images/python/memory/25.png\"></p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>元组之所以被称为不可变类型，是因为一旦定义好了，value1 和 value2 就不能更改指向的对象了，并且不能再新增新的 value</p>\n<h2 id=\"遵守规则\"><a href=\"#遵守规则\" class=\"headerlink\" title=\"遵守规则\"></a>遵守规则</h2><p>对于元组每个元素的内存机制，都要遵守以上和以下包括列表所有类型的规则，包括驻留机制等。但是 pycharm等和上面一样同样会优化该内存地址</p>\n<p>举个例子，若 arg 是数字类型或字符串类型时，该指向常量区还是指向常量区。这也就解释了为什么python 官方模糊了私有堆内存，统称为堆的概念</p>\n<p><img src=\"/./images/python/memory/26.png\"></p>\n<p> 内存图如下</p>\n<p><img src=\"/./images/python/memory/27.png\"></p>\n<h1 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h1><p>列表内存机制和元组大同小异，但唯一不同的是，列表它可以更改 value 指向的对象，而且还可以删除 value 和新增 value。</p>\n<p>内存图如下</p>\n<p><img src=\"/./images/python/memory/28.png\"></p>\n<h2 id=\"列表的三种拷贝机制\"><a href=\"#列表的三种拷贝机制\" class=\"headerlink\" title=\"列表的三种拷贝机制\"></a>列表的三种拷贝机制</h2><p>参考链接</p>\n<ul>\n<li><a href=\"/2022/12/07/python/python%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/\" title=\"python 基本数据类型常用方法\">python 基本数据类型常用方法</a> 关于列表有关的深浅拷贝问题</li>\n</ul>\n<h3 id=\"赋值拷贝\"><a href=\"#赋值拷贝\" class=\"headerlink\" title=\"赋值拷贝\"></a>赋值拷贝</h3><p>赋值拷贝本质是不改变原来的 value 和 list 的指向，只是新增了一个 list_copy 新的引用指向了跟 list 指向相同的对象</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    <span class=\"built_in\">list</span> = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>]]</span><br><span class=\"line\">    list_copy = <span class=\"built_in\">list</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">list</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(list_copy)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(<span class=\"built_in\">list</span>), <span class=\"built_in\">id</span>(list_copy))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/memory/29.png\"></p>\n<p>内存图如下</p>\n<p><img src=\"/./images/python/memory/30.png\"></p>\n<h3 id=\"浅拷贝解析\"><a href=\"#浅拷贝解析\" class=\"headerlink\" title=\"浅拷贝解析\"></a>浅拷贝解析</h3><p>拷贝本质一样是不改变原来的 value 和 list 的指向，只是新增了一个 list_copy 新的引用指向了跟 list 新的 id 不同的对象，但是该对象的 value 指向依旧不变</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    <span class=\"built_in\">list</span> = [[], [<span class=\"number\">1</span>, <span class=\"number\">2</span>]]</span><br><span class=\"line\">    list_copy = <span class=\"built_in\">list</span>.copy()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">list</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(list_copy)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(<span class=\"built_in\">list</span>), <span class=\"built_in\">id</span>(list_copy))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(<span class=\"built_in\">list</span>[<span class=\"number\">1</span>]), <span class=\"built_in\">id</span>(list_copy[<span class=\"number\">1</span>]))</span><br><span class=\"line\">    <span class=\"built_in\">list</span>[<span class=\"number\">1</span>].append(<span class=\"string\">&quot;新加的数据&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">list</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(list_copy)</span><br><span class=\"line\">       </span><br><span class=\"line\">       </span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p> 返回</p>\n<p><img src=\"/./images/python/memory/31.png\"></p>\n<p>内存图如下</p>\n<p><img src=\"/./images/python/memory/32.png\"></p>\n<h3 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h3><p>浅拷贝本质一样是不改变原来的 value 和 list 的指向，但是新拷贝的引用会递归指向不同的内存空间，直到每一个指向的都是不可变类型为止   </p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> copy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    <span class=\"built_in\">list</span> = [[], [<span class=\"number\">1</span>, <span class=\"number\">2</span>]]</span><br><span class=\"line\">    list_copy = copy.deepcopy(<span class=\"built_in\">list</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">list</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(list_copy)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(<span class=\"built_in\">list</span>), <span class=\"built_in\">id</span>(list_copy))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(<span class=\"built_in\">list</span>[<span class=\"number\">1</span>]), <span class=\"built_in\">id</span>(list_copy[<span class=\"number\">1</span>]))</span><br><span class=\"line\">    <span class=\"built_in\">list</span>[<span class=\"number\">1</span>].append(<span class=\"string\">&quot;新加的数据&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">list</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(list_copy)</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p> 返回</p>\n<p><img src=\"/./images/python/memory/33.png\"></p>\n<p>内存图</p>\n<p><img src=\"/./images/python/memory/34.png\"></p>\n<ul>\n<li>这就是为什么 list_copy 为什么不会像浅拷贝一样会添加新的 value2 的原因</li>\n</ul>\n<h3 id=\"遵守规则-1\"><a href=\"#遵守规则-1\" class=\"headerlink\" title=\"遵守规则\"></a>遵守规则</h3><p>对于列表每个元素的内存机制，都要遵守以上和以下包括字典等所有类型的规则，包括驻留机制等。但是 pycharm 等和上面一样同样会优化该内存地址</p>\n<p>同样的列表元素如果是数字等类型，依旧会指向常量区</p>\n<h1 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h1><p>字典涉及哈希表存储机制，这里不过多追溯</p>\n<h1 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h1><p>pass</p>\n<h1 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h1><p>函数一样也是对象，那么函数名就是对象的引用</p>\n<h2 id=\"函数的内存机制\"><a href=\"#函数的内存机制\" class=\"headerlink\" title=\"函数的内存机制\"></a>函数的内存机制</h2><p>函数的内存机制就是在栈中开辟一个引用空间，叫做 栈帧。该空间用于存放函数内的其他引用，而函数本身引用指向堆内存的对象。因为函数本身是  types.FunctionType 类的对象，所以函数本身是根据类指针指向该类。与其他类型不同的是函数会单独使用到方法区的内存。当调用函数时，先会根据调用的引用去方法区加载函数，然后生成函数对象，最后函数引用指向函数对象。当函数引用被 del 或 return 后，它其中的局部变量等也会被消亡</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    a = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>对于以上方法的运行加载内存图如下</p>\n<p><img src=\"/./images/python/memory/35.png\"></p>\n<ul>\n<li>以上看出 test 只不过是函数对象的引用，这里函数的具体是哪个对象参考 <a href=\"/2022/12/08/python/python%20%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/\" title=\"python 函数详解\">python 函数详解</a></li>\n</ul>\n<h2 id=\"解释函数闭包\"><a href=\"#解释函数闭包\" class=\"headerlink\" title=\"解释函数闭包\"></a>解释函数闭包</h2><p>通过以上解释了为什么闭包机制引用的局部变量不随着上层函数一起消亡</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    a = <span class=\"number\">50</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">back</span>(<span class=\"params\">arg</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(arg + a)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> back</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    back_ = test()</span><br><span class=\"line\">    back_(<span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n\n<p>内存图如下</p>\n<p><img src=\"/./images/python/memory/36.png\"></p>\n<p>这也就解释了为什么函数闭包后能够直接引用了，因为不仅 copy 了一份对对象的引用，还 copy 了原来局部变量的引用。即使之前函数消亡了也能够正常返回值。但值得注意的是，全局变量并不会被 copy，所以暂存不了全局变量。</p>\n<p>相当于每次初始化内层函数在它自己的栈帧里拷贝了一份和外层函数的局部变量的一个内存地址，所以能够所谓的“留住”。而全局变量是在栈中共享的，可以理解为每个栈帧里没有它的备份，每次碰到全局变量都会去栈帧外的栈去找全局变量指向的对象值。</p>\n<h2 id=\"函数参数传递的内存机制\"><a href=\"#函数参数传递的内存机制\" class=\"headerlink\" title=\"函数参数传递的内存机制\"></a>函数参数传递的内存机制</h2><p><img src=\"/./images/python/memory/37.png\"></p>\n<ul>\n<li>通过以上图了解到。方法调用给 n1 引用的对象和 n2 引用的对象新开了一个命名空间 arg1，arg2。此时 arg1 ，arg2 分别再次指向 n1 指向的对象和 n2 指向的对象。这样根据 python 变量的内存机制可以推出很多如下的性质</li>\n</ul>\n<h3 id=\"不可变类型参数\"><a href=\"#不可变类型参数\" class=\"headerlink\" title=\"不可变类型参数\"></a>不可变类型参数</h3><p>如果实际参数 args 是不可变类型，则方法修改不会影响它的内存地址(指向)。因为是新开的内存引用原对象</p>\n<p>这经常会造成非元组类的不可变类型在方法中无法修改</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">arg1: <span class=\"built_in\">str</span>, arg2: <span class=\"built_in\">int</span></span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;形参arg1:&quot;</span>, arg1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;形参arg1的内存地址:&quot;</span>, <span class=\"built_in\">id</span>(arg1))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;形参arg2:&quot;</span>, arg2)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;形参arg2的内存地址:&quot;</span>, <span class=\"built_in\">id</span>(arg2))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------------------&quot;</span>)</span><br><span class=\"line\">    arg1 = arg1.lower()</span><br><span class=\"line\">    arg2 = arg2 * <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;变化后的形参arg1:&quot;</span>, arg1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;变化后的形参arg1的内存地址:&quot;</span>, <span class=\"built_in\">id</span>(arg1))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;变化后的形参arg2:&quot;</span>, arg2)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;变化后的形参arg的内存地址:&quot;</span>, <span class=\"built_in\">id</span>(arg2))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    n1 = <span class=\"string\">&quot;HELLO WORLD!&quot;</span></span><br><span class=\"line\">    n2 = <span class=\"number\">20</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;--------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;实参n1:&quot;</span>, n1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;实参n1的内存地址:&quot;</span>, <span class=\"built_in\">id</span>(n1))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;--------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;实参n2:&quot;</span>, n2)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;实参n2的内存地址:&quot;</span>, <span class=\"built_in\">id</span>(n2))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;--------------------&quot;</span>)</span><br><span class=\"line\">    test(arg1=n1, arg2=n2)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;调用方法后实参n1:&quot;</span>, n1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;调用方法后实参n1的内存地址:&quot;</span>, <span class=\"built_in\">id</span>(n1))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;--------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;调用方法后实参n2:&quot;</span>, n2)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;调用方法后实参n2的内存地址:&quot;</span>, <span class=\"built_in\">id</span>(n2))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;--------------------&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/memory/38.png\"></p>\n<p>分析以上数据可以发现 n1，n2的内存地址不变，n1，n2的值不变</p>\n<h3 id=\"参数是元组的情况\"><a href=\"#参数是元组的情况\" class=\"headerlink\" title=\"参数是元组的情况\"></a>参数是元组的情况</h3><p>元组虽然也是不可变类型，但是方法修改不了它每个元素的内存地址，即时是这样，方法依旧可以修改元组列表元素或字典元素这种可变类型的值</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">arg1: <span class=\"built_in\">tuple</span></span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;形参arg1:&quot;</span>, arg1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;形参arg1的内存地址:&quot;</span>, <span class=\"built_in\">id</span>(arg1))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> element <span class=\"keyword\">in</span> arg1:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;&#x27;<span class=\"subst\">&#123;element&#125;</span>&#x27;的内存地址是:<span class=\"subst\">&#123;<span class=\"built_in\">id</span>(element)&#125;</span>&quot;</span>, end=<span class=\"string\">&quot;  &quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------------------&quot;</span>)</span><br><span class=\"line\">    arg1[<span class=\"number\">2</span>].append(<span class=\"number\">2</span>)</span><br><span class=\"line\">    arg1[<span class=\"number\">3</span>][<span class=\"number\">2</span>] = <span class=\"string\">&quot;second&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;变化后的形参arg1:&quot;</span>, arg1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;变化后的形参arg1的内存地址:&quot;</span>, <span class=\"built_in\">id</span>(arg1))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> element <span class=\"keyword\">in</span> arg1:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;变化后&#x27;<span class=\"subst\">&#123;element&#125;</span>&#x27;的内存地址是:<span class=\"subst\">&#123;<span class=\"built_in\">id</span>(element)&#125;</span>&quot;</span>, end=<span class=\"string\">&quot;  &quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------------------&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    n1 = (<span class=\"number\">1</span>, <span class=\"string\">&quot;hello world&quot;</span>, [<span class=\"number\">1</span>], &#123;<span class=\"number\">1</span>: <span class=\"string\">&quot;first&quot;</span>&#125;)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;--------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;实参n1:&quot;</span>, n1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;实参n1的内存地址:&quot;</span>, <span class=\"built_in\">id</span>(n1))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;--------------------&quot;</span>)</span><br><span class=\"line\">    test(arg1=n1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;调用方法后实参n1:&quot;</span>, n1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;调用方法后实参n1的内存地址:&quot;</span>, <span class=\"built_in\">id</span>(n1))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;--------------------&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/memory/39.png\"></p>\n<ul>\n<li>分析以上数据发现 n1 的内存地址不变，n1的元素内存地址也不变，但是 n1 的列表元素和字典元素的值发生了改变</li>\n</ul>\n<h3 id=\"可变类型参数\"><a href=\"#可变类型参数\" class=\"headerlink\" title=\"可变类型参数\"></a>可变类型参数</h3><p>如果实际参数 args 是可变类型，方法依旧无法修改它的内存地址。同样是因为新开的内存引用原对象，但是可以修改它的值，这必须建立在对它本身的增删改查等。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">arg1: <span class=\"built_in\">list</span></span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;形参arg1:&quot;</span>, arg1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;形参arg1的内存地址:&quot;</span>, <span class=\"built_in\">id</span>(arg1))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> element <span class=\"keyword\">in</span> arg1:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;&#x27;<span class=\"subst\">&#123;element&#125;</span>&#x27;的内存地址是:<span class=\"subst\">&#123;<span class=\"built_in\">id</span>(element)&#125;</span>&quot;</span>, end=<span class=\"string\">&quot;  &quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------------------&quot;</span>)</span><br><span class=\"line\">    arg1[<span class=\"number\">1</span>] = arg1[<span class=\"number\">1</span>].lower()</span><br><span class=\"line\">    arg1.append([<span class=\"string\">&quot;新添加的元素&quot;</span>])</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;变化后的形参arg1:&quot;</span>, arg1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;变化后的形参arg1的内存地址:&quot;</span>, <span class=\"built_in\">id</span>(arg1))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> element <span class=\"keyword\">in</span> arg1:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;变化后&#x27;<span class=\"subst\">&#123;element&#125;</span>&#x27;的内存地址是:<span class=\"subst\">&#123;<span class=\"built_in\">id</span>(element)&#125;</span>&quot;</span>, end=<span class=\"string\">&quot;  &quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------------------&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    n1 = [<span class=\"number\">1</span>, <span class=\"string\">&quot;HELLO&quot;</span>]</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;--------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;实参n1:&quot;</span>, n1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;实参n1的内存地址:&quot;</span>, <span class=\"built_in\">id</span>(n1))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;--------------------&quot;</span>)</span><br><span class=\"line\">    test(arg1=n1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;调用方法后实参n1:&quot;</span>, n1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;调用方法后实参n1的内存地址:&quot;</span>, <span class=\"built_in\">id</span>(n1))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;--------------------&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/memory/40.png\"></p>\n<ul>\n<li>分析以上数据发现 n1 的内存地址不变，n1 的元素<code>&quot;HELLO&quot;</code>的内存地址发生了改变，n1 的值同样发生了改变</li>\n</ul>\n<h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><p>参考链接如下</p>\n<ul>\n<li><a href=\"https://juejin.cn/post/6975845305447104549\">https://juejin.cn/post/6975845305447104549</a></li>\n</ul>\n<h2 id=\"类特殊的内存机制\"><a href=\"#类特殊的内存机制\" class=\"headerlink\" title=\"类特殊的内存机制\"></a>类特殊的内存机制</h2><p>类和其他不同的是，类对象的引用是保存在堆区的。这里和实例化后的类的对象的引用不同</p>\n<p><img src=\"/./images/python/memory/41.png\"></p>\n<h2 id=\"本质原因\"><a href=\"#本质原因\" class=\"headerlink\" title=\"本质原因\"></a>本质原因</h2><p>类之所以是对象因为类是 type 类的对象</p>\n<p>类其实不用声明 class 去创建，直接通过 <code>type()</code> 实例化一个类实例，只不过 class 声明更美观易懂</p>\n","categories":["python"],"tags":["python","内存机制"]},{"title":"python 基本数据类型常用方法","url":"/2022/12/07/python/python%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","content":"<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><p>以下数据类型有些内容会涉及内存驻留机制，请参考</p>\n<ul>\n<li><a href=\"/2022/12/08/python/python%20%E9%A9%BB%E7%95%99%E6%9C%BA%E5%88%B6/\" title=\"python 驻留机制\">python 驻留机制</a>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/laizhenghua/articles/12875044.html\">https://www.cnblogs.com/laizhenghua/articles/12875044.html</a></p>\n</li>\n</ul>\n<h1 id=\"基本数据类型分类\"><a href=\"#基本数据类型分类\" class=\"headerlink\" title=\"基本数据类型分类\"></a>基本数据类型分类</h1><p>基本数据类型有 数字类型（int，float，complex），字符串类型（str），列表类型（list）元组（tuple），字典（dict），集合（set）</p>\n<span id=\"more\"></span>\n\n<h1 id=\"数字类型—-gt-不可变类型\"><a href=\"#数字类型—-gt-不可变类型\" class=\"headerlink\" title=\"数字类型—&gt;不可变类型\"></a>数字类型—&gt;不可变类型</h1><ul>\n<li>pass</li>\n</ul>\n<h1 id=\"字符串类型—-gt-不可变类型\"><a href=\"#字符串类型—-gt-不可变类型\" class=\"headerlink\" title=\"字符串类型—&gt;不可变类型\"></a>字符串类型—&gt;不可变类型</h1><ul>\n<li>这代表着以下方法如若修改列表，str 的 id(str) 值会更改，与 list不同。</li>\n</ul>\n<h2 id=\"字符串具体操作方法请\"><a href=\"#字符串具体操作方法请\" class=\"headerlink\" title=\"字符串具体操作方法请\"></a>字符串具体操作方法请</h2><ul>\n<li><a href=\"/2022/12/08/python/python%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/\" title=\"python 字符串常用方法\">python 字符串常用方法</a></li>\n</ul>\n<h2 id=\"字符串切片\"><a href=\"#字符串切片\" class=\"headerlink\" title=\"字符串切片\"></a>字符串切片</h2><p><code>str[n]</code> 表示正数获取字符串的元素，表示从左往右数第 n+1 个元素:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():`</span><br><span class=\"line\">    `test_str = <span class=\"string\">&quot;junliangl&quot;</span>`</span><br><span class=\"line\">    `<span class=\"built_in\">print</span>(test_str[<span class=\"number\">3</span>])`</span><br><span class=\"line\"></span><br><span class=\"line\">`<span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:`</span><br><span class=\"line\">    `test()`</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<p><img src=\"/./images/python/data-type/1.png\"></p>\n<p><code>str[-n]</code> 表示负数获取字符串的元素，表示从右往左数第 n 个元素</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test_str = <span class=\"string\">&quot;junliangl&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_str[-<span class=\"number\">2</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<p><img src=\"/./images/python/data-type/2.png\"></p>\n<p><code>str[m:n]</code> 表示从 m+1 取到第 n 的元素，不包含第 n 个元素（左闭右开原则）。如果截取不到，那么则返回空串 <code>&quot;&quot;</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test_str = <span class=\"string\">&quot;junliangl&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_str[<span class=\"number\">0</span>:<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_str[<span class=\"number\">0</span>:<span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_str[<span class=\"number\">2</span>:<span class=\"number\">5</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<p><img src=\"/./images/python/data-type/3.png\"></p>\n<p><code>str[:n]</code> 表示取第 1 个 到第 n 的元素，不包含第 n 个元素；str[n:] 表示取第 n+1 个 到最后一个元素</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test_str = <span class=\"string\">&quot;junliangl&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_str[:-<span class=\"number\">2</span>])</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_str[<span class=\"number\">2</span>:])</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_str[:-<span class=\"number\">10</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<p><img src=\"/./images/python/data-type/4.png\"></p>\n<p><code>str[a : b : c]</code>  </p>\n<p>如果 c 不写或者为正，则按照正方向截取。就代表着 a &lt; b，否则返回空串</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test_str = <span class=\"string\">&quot;junliangl&quot;</span></span><br><span class=\"line\">    “<span class=\"built_in\">print</span>(test_str[<span class=\"number\">2</span>:<span class=\"number\">6</span>:])</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_str[<span class=\"number\">6</span>:<span class=\"number\">2</span>:<span class=\"number\">3</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<p><img src=\"/./images/python/data-type/5.png\"></p>\n<p>如果 c 为负，则按照反方向截取。就代表着 a &gt; b ，否则返回空串</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test_str = <span class=\"string\">&quot;junliangl&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_str[<span class=\"number\">8</span>:<span class=\"number\">4</span>:-<span class=\"number\">3</span>])</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_str[-<span class=\"number\">2</span>:-<span class=\"number\">7</span>:-<span class=\"number\">2</span>])</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_str[-<span class=\"number\">6</span> : -<span class=\"number\">1</span> : -<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<p><img src=\"/./images/python/data-type/6.png\"></p>\n<p>应用</p>\n<p><code>str[::-1]</code></p>\n<p>直接表示字符串反串</p>\n<h2 id=\"字符串其他常用方法\"><a href=\"#字符串其他常用方法\" class=\"headerlink\" title=\"字符串其他常用方法\"></a>字符串其他常用方法</h2><ul>\n<li><p><code>len() </code>方法求字符串长度</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test_str = <span class=\"string\">&quot;junliangl&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">len</span>(test_str))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/7.png\"></p>\n</li>\n<li><p><code>lower()</code> 与 <code>upper() </code>表示字符串字母全变为小写和大写</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test_str = <span class=\"string\">&quot;JUNliangL&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_str.lower())</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_str.upper())</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/8.png\"></p>\n</li>\n<li><p><code>startwith(str)</code> 和 <code>endwith(str)</code> 表示是否以某一子串开始或结尾</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test_str = <span class=\"string\">&quot;JUNliangL&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_str.startswith(<span class=\"string\">&quot;JUN&quot;</span>))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_str.endswith(<span class=\"string\">&quot;GL&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<p><img src=\"/./images/python/data-type/9.png\"></p>\n</li>\n<li><p><code>join(s) </code>方法表示以指定字符串结合</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test_str = <span class=\"string\">&quot;----&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_str.join(<span class=\"string\">&quot;1234&quot;</span>))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_str.join([<span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;3&quot;</span>, <span class=\"string\">&quot;4&quot;</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<p><img src=\"/./images/python/data-type/10.png\"></p>\n</li>\n<li><p><code>replace(old_str，new_str，count)</code> 表示把 old_str 子串替换成 new_str ，count是替换数量，默认值是替换全部</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    old_test_str = <span class=\"string\">&quot;junliangl bad bad bad&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(old_test_str)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(old_test_str))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;----------------&quot;</span>)</span><br><span class=\"line\">    new_test_str = old_test_str.replace(<span class=\"string\">&quot;bad&quot;</span>, <span class=\"string\">&quot;good&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(new_test_str)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(new_test_str))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;----------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(new_test_str.replace(<span class=\"string\">&quot;good&quot;</span>, <span class=\"string\">&quot;bad&quot;</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<p><img src=\"/./images/python/data-type/11.png\"></p>\n<p>很明显看出 <code>replace()</code> 方法不改变原来的字符串，创建了一个新的对象指向不同的字符串常量。</p>\n</li>\n<li><p><code>count(str，start，end)</code> 表示计算 str 子串在原来字符串中出现的次数。start 和 end 控制返回，默认值则代表整个字符串范围</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test_str = <span class=\"string\">&quot;junliangl bad bad bad good good&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_str.count(<span class=\"string\">&quot;bad&quot;</span>, <span class=\"number\">9</span>, <span class=\"number\">13</span>))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_str.count(<span class=\"string\">&quot;good&quot;</span>))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_str.count(<span class=\"string\">&quot;bad&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/12.png\"></p>\n</li>\n<li><p><code>split(str，count) </code>表示当前字符串以什么子串分隔，返回值为一个字符串列表 list。count 表示分隔几次，默认值是全部。没有子串则返回字符串列表</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test_str = <span class=\"string\">&quot;junliangl bad bad bad good good&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_str.split(<span class=\"string\">&quot; &quot;</span>))</span><br><span class=\"line\">    test_str = <span class=\"string\">&quot;junliangl,bad,bad,bad,good,good&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_str.split(<span class=\"string\">&quot;,&quot;</span>, <span class=\"number\">2</span>))</span><br><span class=\"line\">    test_str = <span class=\"string\">&quot;junliangl,bad,bad,bad,good,good&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_str.split(<span class=\"string\">&quot;.&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/13.png\"></p>\n</li>\n<li><p><code>strip(str) </code>表示当前字符串去除以 str 子串开头和结尾。默认参数则去除首尾的空白字符(空格、\\n、\\t)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    old_test_str = <span class=\"string\">&quot;123 junliangl 123&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(old_test_str))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(old_test_str)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;-----------------&quot;</span>)</span><br><span class=\"line\">    new_test_str = old_test_str.strip(<span class=\"string\">&quot;123&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(old_test_str)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(new_test_str))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(new_test_str)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(new_test_str.strip())</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<p><img src=\"/./images/python/data-type/14.png\"></p>\n<p>很明显看出 <code>strip()</code> 方法不改变原来的字符串，创建了一个新的对象指向不同的字符串常量。</p>\n</li>\n<li><p><code>isdigit()</code> 表示如果字符串只包含数字，是则返回 True，否则返回 False</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test1_str = <span class=\"string\">&quot;junliangl 123&quot;</span></span><br><span class=\"line\">    test2_str = <span class=\"string\">&quot;123&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test1_str.isdigit())</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test2_str.isdigit())</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/15.png\"></p>\n</li>\n<li><p><code>encode(encoding=)</code>对字符串进行编码，encoding 填写编码格式。<code>decode(encoding=)</code>对字符串解码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_str</span>():</span><br><span class=\"line\">    str_test = <span class=\"string\">&quot;测试&quot;</span></span><br><span class=\"line\">    encode = str_test.encode(encoding=<span class=\"string\">&quot;GBK&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(encode)</span><br><span class=\"line\">    new_str = encode.decode(encoding=<span class=\"string\">&quot;GBK&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(new_str)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">b&#x27;\\xb2\\xe2\\xc6\\xd4&#x27;</span>.decode(encoding=<span class=\"string\">&quot;GBK&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_str()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/16.png\"></p>\n</li>\n</ul>\n<h1 id=\"列表类型—-gt-可变类型\"><a href=\"#列表类型—-gt-可变类型\" class=\"headerlink\" title=\"列表类型—&gt;可变类型\"></a>列表类型—&gt;可变类型</h1><ul>\n<li>这代表着以下方法如若修改列表，列表的 id(list)值不变，与 str 类型不同</li>\n</ul>\n<h2 id=\"列表切片\"><a href=\"#列表切片\" class=\"headerlink\" title=\"列表切片\"></a>列表切片</h2><ul>\n<li><p><code>list[n] </code>索引取值遵循字符串规则</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test_list = [<span class=\"string\">&#x27;junliangl&#x27;</span>, <span class=\"number\">1</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>]]</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_list[<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_list[-<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/17.png\"></p>\n</li>\n<li><p><code>list[a:b:c] </code>切片类似 str </p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test_list = [<span class=\"string\">&#x27;junliangl&#x27;</span>, <span class=\"number\">1</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>], <span class=\"string\">&#x27;best&#x27;</span>, <span class=\"string\">&#x27;good&#x27;</span>]</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_list[:<span class=\"number\">3</span>])</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_list[<span class=\"number\">3</span>:])</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_list[:-<span class=\"number\">3</span>])</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_list[-<span class=\"number\">3</span>:])</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_list[<span class=\"number\">1</span>:-<span class=\"number\">2</span>])</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_list[<span class=\"number\">1</span>:<span class=\"number\">4</span>:<span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_list[-<span class=\"number\">2</span>:-<span class=\"number\">4</span>:-<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/18.png\"></p>\n</li>\n<li><p><code>len(list) </code>代表列表长度</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test_list = [<span class=\"string\">&#x27;junliangl&#x27;</span>, <span class=\"string\">&#x27;best&#x27;</span>, <span class=\"string\">&#x27;good&#x27;</span>]</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">len</span>(test_list))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/19.png\"></p>\n</li>\n<li><p><code>append(s) </code>代表往列表末尾追加一个元素 s。改变列表后，列表地址不变，以下的方法同理</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test_list = [<span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span>, <span class=\"string\">&#x27;3&#x27;</span>]</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(test_list))</span><br><span class=\"line\">    test_list.append(<span class=\"string\">&#x27;4&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(test_list))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_list)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/20.png\"></p>\n</li>\n<li><p><code>insert(index，obj)</code> 表示往当前列表 index 处替换为 obj，其他元素后移。若 index &gt;&#x3D; len(list)，则在末尾处添加；若 index &lt;&#x3D; -len(list)，则在首部添加。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test1_list = [<span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span>, <span class=\"string\">&#x27;3&#x27;</span>]</span><br><span class=\"line\">    test2_list = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">    test1_list.insert(-<span class=\"number\">1</span>, <span class=\"string\">&#x27;4&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test1_list)</span><br><span class=\"line\">    test2_list.insert(<span class=\"number\">2</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test2_list)</span><br><span class=\"line\">    test1_list.insert(<span class=\"number\">100</span>, <span class=\"string\">&#x27;5&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test1_list)</span><br><span class=\"line\">    test2_list.insert(-<span class=\"number\">100</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test2_list)</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<p><img src=\"/./images/python/data-type/21.png\"></p>\n</li>\n<li><p><code>extend(iterable)</code> 表示往当前列表末尾添加一个序列而不是序列本身</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test1_list = [<span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span>, <span class=\"string\">&#x27;3&#x27;</span>]</span><br><span class=\"line\">    test2_list = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">    test1_list.append(test2_list)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test1_list)</span><br><span class=\"line\">    test1_list = [<span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span>, <span class=\"string\">&#x27;3&#x27;</span>]</span><br><span class=\"line\">    test1_list.extend(test2_list)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test1_list)</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/22.png\"></p>\n</li>\n<li><p><code>del(list[a:b:c])</code> 表示删除列表选择的元素</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test_list = [<span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span>, <span class=\"string\">&#x27;3&#x27;</span>, <span class=\"string\">&#x27;4&#x27;</span>, <span class=\"string\">&#x27;5&#x27;</span>]</span><br><span class=\"line\">    <span class=\"keyword\">del</span> test_list[-<span class=\"number\">1</span>::-<span class=\"number\">2</span>]</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_list)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/23.png\"></p>\n</li>\n<li><p><code>pop(index)</code> 表示按照 index 删除，默认值为删除末尾的元素</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test_list = [<span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span>, <span class=\"string\">&#x27;3&#x27;</span>, <span class=\"string\">&#x27;4&#x27;</span>, <span class=\"string\">&#x27;5&#x27;</span>]</span><br><span class=\"line\">    test_list.pop(-<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_list)</span><br><span class=\"line\">    test_list.pop()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_list)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/24.png\"></p>\n</li>\n<li><p><code>remove(obj)</code> 表示按照元素对象删除，默认删除寻找到的第一个元素</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test_list = [<span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span>, <span class=\"string\">&#x27;3&#x27;</span>, <span class=\"string\">&#x27;4&#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>]</span><br><span class=\"line\">    test_list.remove(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_list)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/25.png\"></p>\n</li>\n<li><p><code>count(obj, start, end)</code> 统计某个元素在当前列表出现的次数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test_list = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_list.count(<span class=\"number\">2</span>))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_list.count(<span class=\"number\">3</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/26.png\"></p>\n</li>\n<li><p><code>index(obj，start，end)</code> 表示从 <code>list[start] --- list[end]</code> 之间的 obj 出现在 list 的第一个索引值， 找不到的话抛出 <code>ValueError</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test_list = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(test_list.index(<span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>))</span><br><span class=\"line\">    <span class=\"keyword\">except</span> ValueError <span class=\"keyword\">as</span> v:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(v)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_list.index(<span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">5</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/27.png\"></p>\n</li>\n<li><p><code>clear() </code>表示清空列表中的元素</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test_list = [<span class=\"number\">1</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>], <span class=\"number\">3</span>]</span><br><span class=\"line\">    test_list[<span class=\"number\">1</span>].clear()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_list)</span><br><span class=\"line\">    test_list.clear()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_list)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/28.png\"></p>\n</li>\n<li><p><code>reverse() </code>表示反转列表中的元素等价 <code>list[::-1]</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test_list = [<span class=\"number\">1</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>], <span class=\"number\">3</span>]</span><br><span class=\"line\">    test_list[<span class=\"number\">1</span>].reverse()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_list)</span><br><span class=\"line\">    test_list.reverse()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_list)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/29.png\"></p>\n</li>\n<li><p><code>sort() </code>表示对列表进行排序，要保持类型一致，否则会报错</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test1_list = [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">51</span>, <span class=\"number\">10</span>, <span class=\"number\">9</span>]</span><br><span class=\"line\">    test2_list = [<span class=\"number\">12</span>, <span class=\"string\">&#x27;&#x27;</span>]</span><br><span class=\"line\">    test1_list.sort()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test1_list)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        test2_list.sort()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(test2_list)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> TypeError <span class=\"keyword\">as</span> t:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(t)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/30.png\"></p>\n</li>\n</ul>\n<h2 id=\"关于-list-的拷贝\"><a href=\"#关于-list-的拷贝\" class=\"headerlink\" title=\"关于 list 的拷贝\"></a>关于 list 的拷贝</h2><p>参考链接</p>\n<ul>\n<li><a href=\"/2022/12/10/python/python%20%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/\" title=\"python 内存详解\">python 内存详解</a> 关于python的列表的内存机制</li>\n</ul>\n<h3 id=\"赋值拷贝\"><a href=\"#赋值拷贝\" class=\"headerlink\" title=\"赋值拷贝\"></a>赋值拷贝</h3><p>直接将对象(地址)赋值传递给新的对象。这样更改原来的元素都会影响赋值拷贝后的列表</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test1_list = [<span class=\"number\">1</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]]</span><br><span class=\"line\">    test2_list = test1_list</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(test1_list))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test1_list)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(test2_list))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test2_list)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    test1_list[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = <span class=\"number\">10000</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test1_list)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test2_list)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/31.png\"></p>\n<h3 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h3><p>浅拷贝即未对所有层的内容进行拷贝，即其中包含赋值拷贝，即使他们的 id 值不一样。以下有几种使用方式</p>\n<ul>\n<li><p><code>for</code>循环依次赋值</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    old = [<span class=\"number\">1</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"number\">3</span>]</span><br><span class=\"line\">    new = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(old)):</span><br><span class=\"line\">        new.append(old[i])</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(old))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(old)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(new))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(new)</span><br><span class=\"line\">    new[<span class=\"number\">0</span>] = <span class=\"number\">3</span></span><br><span class=\"line\">    new[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(old)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(new)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>返回</p>\n<p><img src=\"/./images/python/data-type/32.png\"></p>\n</li>\n</ul>\n</li>\n<li><p>使用<code>copy()</code> 方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    old = [<span class=\"number\">1</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"number\">3</span>]</span><br><span class=\"line\">    new = old.copy()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(old))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(old)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(new))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(new)</span><br><span class=\"line\">    new[<span class=\"number\">0</span>] = <span class=\"number\">3</span></span><br><span class=\"line\">    new[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(old)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(new)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/33.png\"></p>\n</li>\n<li><p>使用切片</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    old = [<span class=\"number\">1</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"number\">3</span>]</span><br><span class=\"line\">    new = old[:]</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(old))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(old)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(new))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(new)</span><br><span class=\"line\">    new[<span class=\"number\">0</span>] = <span class=\"number\">3</span></span><br><span class=\"line\">    new[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(old)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(new)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/34.png\"></p>\n</li>\n<li><p>等值传递</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">        old = [<span class=\"number\">1</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"number\">3</span>]</span><br><span class=\"line\">        new = [<span class=\"number\">1</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"number\">3</span>]</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(old))</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(old)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(new))</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(new)</span><br><span class=\"line\">        new[<span class=\"number\">0</span>] = <span class=\"number\">3</span></span><br><span class=\"line\">        new[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = <span class=\"number\">3</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(old)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(new)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">        test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/35.png\"></p>\n</li>\n</ul>\n<h3 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h3><p>即创建与原对象完全无关的对象。需导入 copy 模块</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> copy</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">      old = [<span class=\"number\">1</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"number\">3</span>]</span><br><span class=\"line\">      new = copy.deepcopy(old)</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(old))</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(old)</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(new))</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(new)</span><br><span class=\"line\">      new[<span class=\"number\">0</span>] = <span class=\"number\">3</span></span><br><span class=\"line\">      new[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = <span class=\"number\">3</span></span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(old)</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(new)</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">      test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/36.png\"></p>\n<h1 id=\"元组类型—-gt-不可变类型\"><a href=\"#元组类型—-gt-不可变类型\" class=\"headerlink\" title=\"元组类型—&gt;不可变类型\"></a>元组类型—&gt;不可变类型</h1><p>元组相当于不可变的列表(为 id 值 无法变，但是对于列表元组等，可以更改里面的值)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test_tuple = (<span class=\"number\">1</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>])</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_tuple)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        test_tuple[<span class=\"number\">0</span>] = <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> TypeError <span class=\"keyword\">as</span> t:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(t)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        test_tuple[<span class=\"number\">1</span>][<span class=\"number\">1</span>] = <span class=\"number\">10000</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> TypeError <span class=\"keyword\">as</span> t:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(t)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_tuple)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/37.png\"></p>\n<h2 id=\"元组类型常用方法\"><a href=\"#元组类型常用方法\" class=\"headerlink\" title=\"元组类型常用方法\"></a>元组类型常用方法</h2><ul>\n<li><p><code>tuple(obj)</code> obj 只要为可迭代类型都能转换。对于 dict 类型转换只转换 key 值</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    test1_tuple = <span class=\"built_in\">tuple</span>(<span class=\"string\">&quot;junliangl&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test1_tuple)</span><br><span class=\"line\">    test2_tuple = <span class=\"built_in\">tuple</span>(&#123;<span class=\"string\">&quot;first&quot;</span>: <span class=\"number\">1</span>, <span class=\"string\">&quot;second&quot;</span>: <span class=\"number\">2</span>&#125;)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test2_tuple)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/38.png\"></p>\n</li>\n<li><p><code>tuple[a:b:c] </code>切片，索引。和 list 一致 </p>\n<p><code>pass</code></p>\n</li>\n<li><p><code>len(tuple)</code> 和 list 一致</p>\n<p><code>pass</code></p>\n</li>\n<li><p><code>index(obj, start, end)</code> 和列表一致</p>\n<p><code>pass</code></p>\n</li>\n<li><p><code>count(obj, start, end)</code>和列表一致</p>\n<p><code>pass</code></p>\n</li>\n</ul>\n<h1 id=\"字典类型—-gt-可变类型\"><a href=\"#字典类型—-gt-可变类型\" class=\"headerlink\" title=\"字典类型—&gt;可变类型\"></a>字典类型—&gt;可变类型</h1><p>这代表着以下方法如若修改字典，字典的 id(dict)值不变，与 str 类型不同</p>\n<h2 id=\"参考链接-1\"><a href=\"#参考链接-1\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://www.cnblogs.com/wakey/p/16246920.html\">https://www.cnblogs.com/wakey/p/16246920.html</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_45228198/article/details/112771784\">https://blog.csdn.net/weixin_45228198/article/details/112771784</a></li>\n</ul>\n<h2 id=\"底层原理\"><a href=\"#底层原理\" class=\"headerlink\" title=\"底层原理\"></a>底层原理</h2><p>字典底层采用 hash表（散列表）的形式存储数据。内存形式如下</p>\n<p><img src=\"/./images/python/data-type/39.png\"></p>\n<ol>\n<li><p>插入数据</p>\n<p>d[“name”]&#x3D;”jack”</p>\n<ol>\n<li>首先对键- -“name”计算哈希值，然后对当前C数组arr的长度求余</li>\n<li>然后得到一个索引值，假如为5，则将当前的（哈希值，键，值）作为一个整体存入arr[5]</li>\n</ol>\n</li>\n<li><p>哈希碰撞</p>\n<ol>\n<li>当插入的键，经过哈希计算，求余后若得到与之前一样的索引，比如5</li>\n<li>因此索引处已经存有数据，无法再次存入，那么就将当前的索引+ 一个偏移量</li>\n<li>重新计算索引位置，然后存入数据，这在python中为开放地址法</li>\n</ol>\n</li>\n<li><p>扩容（可变）</p>\n<ol>\n<li>当存入的数据超过总长度的2&#x2F;3时，字典会成倍扩容，对旧数据根据新数组长度计算索引，重新存入</li>\n</ol>\n</li>\n<li><p>更新值</p>\n<p>d[“name”]&#x3D;”tom”</p>\n<ol>\n<li>首先计算键- “name”的哈希值，然后对当前数组总长度求余，得到索引，若索引对应位置的数据的键&#x3D;&#x3D;“name”，则更新它的值</li>\n</ol>\n</li>\n<li><p>删除</p>\n<p>del d[“name”]</p>\n<ol>\n<li>计算当前键- “name” 的哈希值，求余，找到索引，删除数据，仍保持探测链</li>\n<li>标记此处有过数据</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"字典对比列表优缺点\"><a href=\"#字典对比列表优缺点\" class=\"headerlink\" title=\"字典对比列表优缺点\"></a>字典对比列表优缺点</h2><p>列表：遍历所有数据，一个一个的比较，数据量大时，时间复杂度高<br>字典：对要查找的键，计算哈希值，求余运算得到索引，一步到位，查找效率高。内存消耗极大，属于空间换取时间</p>\n<h2 id=\"字典注意项\"><a href=\"#字典注意项\" class=\"headerlink\" title=\"字典注意项\"></a>字典注意项</h2><p>遍历字典时添加新建可能导致字典底层数组扩容，导致散列链发生变化，因此一般不要对字典遍历的同时进行修改</p>\n<p>具体过程如下：</p>\n<ol>\n<li><p>键值的存储过程</p>\n<ol>\n<li><p>首先要计算data[“name”]的散列值</p>\n</li>\n<li><p>得到hash值后，我们从hash值最右边3位数字作为偏离量，即0b1xxxx000111101</p>\n</li>\n<li><p>我们查看偏移量”101” 对应的bucket是否为空，如果为空，则将键值对放进去</p>\n</li>\n<li><p>如果不为空，则依次去右边3位作为偏离量，即0b1xxxx000111101</p>\n</li>\n<li><p>再看偏离量”111” 对应的bucket是否为空，直到找到为空的bucket将键值对放进去</p>\n<p>  <img src=\"/./images/python/data-type/40.png\"></p>\n</li>\n</ol>\n</li>\n<li><p>字典查找值的过程</p>\n<ol>\n<li><p>我们要计算data[“name”] 里面的”name”对象</p>\n</li>\n<li><p>确定偏离量，散列值的最右边3位数字作为偏离量 0b1xxxx000111101</p>\n</li>\n<li><p>查看偏离量”101”对应的bucket是否为空，如果为空，则返回None</p>\n</li>\n<li><p>如果不为空，则将这个bucket的键对象计算出对应的散列值和data[“name”]的”name”散列值进行比较，如果两个散列值相等，则将对应数组里的值对象返回，如果不相等，则再依次向前取3个【偏移量，如0b1xxxx000111101。依次取完，仍然没有找到，则返回None</p>\n<p>  <img src=\"/./images/python/data-type/41.png\"></p>\n</li>\n</ol>\n</li>\n</ol>\n<p>字典的 key 必须是可散列的 数字类型，字符串类型，元组类型。如若是其他类型，则会报错</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_dict</span>():</span><br><span class=\"line\">    a = &#123;(<span class=\"number\">1</span>, <span class=\"number\">2</span>): <span class=\"number\">1</span>&#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        b = &#123;[<span class=\"number\">1</span>, <span class=\"number\">2</span>]: <span class=\"number\">1</span>&#125;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(b)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> TypeError <span class=\"keyword\">as</span> t:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(t)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_dict()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/42.png\"></p>\n<h2 id=\"字典赋值\"><a href=\"#字典赋值\" class=\"headerlink\" title=\"字典赋值\"></a>字典赋值</h2><p><code>dict[key] = value</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_dict</span>():</span><br><span class=\"line\">    dict_test = &#123;&#125;</span><br><span class=\"line\">    list_test = [[<span class=\"string\">&quot;first&quot;</span>, <span class=\"string\">&quot;value1&quot;</span>], [<span class=\"string\">&quot;second&quot;</span>, <span class=\"string\">&quot;value2&quot;</span>], [<span class=\"string\">&quot;third&quot;</span>, <span class=\"string\">&quot;value3&quot;</span>]]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> list_test:</span><br><span class=\"line\">        dict_test[i[<span class=\"number\">0</span>]] = i[<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(dict_test)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_dict()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/43.png\"></p>\n<p>针对赋值操作，key 存在则修改，key 不存在则新增。所以字典里的 key 必须唯一</p>\n<h2 id=\"字典的常用方法\"><a href=\"#字典的常用方法\" class=\"headerlink\" title=\"字典的常用方法\"></a>字典的常用方法</h2><ul>\n<li><p><code>fromkeys(obj，value)</code> 表示遍历序列 obj 作为新 dict 的 key，value 整体作为 value</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_dict</span>():</span><br><span class=\"line\">    dict_test1 = &#123;&#125;</span><br><span class=\"line\">    dict_test2 = dict_test1.fromkeys((<span class=\"number\">1</span>, <span class=\"number\">2</span>), <span class=\"number\">3</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(dict_test1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(dict_test2)</span><br><span class=\"line\">    dict_test3 = dict_test1.fromkeys([<span class=\"string\">&quot;first&quot;</span>, <span class=\"string\">&quot;second&quot;</span>], [<span class=\"string\">&quot;value1&quot;</span>, <span class=\"string\">&quot;value2&quot;</span>])</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(dict_test3)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_dict()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/44.png\"></p>\n</li>\n<li><p><code>pop(key)</code> 方法代表删除，返回被删除的 value</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_dict</span>():</span><br><span class=\"line\">    dict_test = &#123;<span class=\"string\">&quot;key&quot;</span>: <span class=\"string\">&quot;value&quot;</span>, <span class=\"number\">5</span>: <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">    value = dict_test.pop(<span class=\"string\">&quot;key&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(dict_test)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_dict()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/45.png\"></p>\n</li>\n<li><p><code>popitem()</code> 后进先出原则删除字典最后添加的 key-value 对</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_dict</span>():</span><br><span class=\"line\">    dict_test1 = &#123;<span class=\"string\">&quot;key&quot;</span>: <span class=\"string\">&quot;value&quot;</span>, <span class=\"number\">5</span>: <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(dict_test1.popitem())</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(dict_test1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;------------------&quot;</span>)</span><br><span class=\"line\">    dict_test2 = &#123;<span class=\"number\">5</span>: <span class=\"number\">3</span>, <span class=\"number\">6</span>: <span class=\"number\">3</span>, <span class=\"number\">2</span>: <span class=\"number\">9</span>&#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(dict_test2.popitem())</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(dict_test2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_dict()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/46.png\"></p>\n</li>\n<li><p><code>clear()</code> 清空字典</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_dict</span>():</span><br><span class=\"line\">    dict_test = &#123;<span class=\"string\">&quot;key&quot;</span>: <span class=\"string\">&quot;value&quot;</span>, <span class=\"number\">5</span>: <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">    dict_test.clear()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(dict_test)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_dict()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/47.png\"></p>\n</li>\n<li><p><code>update(dict)</code> 更新字典。key 重复则更新 value，没有则新增</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_dict</span>():</span><br><span class=\"line\">    dict_test = &#123;<span class=\"string\">&quot;first&quot;</span>: <span class=\"string\">&quot;value1&quot;</span>, <span class=\"string\">&quot;second&quot;</span>: <span class=\"string\">&quot;value2&quot;</span>&#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(dict_test)</span><br><span class=\"line\">    dict_test.update(&#123;<span class=\"string\">&quot;first&quot;</span>: <span class=\"string\">&quot;update&quot;</span>, <span class=\"string\">&quot;third&quot;</span>: <span class=\"string\">&quot;value3&quot;</span>&#125;)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(dict_test)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_dict()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/48.png\"></p>\n</li>\n<li><p>get(key，obj) 判断字典的 key 是否存在，若存在返回对应的 value，不存在则返回 obj</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_dict</span>():</span><br><span class=\"line\">    dict_test1 = &#123;<span class=\"string\">&quot;first&quot;</span>: <span class=\"string\">&quot;value1&quot;</span>, <span class=\"string\">&quot;second&quot;</span>: <span class=\"string\">&quot;value2&quot;</span>&#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(dict_test1.get(<span class=\"string\">&quot;first&quot;</span>, <span class=\"string\">&quot;first 不存在&quot;</span>))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(dict_test1.get(<span class=\"string\">&quot;third&quot;</span>, <span class=\"string\">&quot;third 不存在&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_dict()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/49.png\"></p>\n</li>\n<li><p><code>setdefault(key，value) </code>如果当前 dict 存在 key，那么返回它的 value；否则把 key-value 键值对添加进字典并返回 vaule</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_dict</span>():</span><br><span class=\"line\">    dict_test = &#123;<span class=\"string\">&quot;first&quot;</span>: <span class=\"string\">&quot;value1&quot;</span>, <span class=\"string\">&quot;second&quot;</span>: <span class=\"string\">&quot;value2&quot;</span>&#125;</span><br><span class=\"line\">    dict_test.setdefault(<span class=\"string\">&quot;third&quot;</span>, <span class=\"string\">&quot;value3&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(dict_test.setdefault(<span class=\"string\">&quot;third&quot;</span>, <span class=\"string\">&quot;setdefault&quot;</span>))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(dict_test)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_dict()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/50.png\"></p>\n</li>\n<li><p><code>keys()</code> 获取 dict 的 keys。并返回该对象的生成器。这样节省了空间。如果要取值则可以自行强行转化成 list</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_dict</span>():</span><br><span class=\"line\">    dict_test1 = &#123;<span class=\"string\">&quot;first&quot;</span>: <span class=\"number\">1</span>, <span class=\"string\">&quot;second&quot;</span>: <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">    keys = dict_test1.keys()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(keys)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(keys))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">list</span>(keys))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_dict()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/51.png\"></p>\n</li>\n<li><p><code>values()</code> 获取 dict 的 values，其他同上</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_dict</span>():</span><br><span class=\"line\">    dict_test1 = &#123;<span class=\"string\">&quot;first&quot;</span>: <span class=\"number\">1</span>, <span class=\"string\">&quot;second&quot;</span>: <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">    values = dict_test1.values()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(values)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(values))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">list</span>(values))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_dict()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/52.png\"></p>\n</li>\n<li><p><code>items()</code>获取了dict 的 keys 和values 元组对，其他同上</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_dict</span>():</span><br><span class=\"line\">    dict_test = &#123;<span class=\"string\">&quot;first&quot;</span>: <span class=\"number\">1</span>, <span class=\"string\">&quot;second&quot;</span>: <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">    items = dict_test.items()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(items)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(items))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">list</span>(items))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_dict()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/53.png\"></p>\n</li>\n</ul>\n<h1 id=\"集合类型—-gt-可变类型\"><a href=\"#集合类型—-gt-可变类型\" class=\"headerlink\" title=\"集合类型—&gt;可变类型\"></a>集合类型—&gt;可变类型</h1><p>这代表着以下方法如若修改字典，字典的 id(dict)值不变，与 str 类型不同</p>\n<h2 id=\"条件\"><a href=\"#条件\" class=\"headerlink\" title=\"条件\"></a>条件</h2><p>集合元素满足</p>\n<ul>\n<li>必须是可散列的 数字，字符串，元组</li>\n</ul>\n<h2 id=\"底层原理-1\"><a href=\"#底层原理-1\" class=\"headerlink\" title=\"底层原理\"></a>底层原理</h2><p>依旧采用 hash 表进行存储</p>\n<h2 id=\"创建空集合\"><a href=\"#创建空集合\" class=\"headerlink\" title=\"创建空集合\"></a>创建空集合</h2><p> <code>set()</code></p>\n<ul>\n<li><p>不能采用 <code>&#123;&#125;</code>，系统默认为 dict 类型</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_set</span>():</span><br><span class=\"line\">    set_test = <span class=\"built_in\">set</span>()</span><br><span class=\"line\">    dict_test = &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(set_test)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(set_test))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;-----------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(dict_test)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(dict_test))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_set()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/55.png\"></p>\n</li>\n<li><p>如若不是空集合，则可以采用 <code>&#123;values&#125;</code> 方式创建</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_set</span>():</span><br><span class=\"line\">    set_test = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(set_test)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(set_test))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_set()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/56.png\"></p>\n</li>\n<li><p>由于集合内元素要参与 <code>hash(values)</code> 运算，所以得是不可变类型</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_set</span>():</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        set_test = &#123;<span class=\"number\">1</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>]&#125;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(set_test)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> TypeError <span class=\"keyword\">as</span> t:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(t)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_set()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/57.png\"></p>\n</li>\n</ul>\n<h2 id=\"集合常用方法\"><a href=\"#集合常用方法\" class=\"headerlink\" title=\"集合常用方法\"></a>集合常用方法</h2><ul>\n<li><p>交集 <code>set1 &amp; set2</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_set</span>():</span><br><span class=\"line\">    set1 = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">    set2 = &#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</span><br><span class=\"line\">    set3 = &#123;<span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>&#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(set1 &amp; set2)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(set2 &amp; set3)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_set()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/58.png\"></p>\n</li>\n<li><p>并集 <code>set1 | set2</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_set</span>():</span><br><span class=\"line\">    set1 = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">    set2 = &#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(set1 | set2)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_set()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/59.png\"></p>\n</li>\n<li><p>差集 <code>set1 - set2</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_set</span>():</span><br><span class=\"line\">    set1 = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">    set2 = &#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(set1 - set2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_set()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/60.png\"></p>\n</li>\n<li><p><code>discard(value)</code> 删除集合中 value 元素，找不到不会抛出异常</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_set</span>():</span><br><span class=\"line\">    set_test = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">    set_test.discard(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(set_test)</span><br><span class=\"line\">    set_test.discard(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_set()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/61.png\"></p>\n</li>\n<li><p><code>remove(values)</code> 删除 value 。找不到则报错</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_set</span>():</span><br><span class=\"line\">    set_test = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">    set_test.remove(<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(set_test)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        set_test.remove(<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> KeyError <span class=\"keyword\">as</span> k:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(k)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_set()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/62.png\"></p>\n</li>\n<li><p><code>update(obj)</code> 遍历序列 obj 更新集合 。序列一定是可哈希的，否则报错。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_set</span>():</span><br><span class=\"line\">    set_test = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">    set_test.update([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>])</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(set_test)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        set_test.update([<span class=\"number\">2</span>, <span class=\"number\">3</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>]])</span><br><span class=\"line\">    <span class=\"keyword\">except</span> TypeError <span class=\"keyword\">as</span> t:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(t)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_set()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/63.png\"></p>\n</li>\n<li><p><code>pop()</code> 随机删除一个元素。通常是展现出的删除第一个元素</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_set</span>():</span><br><span class=\"line\">    set_test1 = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">    set_test1.pop()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(set_test1)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_set()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/64.png\"></p>\n</li>\n<li><p><code>add(value)</code> 往集合中增加一个元素</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_set</span>():</span><br><span class=\"line\">    set_test1 = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">    set_test1.add(<span class=\"number\">4</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(set_test1)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        set_test1.add([])</span><br><span class=\"line\">    <span class=\"keyword\">except</span> TypeError <span class=\"keyword\">as</span> t:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(t)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_set()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/65.png\"></p>\n</li>\n<li><p><code>clear()</code> 清空集合</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_set</span>():</span><br><span class=\"line\">    set_test = &#123;<span class=\"string\">&quot;&quot;</span>, <span class=\"number\">1</span>, ()&#125;</span><br><span class=\"line\">    set_test.clear()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(set_test)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_set()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/data-type/66.png\"></p>\n</li>\n</ul>\n","categories":["python"],"tags":["python","基本数据类型","常用方法"]},{"title":"python 函数详解","url":"/2022/12/08/python/python%20%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/","content":"<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p>以下有关变量的作用域和类相关的请参考</p>\n<ul>\n<li><a href=\"/2022/12/08/python/python%20%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/\" title=\"python 变量的作用域\">python 变量的作用域</a></li>\n<li><a href=\"/2022/12/10/python/python%20%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/\" title=\"python 内存详解\">python 内存详解</a></li>\n<li><a href=\"/2022/12/10/python/python%20%E7%B1%BB%E8%AF%A6%E8%A7%A3/\" title=\"python 类详解\">python 类详解</a></li>\n</ul>\n<h1 id=\"函数命名规则\"><a href=\"#函数命名规则\" class=\"headerlink\" title=\"函数命名规则\"></a>函数命名规则</h1><p>小写开头，多个单词下划线 _ 隔开</p>\n<ul>\n<li><p><code>hello()，test_()， _good_time()</code></p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">hello</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">_good_time</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"对于类里的函数命名规则\"><a href=\"#对于类里的函数命名规则\" class=\"headerlink\" title=\"对于类里的函数命名规则\"></a>对于类里的函数命名规则</h2><p>对于类里的方法命名有以下规则</p>\n<ul>\n<li><p>python 预先自定义的<code>__init__()，__str__()</code>等收尾双下划线的方法名称为魔法函数。并且一般不建议自己这样命名方法如<code>__public__()</code>因为会被误解为魔法函数。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, name</span>):</span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__str__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Test类&quot;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__public__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>__private()</code>以双下划线开头但是不以双下划线结尾的称为私有函数，只能在类里面调用</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__private</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test = Test()</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        test.__private()</span><br><span class=\"line\">    <span class=\"keyword\">except</span> AttributeError <span class=\"keyword\">as</span> a:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(a)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/1.png\"></p>\n</li>\n</ul>\n<h3 id=\"特殊情况\"><a href=\"#特殊情况\" class=\"headerlink\" title=\"特殊情况\"></a>特殊情况</h3><p>然而可以通过<code>_Test__private()</code>强制访问</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Test</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__private</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test = Test()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">dir</span>(test))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test._Test__private())</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/2.png\"></p>\n<p>以上我们可以看到 test 属性有一个 <code>_Test__private</code>，这意味着可以用它取访问私有的属性。python 其实没有正在意义上的私有属性，只不过我们希望它不能被外界访问时，加入这样的标识符使得被 python 识别。python 不支持私有属性,但当属性命名为 __ 时,会将属性改名为_类名__属性名.这个方法其实是变量名压缩( mangling ,相当于扩张)的概念,只是通过这种方法变相地实现了属性访问控制的功能。但是呢这个方法也很有用,尤其在多重继承,或者大项目的情况下,各个类及实例可能出现属性冲突的情况,就可以通过这个功能来实现。</p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><ul>\n<li><a href=\"https://blog.csdn.net/renyiforever/article/details/79921854\">https://blog.csdn.net/renyiforever/article/details/79921854</a></li>\n</ul>\n<h1 id=\"函数参数\"><a href=\"#函数参数\" class=\"headerlink\" title=\"函数参数\"></a>函数参数</h1><h2 id=\"参考链接-1\"><a href=\"#参考链接-1\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li><a href=\"https://www.bilibili.com/video/BV1k7411W78H?p=6&amp;vd_source=f9937d98d0a8cc08ef5248c3c127d588\">https://www.bilibili.com/video/BV1k7411W78H?p=6&amp;vd_source=f9937d98d0a8cc08ef5248c3c127d588</a></li>\n</ul>\n<h2 id=\"参数类别\"><a href=\"#参数类别\" class=\"headerlink\" title=\"参数类别\"></a>参数类别</h2><p>总所周知，写在函数名括号后的叫形式参数，简称形参；实际传值的参数叫实际参数，简称实参</p>\n<h3 id=\"位置参数\"><a href=\"#位置参数\" class=\"headerlink\" title=\"位置参数\"></a>位置参数</h3><p>位置参数设定好以后位置传参不能随意发生改变。若随意改变，函数的功能会发生变化。并且传参参数量一定要匹配，多了或者少了会报错。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">arg1, arg2, arg3</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第一个参数是:<span class=\"subst\">&#123;arg1&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第二个参数是:<span class=\"subst\">&#123;arg2&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第三个参数是:<span class=\"subst\">&#123;arg3&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;**********************&quot;</span>)</span><br><span class=\"line\">    test(<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;**********************&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        test(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> TypeError <span class=\"keyword\">as</span> t:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(t)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;**********************&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        test(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> TypeError <span class=\"keyword\">as</span> t:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(t)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/3.png\"></p>\n<ul>\n<li><p>参数位置发生改变，方法功能性发生了改变。第一个输出的是 1，2，3；第二个输出的是 3，2，1</p>\n</li>\n<li><p>参数数量出现问题会抛出错误提示缺少一个位置参数和给多给了位置参数</p>\n</li>\n</ul>\n<h3 id=\"关键字参数\"><a href=\"#关键字参数\" class=\"headerlink\" title=\"关键字参数\"></a>关键字参数</h3><p>位置参数固然稳定，但是 python 对于方法参数的数量没有做定量要求(java 一般要求参数数量不多于6个)，那么对于多位置参数这种方式会容易位置混乱容易照成方法功能性不符合预期</p>\n<p>对于以上问题 python 给出解决方案为 关键字参数</p>\n<p>使用方法是：针对形参名在传实参时可以指定想要传入给哪个形参，受指定的参数不受位置问题从而影响方法的功能性</p>\n<p>但是一样要满足参数数量的严格吻合，否则还是会报错。并且不能对相同的关键字参数多次传值</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">arg1, arg2, arg3</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第一个参数是:<span class=\"subst\">&#123;arg1&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第二个参数是:<span class=\"subst\">&#123;arg2&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第三个参数是:<span class=\"subst\">&#123;arg3&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;**********************&quot;</span>)</span><br><span class=\"line\">    test(arg3=<span class=\"number\">3</span>, arg2=<span class=\"number\">2</span>, arg1=<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/4.png\"></p>\n<ul>\n<li>以上不难看出关键字参数的使用具有指定性功能。这样即时位置混乱只要符合以上要求都能保持方法功能的正常使用</li>\n</ul>\n<h3 id=\"位置参数和关键字参数混搭\"><a href=\"#位置参数和关键字参数混搭\" class=\"headerlink\" title=\"位置参数和关键字参数混搭\"></a>位置参数和关键字参数混搭</h3><p>混搭规则是一定是实参传递时位置参数在前，关键字参数在后，否则会报错（铁律）</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">arg1, arg2, arg3</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第一个参数是:<span class=\"subst\">&#123;arg1&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第二个参数是:<span class=\"subst\">&#123;arg2&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第三个参数是:<span class=\"subst\">&#123;arg3&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test(<span class=\"number\">1</span>, <span class=\"number\">2</span>, arg3=<span class=\"number\">3</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;**********************&quot;</span>)</span><br><span class=\"line\">    test(<span class=\"number\">1</span>, arg2=<span class=\"number\">2</span>, arg3=<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/5.png\"></p>\n<ul>\n<li><p>若实参传递时关键字参数放在位置参数之前，则编译会报错</p>\n<p><img src=\"/./images/python/method/6.png\"></p>\n<p>以上报错信息提示位置参数在关键字参数之后了。</p>\n</li>\n<li><p>即使满足位置参数在前，关键字参数在后依旧会报错，位置参数还应该对应本身位置</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">arg1, arg2, arg3</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第一个参数是:<span class=\"subst\">&#123;arg1&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第二个参数是:<span class=\"subst\">&#123;arg2&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第三个参数是:<span class=\"subst\">&#123;arg3&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test(<span class=\"number\">1</span> , <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;**********************&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        test(<span class=\"number\">10</span>, <span class=\"number\">30</span>, arg2=<span class=\"number\">20</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> TypeError <span class=\"keyword\">as</span> t:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(t)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/7.png\"></p>\n<ul>\n<li>以上不难看出，arg1，arg2 位置参数都已经给出了参数，但是随后的关键字参数再次给位置参数 arg2 传值，所以提示 test() 方法传给了 arg2 多个值的错误</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"强制关键字参数\"><a href=\"#强制关键字参数\" class=\"headerlink\" title=\"强制关键字参数\"></a>强制关键字参数</h3><p>为了让位置参数不容易写混淆而照成方法功能性错误，从而引入强制关键字参数</p>\n<p>用法是在需要使用强制关键字参数之前写入 * 号，代表 * 后的参数强制只能使用关键字参数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">def test(*, arg1, arg2, arg3):</span><br><span class=\"line\">    print(f&quot;第一个参数是:&#123;arg1&#125;&quot;)</span><br><span class=\"line\">    print(&quot;---------------------&quot;)</span><br><span class=\"line\">    print(f&quot;第二个参数是:&#123;arg2&#125;&quot;)</span><br><span class=\"line\">    print(&quot;---------------------&quot;)</span><br><span class=\"line\">    print(f&quot;第三个参数是:&#123;arg3&#125;&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &#x27;__main__&#x27;:</span><br><span class=\"line\">    test(arg1=1, arg2=2, arg3=3)</span><br><span class=\"line\">    print(&quot;**********************&quot;)</span><br><span class=\"line\">    try:</span><br><span class=\"line\">        test(1, 2, arg3=3)</span><br><span class=\"line\">    except TypeError as t:</span><br><span class=\"line\">        print(t)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/8.png\"></p>\n<ul>\n<li><p>以上不难看出 * 后实参的传递必须是关键字参数形式，如果没有按这样的方式，就会报 <code>TypeError</code>—test() 方法是0个位置参数，但是传递了2个位置参数</p>\n</li>\n<li><p>值得注意的是 * 号前依旧可以使用位置参数和关键字参数混搭，但是这建立在形参的 * 号位置</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">arg1, arg2, *, arg3</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第一个参数是:<span class=\"subst\">&#123;arg1&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第二个参数是:<span class=\"subst\">&#123;arg2&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第三个参数是:<span class=\"subst\">&#123;arg3&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test(<span class=\"number\">1</span>, arg2=<span class=\"number\">2</span>, arg3=<span class=\"number\">3</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;**********************&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        test(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> TypeError <span class=\"keyword\">as</span> t:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(t)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/9.png\"></p>\n<p>以上不难看出可以通过改变 * 号位置灵活使用强制关键字参数，但是依旧要遵守相关的混搭规则。</p>\n</li>\n</ul>\n<h3 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h3><p>在定义形参的时候，我们可以默认给其中的参数传递初始值(默认值)，这样依旧可以正常的定义参数</p>\n<p>关键字参数的用法是：在传递实参的时候你可以给默认参数传递一个新的值，也可以不传递</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">arg1=<span class=\"number\">1</span>, arg2=<span class=\"number\">2</span>, arg3=<span class=\"number\">3</span></span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第一个参数是:<span class=\"subst\">&#123;arg1&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第二个参数是:<span class=\"subst\">&#123;arg2&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第三个参数是:<span class=\"subst\">&#123;arg3&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;**********************&quot;</span>)</span><br><span class=\"line\">    test(<span class=\"number\">10</span>, arg2=<span class=\"number\">20</span>)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/10.png\"></p>\n<ul>\n<li>以上不难看出可以不用给默认参数传值，也可以给其中的默认参数传值。传值可以使用位置参数和关键字参数混搭的模式，但是依旧要遵守混搭规则。</li>\n</ul>\n<h3 id=\"默认参数的混搭\"><a href=\"#默认参数的混搭\" class=\"headerlink\" title=\"默认参数的混搭\"></a>默认参数的混搭</h3><p>默认参数依旧可以和之前的位置参数和关键字参数以及强制关键字参数混搭</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">def test(arg1, arg2, arg3, arg4=4):</span><br><span class=\"line\">    print(f&quot;第一个参数是:&#123;arg1&#125;&quot;)</span><br><span class=\"line\">    print(&quot;---------------------&quot;)</span><br><span class=\"line\">    print(f&quot;第二个参数是:&#123;arg2&#125;&quot;)</span><br><span class=\"line\">    print(&quot;---------------------&quot;)</span><br><span class=\"line\">    print(f&quot;第三个参数是:&#123;arg3&#125;&quot;)</span><br><span class=\"line\">    print(&quot;---------------------&quot;)</span><br><span class=\"line\">    print(f&quot;第四个参数是:&#123;arg4&#125;&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &#x27;__main__&#x27;:</span><br><span class=\"line\">    test(1, arg2=2, arg3=3, arg4=40)</span><br><span class=\"line\">    print(&quot;**********************&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/11.png\"></p>\n<ul>\n<li>以上不难看出默认参数混搭时依旧要遵守之前的混搭规则</li>\n</ul>\n<p>还有一点值得注意的是定义默认参数形参的时候一定要把所有的非默认参数在默认参数之前定义，否则编译不通过（除非形参包含强制关键字参数或可变参数，请参考下面可变位置参数）</p>\n<p><img src=\"/./images/python/method/12.png\"></p>\n<p>这很好理解，因为如果定义在非默认参数之前，当传递实参的时候，编译器不知道你是否给默认参数传递了值，这样为了避免二义性直接编译阶段报错</p>\n<p>当默认参数和强制关键字混搭时，由于默认参数的特性，当使用默认值时，我们可以不写 &#x3D; ，但是想给默认参数传值时，则一定要指明默认参数名</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">arg1, *, arg2=<span class=\"number\">2</span>, arg3=<span class=\"number\">3</span></span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第一个参数是:<span class=\"subst\">&#123;arg1&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第二个参数是:<span class=\"subst\">&#123;arg2&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第三个参数是:<span class=\"subst\">&#123;arg3&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test(<span class=\"number\">1</span>, arg2=<span class=\"number\">20</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;**********************&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        test(<span class=\"number\">1</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> TypeError <span class=\"keyword\">as</span> t:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(t)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/13.png\"></p>\n<ul>\n<li>以上不难看出如果定义在强制关键词参数后的默认参数想修改默认参数的值，必须要写 &#x3D;，否则就会报错</li>\n</ul>\n<p>默认参数和强制关键字参数混搭可以打破默认参数位置限制，但 * 号前的参数依旧要满足默认参数位限制（默认参数位置限制参考上面）</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">arg1, *, arg2=<span class=\"number\">2</span>, arg3</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第一个参数是:<span class=\"subst\">&#123;arg1&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第二个参数是:<span class=\"subst\">&#123;arg2&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第三个参数是:<span class=\"subst\">&#123;arg3&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test(<span class=\"number\">1</span>, arg2=<span class=\"number\">20</span>, arg3=<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/14.png\"></p>\n<ul>\n<li><p>以上不难看出默认参数可以写在位置参数之前了，打破了之前的限制，因为后面位置参数变为了强制关键字参数，因此不会引发二义性。但是后面的强制关键字参数依旧要使用等号，否则编译不通过。因为不满足实参传值时位置参数要在关键字参数之前</p>\n<p><img src=\"/./images/python/method/15.png\"></p>\n</li>\n</ul>\n<h3 id=\"可变位置参数（又叫可变参数）\"><a href=\"#可变位置参数（又叫可变参数）\" class=\"headerlink\" title=\"可变位置参数（又叫可变参数）\"></a>可变位置参数（又叫可变参数）</h3><p>有时候我们不确定具体传参时某些形参需要传多少个，那么我们就引入可变位置参数</p>\n<p>使用方式：在定义形参的名字前写上 *</p>\n<p><code>def test(*args)</code></p>\n<p>该可变位置参数通过把我们实际传递的实参用一个元组 args 来接受，这样完成可变确定的参数传值</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">*args</span>):</span><br><span class=\"line\">    num = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(args) == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;该可变位置参数没有传值&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> args:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;该可变位置参数参数的第<span class=\"subst\">&#123;num&#125;</span>个元素是:<span class=\"subst\">&#123;i&#125;</span>&quot;</span>)</span><br><span class=\"line\">        num += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;args的值为:<span class=\"subst\">&#123;args&#125;</span>, args的类型为:<span class=\"subst\">&#123;<span class=\"built_in\">type</span>(args)&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;**********************&quot;</span>)</span><br><span class=\"line\">    test(<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, [<span class=\"number\">40</span>])</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/16.png\"></p>\n<ul>\n<li>以上不难看出 args 类型为 tuple 元组类型；并且可以不传实参给他，那么 args 就为空元组</li>\n</ul>\n<h3 id=\"可变位置参数的混搭\"><a href=\"#可变位置参数的混搭\" class=\"headerlink\" title=\"可变位置参数的混搭\"></a>可变位置参数的混搭</h3><p>很明显，实际需要和可变位置参数的混搭完成函数的功能多样性</p>\n<p>可变位置参数可以和之前的参数任何一种或几种进行混搭，前提是依旧要满足他们各自的规则。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">arg1, *args, arg3=<span class=\"number\">3</span></span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第一个参数是:<span class=\"subst\">&#123;arg1&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第二个参数是:<span class=\"subst\">&#123;args&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第三个参数是:<span class=\"subst\">&#123;arg3&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test(<span class=\"number\">1</span>, [], &#123;&#125;, <span class=\"string\">&quot;&quot;</span>, <span class=\"number\">30</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;**********************&quot;</span>)</span><br><span class=\"line\">    test(<span class=\"number\">1</span>, [], &#123;&#125;, <span class=\"string\">&quot;&quot;</span>, arg3=<span class=\"number\">30</span>)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/17.png\"></p>\n<ul>\n<li>以上不难看出可变位置参数本质上扮演者位置参数角色，如果要给之后的默认参数传值就得使用关键字参数进行传值，否则会默认把之后的参数都传入可变参数的元组里</li>\n</ul>\n<p>可变参数混搭位置参数如果某些位置参数在可变参数之后，那么一定要以关键字参数形式进行传参</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">*args, arg2</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第一个参数是:<span class=\"subst\">&#123;args&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第二个参数是:<span class=\"subst\">&#123;arg2&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test(<span class=\"number\">1</span>, [], &#123;&#125;, arg2=<span class=\"number\">20</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;**********************&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        test(<span class=\"number\">1</span>, [], &#123;&#125;, <span class=\"number\">20</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> TypeError <span class=\"keyword\">as</span> t:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(t)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/18.png\"></p>\n<ul>\n<li>以上不难看出如果不以关键字形式进行传参，那么就会报缺少关键字参数的错误</li>\n</ul>\n<p>可变位置参数依旧可以打破默认参数在位置参数之后的限制，但可变参数前的参数依旧要满足默认参数位限制（参考上面介绍）但是</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">arg1, arg2=<span class=\"number\">2</span>, *args</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第一个参数是:<span class=\"subst\">&#123;arg1&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第二个参数是:<span class=\"subst\">&#123;arg2&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第三个参数是:<span class=\"subst\">&#123;args&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test(<span class=\"number\">1</span>, <span class=\"number\">20</span>, [], &#123;&#125;)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;**********************&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/19.png\"></p>\n<ul>\n<li><p>以上不难看出默认参数的默认值修改了。系统并没有把 20 传入元组作为 args。所以当出现打破默认参数位置限制的时，默认参数传值不能进行关键字参数进行传递，情况如下</p>\n<ul>\n<li><p>第一种情况是关键字参数在前对默认参数进行赋值，很明显违背位置参数要在关键字参数之前的规则</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">arg1, arg2=<span class=\"number\">2</span>, *args</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第一个参数是:<span class=\"subst\">&#123;arg1&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第二个参数是:<span class=\"subst\">&#123;arg2&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第三个参数是:<span class=\"subst\">&#123;args&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test(<span class=\"number\">1</span>, arg2=<span class=\"number\">20</span>, [], &#123;&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>报错信息</p>\n<p><img src=\"/./images/python/method/20.png\"></p>\n</li>\n<li><p>第二种情况是默认参数放在了后面，但是结合上面的分析，即时关键字参数放在最后，依旧要满足位置对应关系</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">arg1, arg2=<span class=\"number\">2</span>, *args</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第一个参数是:<span class=\"subst\">&#123;arg1&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第二个参数是:<span class=\"subst\">&#123;arg2&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第三个参数是:<span class=\"subst\">&#123;args&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        test(<span class=\"number\">1</span>, [], &#123;&#125;, arg2=<span class=\"number\">20</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> TypeError <span class=\"keyword\">as</span> t:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(t)</span><br></pre></td></tr></table></figure>\n\n<p>报错信息</p>\n<p><img src=\"/./images/python/method/21.png\"></p>\n<p>很明显提示 arg2 之前已经赋值了[] ,，所以重复赋值</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>注意可变位置参数不能和强制关键字参数进行混搭，否则编译不通过</p>\n<p><img src=\"/./images/python/method/22.png\"></p>\n<h3 id=\"可变关键字参数\"><a href=\"#可变关键字参数\" class=\"headerlink\" title=\"可变关键字参数\"></a>可变关键字参数</h3><p>实际中如果我们要传入一组参数名和参数值不确定的参数时，我们可以用可变关键字参数进行定义</p>\n<p>使用方式：在定义形参的名字前写上 **</p>\n<p><code>def test(**kwargs)</code></p>\n<p>该可变关键字参数通过把我们实际传递的实参用一个字典 kwargs 来接受，这样完成可变确定的参数传值</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">**kwargs</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;可变关键字参数是:<span class=\"subst\">&#123;kwargs&#125;</span>, 类型是:<span class=\"subst\">&#123;<span class=\"built_in\">type</span>(kwargs)&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;**********************&quot;</span>)</span><br><span class=\"line\">    test(first=<span class=\"number\">10</span>, second=<span class=\"number\">20</span>)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/23.png\"></p>\n<ul>\n<li>以上不难看出返回的是一个实参输入的参数名-参数值得字典键值对，kwargs 类型是 dict 类型</li>\n</ul>\n<h3 id=\"可变关键字参数的混搭\"><a href=\"#可变关键字参数的混搭\" class=\"headerlink\" title=\"可变关键字参数的混搭\"></a>可变关键字参数的混搭</h3><p>可变关键字参数的混搭顺序，一定是在所有参数类型最后再定义，理由很简单：因为是用关键字参数进行传递，那么不能在默认参数和位置参数之前，这两者就包含了可变位置参数。特殊地依旧不能在强制关键字之前定义，因为不知道后面的关键字参数是否是传给 kwargs，还是本身</p>\n<p><img src=\"/./images/python/method/24.png\"></p>\n<h3 id=\"强制位置参数（3-8新特性）\"><a href=\"#强制位置参数（3-8新特性）\" class=\"headerlink\" title=\"强制位置参数（3.8新特性）\"></a>强制位置参数（3.8新特性）</h3><p>用法 &#x2F;</p>\n<p>强制位置表示在   &#x2F; 之前一定要使用位置参数，不接受使用关键字参数</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">arg1, arg2=<span class=\"number\">2</span>, /, arg3=<span class=\"number\">3</span></span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第一个参数是:<span class=\"subst\">&#123;arg1&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第二个参数是:<span class=\"subst\">&#123;arg2&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第三个参数是:<span class=\"subst\">&#123;arg3&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test(<span class=\"number\">10</span>, <span class=\"number\">20</span>, arg3=<span class=\"number\">30</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;**********************&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        test(arg1=<span class=\"number\">10</span>, arg2=<span class=\"number\">20</span>, arg3=<span class=\"number\">30</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> TypeError <span class=\"keyword\">as</span> t:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(t)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/25.png\"></p>\n<ul>\n<li><p>以上不难看出如果用关键字参数给 &#x2F; 之前的参数赋值，那么会报错</p>\n</li>\n<li><p>强制位置参数不能在可变位置参数之后定义</p>\n<p><img src=\"/./images/python/method/26.png\"></p>\n</li>\n<li><p>强制位置参数不能在可变关键字参数之后定义</p>\n<p><img src=\"/./images/python/method/27.png\"></p>\n</li>\n<li><p>强制位置参数很明显应该放在强制关键字参数之前定义，否则引发矛盾</p>\n<p><img src=\"/./images/python/method/28.png\"></p>\n</li>\n</ul>\n<h3 id=\"解包（开包）\"><a href=\"#解包（开包）\" class=\"headerlink\" title=\"解包（开包）\"></a>解包（开包）</h3><p>python 可以通过 * 对列表或元组进行解包，通过 ** 对字典进行解包</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    list1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">    tuple1 = (<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">    dict1 = &#123;<span class=\"string\">&quot;first&quot;</span>: <span class=\"number\">1</span>, <span class=\"string\">&quot;second&quot;</span>: <span class=\"number\">2</span>, <span class=\"string\">&quot;third&quot;</span>: <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(*list1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(*tuple1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(*dict1)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test() </span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/29.png\"></p>\n<ul>\n<li>通过以上发现，解包无非是对序列进行进行遍历。注意 * 号对字典解包是取它的 keys</li>\n</ul>\n<h3 id=\"解包的应用\"><a href=\"#解包的应用\" class=\"headerlink\" title=\"解包的应用\"></a>解包的应用</h3><p>此应用于传参中</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">arg1, arg2, arg3</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第一个参数是:<span class=\"subst\">&#123;arg1&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第二个参数是:<span class=\"subst\">&#123;arg2&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;---------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第三个参数是:<span class=\"subst\">&#123;arg3&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    args1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">    args2 = (<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">    test(*args1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;**********************&quot;</span>)</span><br><span class=\"line\">    test(*args2)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/30.png\"></p>\n<ul>\n<li>这样传参可以瞬间传递自动遍历</li>\n</ul>\n<p>通过解包可以使得可变位置参数和可变关键字参数传参变得灵活容易起来</p>\n<ul>\n<li><p>可变位置参数</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">*args</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;解包参数是:<span class=\"subst\">&#123;args&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(*args)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    args1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\">    args2 = (<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">    test(*args1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;**********************&quot;</span>)</span><br><span class=\"line\">    test(*args2)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/31.png\"></p>\n</li>\n<li><p>可变关键字参数</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">**kwargs</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;解包参数是:<span class=\"subst\">&#123;kwargs&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    args = &#123;<span class=\"string\">&quot;first&quot;</span>: <span class=\"number\">1</span>, <span class=\"string\">&quot;second&quot;</span>: <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">    test(**args)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/32.png\"></p>\n</li>\n</ul>\n<h1 id=\"函数的返回值\"><a href=\"#函数的返回值\" class=\"headerlink\" title=\"函数的返回值\"></a>函数的返回值</h1><p>python 是弱类型语言，对返回值没有定性的要求，可以返回 None，可以不写 return 语句默认返回 None，可以有多个返回值，但是要在一个 return 语句中实现，并且这多个返回值以元组形式返回</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_not_return</span>():</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_return_None</span>():</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_return_single</span>():</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_return_diff</span>():</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>, <span class=\"number\">2.</span>, <span class=\"string\">&quot;&quot;</span>, [], (), &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_not_return())</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_return_None())</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_return_single())</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test_return_diff())</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/33.png\"></p>\n<ul>\n<li>以上可以看到 方法可以没有返回值，可以没有 return 语句，可以有多个不同类型返回值，多个返回值确实以元组形式返回</li>\n</ul>\n<h1 id=\"函数的类型\"><a href=\"#函数的类型\" class=\"headerlink\" title=\"函数的类型\"></a>函数的类型</h1><h2 id=\"普通函数\"><a href=\"#普通函数\" class=\"headerlink\" title=\"普通函数\"></a>普通函数</h2><p>普通函数属于自定义函数，满足函数规则即可</p>\n<h2 id=\"匿名函数\"><a href=\"#匿名函数\" class=\"headerlink\" title=\"匿名函数\"></a>匿名函数</h2><p>python 支持匿名函数，即函数名未知地定义，使用 lambda 表达式来定义</p>\n<h3 id=\"匿名函数定义方式\"><a href=\"#匿名函数定义方式\" class=\"headerlink\" title=\"匿名函数定义方式\"></a>匿名函数定义方式</h3><p>lambda [arg1 [,arg2, … argN]] : expression</p>\n<ul>\n<li>以上可以看出 lambda 表达式参数可以多个，但是只能有一个返回表达式</li>\n</ul>\n<p>一般 lambda 表达式用于简单的方法场合</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">test = lambda x, y: x ** y</span><br><span class=\"line\">print(test.__class__)</span><br><span class=\"line\">print(test)</span><br><span class=\"line\">print(test(3, 2))</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>以上发现 lambda 表达式就是一个 function （python中具体为 types.FunctionType）类的对象</li>\n</ul>\n<h2 id=\"内部函数\"><a href=\"#内部函数\" class=\"headerlink\" title=\"内部函数\"></a>内部函数</h2><p>一般来说，函数内部也可以定义新的函数。那么我们称这个函数为内部函数或局部函数</p>\n<p>内部函数的本质就是局部变量(函数就是一个变量)。在函数外部不可以直接调用（闭包机制可以打破）。内部函数在函数内部调用</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test1</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test2</span>():</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">test3</span>():</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        test3()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test3</span>():</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    test2()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test1()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/34.png\"></p>\n<ul>\n<li>以上我们可以看出内部函数可以嵌套，因为本质是局部变量我们依旧可以在外部定义一个和内部重名的函数</li>\n</ul>\n<h2 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h2><p>高阶函数本质也是普通函数，只不过 python 强调一切皆为对象，那么函数本身也是一个对象。怎么证明呢</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(test))</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/35.png\"></p>\n<ul>\n<li><p>这时会发现 test 为function类的实例对象。但是查阅资料知道 function 类引用被 del 了，只不过被一个类沿用，那就是 types 模块的 FunctionType 类</p>\n<p><img src=\"/./images/python/method/36.png\"></p>\n<p>那根据参数传递的本质就是传递一个个对象，那么函数依旧可以作为对象传入方法中，其中接收函数参数的方法就被称为高阶函数</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">x</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    result = <span class=\"built_in\">filter</span>(test, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">list</span>(result))</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/37.png\"></p>\n<p>从上面可以分析出，<code>filter()</code>内置函数把 test 作为参数传入进了方法里</p>\n</li>\n</ul>\n<h2 id=\"偏函数\"><a href=\"#偏函数\" class=\"headerlink\" title=\"偏函数\"></a>偏函数</h2><h3 id=\"偏函数使用情形\"><a href=\"#偏函数使用情形\" class=\"headerlink\" title=\"偏函数使用情形\"></a>偏函数使用情形</h3><p>函数在执行时，要带上所有必要的参数进行调用。但是，有时参数可以在函数被调用之前提前获知。这种情况下，一个函数有一个或多个参数预先就能用上，以便函数能用更少的参数进行调用。</p>\n<h3 id=\"偏函数使用方法：\"><a href=\"#偏函数使用方法：\" class=\"headerlink\" title=\"偏函数使用方法：\"></a>偏函数使用方法：</h3><p>要用到 functools 模块的 partial 方法</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> partial</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">x, y</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x &gt; y:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    result = partial(test, <span class=\"number\">5</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(result(<span class=\"number\">100</span>))</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/38.png\"></p>\n<ul>\n<li>很明显看出，我们已知 x &#x3D; 5，的前提下，把偏函数作为一个新函数进行传参就可以得到结果。从上面看出偏函数本质也是高阶函数</li>\n</ul>\n<h2 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h2><p>由于讲了函数可以作为参数传入，那么回调函数的作用就是把自身作为参数传入到一个新函数中，利用新函数的其他参数作为自身的参数进行操作</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test1</span>(<span class=\"params\">a</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">callback</span>(<span class=\"params\">function_name, b</span>):</span><br><span class=\"line\">    function_name(b)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    callback(test1, <span class=\"string\">&quot;我是回调函数&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/39.png\"></p>\n<h3 id=\"回调函数的异步处理\"><a href=\"#回调函数的异步处理\" class=\"headerlink\" title=\"回调函数的异步处理\"></a>回调函数的异步处理</h3><p><code>pass</code></p>\n<h3 id=\"回调函数的本质原因\"><a href=\"#回调函数的本质原因\" class=\"headerlink\" title=\"回调函数的本质原因\"></a>回调函数的本质原因</h3><p>回调函数之所以能这么使用是因为所有 函数都是 types.FunctionType 类的实例对象，而 python 提供了一个魔法方法 <code>__call__()</code>，这样可以使得他的对象都可以用对象名(args)进行使用。前提是一定要显示地写出来。</p>\n<p><img src=\"/./images/python/method/40.png\"></p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__call__</span>(<span class=\"params\">self, name, **kwargs</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(name)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test = A()</span><br><span class=\"line\">    test(<span class=\"string\">&quot;这就是函数带括号的底层原理&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/41.png\"></p>\n<ul>\n<li>以上不难看出我们的 test 对象竟然也可以写成 <code>test()</code>了，因为我们在 A 类里重写了 <code>__call__()</code> 方法，使得 test 对象可以作为函数名使用，同理这适用于回调函数语法。所以本质回调函数依旧是一种高阶函数</li>\n</ul>\n<h2 id=\"函数的闭包\"><a href=\"#函数的闭包\" class=\"headerlink\" title=\"函数的闭包\"></a>函数的闭包</h2><p>python 如果我们想对一个函数本身进行操作，那么那个操作本身也是函数。所以 python 提供函数内嵌套函数。通过这种方法我们能很好地处理不同函数的类似问题。通过闭包我们能在外部使用函数内的局部代码块了。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">outer</span>(<span class=\"params\">a</span>):</span><br><span class=\"line\">    a = a + <span class=\"number\">1</span>    </span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(a))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">inner</span>(<span class=\"params\">b</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(a))</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(b + a)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> inner</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">inner1 = outer(a=<span class=\"number\">7</span>)</span><br><span class=\"line\">inner1(b=<span class=\"number\">5</span>)</span><br><span class=\"line\">inner2 = outer(a=<span class=\"number\">8</span>)</span><br><span class=\"line\">inner2(b=<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/42.png\"></p>\n<ul>\n<li><p>由上面可以看到闭包机制一个特点是对每一次的局部变量的值可以保留在内层函数里。具体请参考</p>\n<a href=\"/2022/12/10/python/python%20%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/\" title=\"python 内存详解\">python 内存详解</a></li>\n</ul>\n<h2 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h2><p>python 提供的一种语法构造，由于之前分析的 闭包机制，那么我们想把一个函数对象当做参数传入到闭包机制中，那么 python 提供装饰器语法这样不用每次把原函数指向闭包后的新函数。这个闭包函数我们就称之为装饰器</p>\n<h3 id=\"装饰器的使用方法\"><a href=\"#装饰器的使用方法\" class=\"headerlink\" title=\"装饰器的使用方法\"></a>装饰器的使用方法</h3><p>本质是将所装饰的函数对象作为参数传输到装饰器函数中去。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">calculate_runtime</span>(<span class=\"params\">method</span>):</span><br><span class=\"line\">    start = time.time()</span><br><span class=\"line\">    method()</span><br><span class=\"line\">    end = time.time()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(end - start)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">play_game</span>():</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">200000</span>):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;游戏打完了&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">shopping</span>():</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">80000</span>):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;东西打完了&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    calculate_runtime(play_game)</span><br><span class=\"line\">    calculate_runtime(shopping)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/43.png\"></p>\n<p>很明显这种方式处理函数会有局限性，因为我们只想对函数功能进行添加，当自己运行函数的时候就可以</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">calculate_runtime</span>(<span class=\"params\">method</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">run</span>():</span><br><span class=\"line\">        start = time.time()</span><br><span class=\"line\">        method()</span><br><span class=\"line\">        end = time.time()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(end - start)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> run</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">play_game</span>():</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">200000</span>):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;游戏打完了&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">shopping</span>():</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">80000</span>):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;东西打完了&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">play_game = calculate_runtime(play_game)</span><br><span class=\"line\">play_game()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;*&quot;</span>*<span class=\"number\">50</span>)</span><br><span class=\"line\">shopping = calculate_runtime(shopping)</span><br><span class=\"line\">shopping()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p>​\t<img src=\"/./images/python/method/44.png\"></p>\n<h3 id=\"装饰器的语法糖\"><a href=\"#装饰器的语法糖\" class=\"headerlink\" title=\"装饰器的语法糖\"></a>装饰器的语法糖</h3><p>这种方式比上一种好的是，我能直接运行原来的函数使得功能性不一样了，但是每次都用 method &#x3D; function(method) 太麻烦了。在定义函数体上方用 <code>@装饰器名</code>去装饰所定义的函数，我们称之为 <em>语法糖</em>。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">calculate_runtime</span>(<span class=\"params\">method</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">run</span>():</span><br><span class=\"line\">        start = time.time()</span><br><span class=\"line\">        method()</span><br><span class=\"line\">        end = time.time()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(end - start)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> run</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@calculate_runtime</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">play_game</span>():</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">200000</span>):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;游戏打完了&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@calculate_runtime</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">shopping</span>():</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">80000</span>):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;东西打完了&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    play_game()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;*&quot;</span>*<span class=\"number\">50</span>)</span><br><span class=\"line\">    shopping()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/45.png\"></p>\n<h3 id=\"装饰器内部的参数设置\"><a href=\"#装饰器内部的参数设置\" class=\"headerlink\" title=\"装饰器内部的参数设置\"></a>装饰器内部的参数设置</h3><p>以上例子有大量的局限性：被装饰的方法没有参数。如果被装饰的方法有参数，并且参数不唯一且可变呢。那么我们直接使用我们的可变位置参数和可变强制参数来传值</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">calculate_runtime</span>(<span class=\"params\">method</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">run</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">        start = time.time()</span><br><span class=\"line\">        method(*args, **kwargs)</span><br><span class=\"line\">        end = time.time()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(end - start)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> run</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@calculate_runtime</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">play_game</span>(<span class=\"params\">game, times=<span class=\"number\">200000</span></span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(times):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;游戏<span class=\"subst\">&#123;game&#125;</span>打完了&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    play_game(<span class=\"string\">&quot;csgo&quot;</span>, <span class=\"number\">100000</span>)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/46.png\"></p>\n<h3 id=\"有参装饰器\"><a href=\"#有参装饰器\" class=\"headerlink\" title=\"有参装饰器\"></a>有参装饰器</h3><p>我们发现装饰器虽好，但是我们需要的功能比较多的时候，需要用到外部其他变量的时候，其中内部 warpper() 和外部的 outer() 方法都不能添加其他额外的参数，因为写法已经固定了。所以我们可以通过外层嵌套另外一层函数来实现</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">argument_</span>(<span class=\"params\">sleep_time</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">calculate_runtime</span>(<span class=\"params\">method</span>):</span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">run</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">            start = time.time()</span><br><span class=\"line\">            method(*args, **kwargs)</span><br><span class=\"line\">            time.sleep(sleep_time)</span><br><span class=\"line\">            end = time.time()</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(end - start)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> run</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> calculate_runtime</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@argument_(<span class=\"params\"><span class=\"number\">2</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">play_game</span>(<span class=\"params\">game, times=<span class=\"number\">200000</span></span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(times):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;游戏<span class=\"subst\">&#123;game&#125;</span>打完了&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    play_game(<span class=\"string\">&quot;csgo&quot;</span>, <span class=\"number\">100000</span>)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/47.png\"></p>\n<ul>\n<li>以上我们不难看出通过这种方法成功实现了再次操控被装饰的函数</li>\n</ul>\n<h3 id=\"伪装原函数\"><a href=\"#伪装原函数\" class=\"headerlink\" title=\"伪装原函数\"></a>伪装原函数</h3><p>我们要想达到对原函数的完全装饰而让外部不察觉出来，我们可以通过伪装原函数进行实现。</p>\n<p>第一个例子如下</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">calculate_runtime</span>(<span class=\"params\">method</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">run</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">        start = time.time()</span><br><span class=\"line\">        method(*args, **kwargs)</span><br><span class=\"line\">        end = time.time()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(end - start)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> run</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@calculate_runtime</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">play_game</span>(<span class=\"params\">game, times=<span class=\"number\">200000</span></span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(times):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;游戏<span class=\"subst\">&#123;game&#125;</span>打完了&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;该去吃饭了&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    result = play_game(<span class=\"string\">&quot;csgo&quot;</span>, <span class=\"number\">100000</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(result)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/48.png\"></p>\n<ul>\n<li>很明显，该函数没有返回值，这样没办法达到不改变其函数的内部性质</li>\n</ul>\n<p>第二个例子</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">calculate_runtime</span>(<span class=\"params\">method</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">run</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">        start = time.time()</span><br><span class=\"line\">        method(*args, **kwargs)</span><br><span class=\"line\">        end = time.time()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(end - start)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> run</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@calculate_runtime</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">play_game</span>(<span class=\"params\">game, times=<span class=\"number\">200000</span></span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(times):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;游戏<span class=\"subst\">&#123;game&#125;</span>打完了&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(play_game.__name__)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(play_game.__str__())</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/49.png\"></p>\n<ul>\n<li>很明显，由于装饰器本质是闭包，那么使用装饰器后，函数的引用指向了内部的方法，所以很多函数的属性值会跟着变化。</li>\n</ul>\n<p>以上例子说明了我们没有真正地实现不改变函数的内部属性来实现额外的功能。我们可以通过调用 functools 的 warps() 装饰器来装饰内部的函数使得原来函数的属性不改变，原理就是提前在内部拷贝一份原来函数的所有属性值。函数的返回值我们直接用一个变量来接收并返回</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">calculate_runtime</span>(<span class=\"params\">method</span>):</span><br><span class=\"line\"><span class=\"meta\">    @functools.wraps(<span class=\"params\">method</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">run</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">        start = time.time()</span><br><span class=\"line\">        result = method(*args, **kwargs)</span><br><span class=\"line\">        end = time.time()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(end - start)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> run</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@calculate_runtime</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">play_game</span>(<span class=\"params\">game, times=<span class=\"number\">200000</span></span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(times):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;游戏<span class=\"subst\">&#123;game&#125;</span>打完了&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;该吃饭了&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    result = play_game(<span class=\"string\">&quot;cf&quot;</span>, <span class=\"number\">30000</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(result)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(play_game.__name__)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(play_game.__str__())</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/50.png\"></p>\n<h3 id=\"装饰器模板\"><a href=\"#装饰器模板\" class=\"headerlink\" title=\"装饰器模板\"></a>装饰器模板</h3><p>我们发现装饰器有共同的结构，这样就形成了一个装饰器模板</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">outer_</span>(<span class=\"params\">*arg, **kwarg</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">outer</span>(<span class=\"params\">functions</span>):</span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">warpper</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">            result = functions(*args, **kwargs)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\">        <span class=\"keyword\">return</span> warpper</span><br><span class=\"line\">    <span class=\"keyword\">return</span> outer</span><br></pre></td></tr></table></figure>\n\n<p>以上就构成了一个有参装饰器的模板了</p>\n<h3 id=\"多个装饰器装饰一个函数\"><a href=\"#多个装饰器装饰一个函数\" class=\"headerlink\" title=\"多个装饰器装饰一个函数\"></a>多个装饰器装饰一个函数</h3><p>当多个装饰器装饰一个函数那么执行顺序是什么呢</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">outer_1</span>(<span class=\"params\">*arg, **kwarg</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">outer</span>(<span class=\"params\">functions</span>):</span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">warpper</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;这是 outer_1 之前&quot;</span>)</span><br><span class=\"line\">            result = functions(*args, **kwargs)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;这是 outer_1 之后&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> warpper</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> outer</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">outer_2</span>(<span class=\"params\">*arg, **kwarg</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">outer</span>(<span class=\"params\">functions</span>):</span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">warpper</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;这是 outer_2 之前&quot;</span>)</span><br><span class=\"line\">            result = functions(*args, **kwargs)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;这是 outer_2 之后&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> warpper</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> outer</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@outer_2()</span></span><br><span class=\"line\"><span class=\"meta\">@outer_1()</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/method/51.png\"></p>\n<ul>\n<li>以上我们不难看出装饰顺序是先用最靠近函数的 outer_1() 装饰器然后是 outer_2() 装饰器</li>\n<li>通过栈的压栈和出栈可以解释以上返回值<ol>\n<li>调用 test() 本质是执行 <code>outer_2.outer(outer_1.outer(test))</code></li>\n<li>压栈原理，程序执行到 <code>outer_2.outer()</code>后会先执行 <code>print(&quot;这是 outer_2 之前&quot;)</code></li>\n<li>然后碰到 <code>funtions</code>此时传入 <code>outer_1.outer</code> 进行执行 <code>print(&quot;这是 outer_1 之前&quot;)</code></li>\n<li>接着执行原函数</li>\n<li>然后执行接着第 3 步骤的<code>print(&quot;这是 outer_1 之后&quot;)</code></li>\n<li>等 <code>outer_1.outer()</code>执行完毕就会得到 result 的返回值。注意这里的 <code>result</code> 并不是直观意义上的 <code>outer_1.outer</code> 这个引用，而是多重调用装饰器，内部优化成 <code>outer_1.outer (test)()</code>，这样 <code>outer2.outer</code> 里的接收的返回值其实本质就是 <code>outer1.outer</code> 里的 result 的值</li>\n<li>最后再执行 outer_2 的<code>print(&quot;这是 outer_2 之后&quot;)</code></li>\n</ol>\n</li>\n</ul>\n<h3 id=\"装饰器的本质\"><a href=\"#装饰器的本质\" class=\"headerlink\" title=\"装饰器的本质\"></a>装饰器的本质</h3><p>以上可以看到装饰器本质就是闭包，只不过参数变为了被装饰的函数。</p>\n","categories":["python"],"tags":["python","函数","方法"]},{"title":"python 循环控制 break 和 continue","url":"/2022/12/08/python/python%20%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%20break%20%E5%92%8C%20continue/","content":"<p>一般来说 break 和 continute 控制的是本层循环，不影响外层循环，如若要退出则使用 return 语句进行</p>\n<p><img src=\"/./images/python/continue&break/1.png\"></p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">6</span>):</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;j = <span class=\"subst\">&#123;j&#125;</span>&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> j &gt; <span class=\"number\">2</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;i = <span class=\"subst\">&#123;i&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/continue&break/2.png\"></p>\n<p>由上看出，即时 break 了，依旧不会跳过外层循环</p>\n<span id=\"more\"></span>\n","categories":["python"],"tags":["python","循环"]},{"title":"python 字符串常用方法","url":"/2022/12/08/python/python%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","content":"<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><ul>\n<li><p><a href=\"https://www.bilibili.com/video/BV1wD4y1o7AS?p=78&amp;vd_source=f9937d98d0a8cc08ef5248c3c127d588\">https://www.bilibili.com/video/BV1wD4y1o7AS?p=78&amp;vd_source=f9937d98d0a8cc08ef5248c3c127d588</a></p>\n</li>\n<li><p>其他类型常用方法具体可以参考以下文档</p>\n<ul>\n<li><a href=\"/2022/12/07/python/python%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/\" title=\"python 基本数据类型常用方法\">python 基本数据类型常用方法</a></li>\n</ul>\n</li>\n</ul>\n<span id=\"more\"></span>\n\n<h1 id=\"查询操作\"><a href=\"#查询操作\" class=\"headerlink\" title=\"查询操作\"></a>查询操作</h1><p><img src=\"/./images/python/string/1.png\"></p>\n<h1 id=\"转换大小写\"><a href=\"#转换大小写\" class=\"headerlink\" title=\"转换大小写\"></a>转换大小写</h1><p><img src=\"/./images/python/string/2.png\"></p>\n<h1 id=\"对齐字符串\"><a href=\"#对齐字符串\" class=\"headerlink\" title=\"对齐字符串\"></a>对齐字符串</h1><p><img src=\"/./images/python/string/3.png\"></p>\n<h1 id=\"字符串的拆分\"><a href=\"#字符串的拆分\" class=\"headerlink\" title=\"字符串的拆分\"></a>字符串的拆分</h1><p><img src=\"/./images/python/string/4.png\"></p>\n<h1 id=\"字符串的判断\"><a href=\"#字符串的判断\" class=\"headerlink\" title=\"字符串的判断\"></a>字符串的判断</h1><p><img src=\"/./images/python/string/5.png\"></p>\n<h1 id=\"字符串的替换\"><a href=\"#字符串的替换\" class=\"headerlink\" title=\"字符串的替换\"></a>字符串的替换</h1><p><img src=\"/./images/python/string/6.png\"></p>\n<h1 id=\"比较字符串\"><a href=\"#比较字符串\" class=\"headerlink\" title=\"比较字符串\"></a>比较字符串</h1><p><img src=\"/./images/python/string/7.png\"></p>\n<p>其中 <code>ord(str) </code>方法可以查看该字符的ASCII编码</p>\n  <figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">ord</span>(<span class=\"string\">&quot;a&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">      test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/string/8.png\"></p>\n<h1 id=\"格式化字符串和数字\"><a href=\"#格式化字符串和数字\" class=\"headerlink\" title=\"格式化字符串和数字\"></a>格式化字符串和数字</h1><p><img src=\"/./images/python/string/9.png\"></p>\n<h1 id=\"字符串前缀\"><a href=\"#字符串前缀\" class=\"headerlink\" title=\"字符串前缀\"></a>字符串前缀</h1><h2 id=\"r\"><a href=\"#r\" class=\"headerlink\" title=\"r\"></a><code>r</code></h2><p>整个字符串都会被视为原生的字符串。其中的 \\ 转义将不再实现</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_str</span>():</span><br><span class=\"line\">    str_test = <span class=\"string\">&quot;第一行\\n第二行&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(str_test)</span><br><span class=\"line\">    str_test = <span class=\"string\">r&quot;第一行\\n第二行&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(str_test)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_str()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/string/10.png\"></p>\n<h2 id=\"b\"><a href=\"#b\" class=\"headerlink\" title=\"b\"></a><code>b</code></h2><p>用来表示后面字符串是bytes 类型。网络编程中，服务器和浏览器只认bytes 类型数据</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_str</span>():</span><br><span class=\"line\">    a = <span class=\"string\">b&#x27;\\xe6\\xb5\\x8b\\xe8\\xaf\\x95&#x27;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a.decode(encoding=<span class=\"string\">&quot;UTF-8&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_str()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/string/11.png\"></p>\n<h2 id=\"u\"><a href=\"#u\" class=\"headerlink\" title=\"u\"></a><code>u</code></h2><p>表示后面字符串采用的编码字符集为 unicode，现在内存中默认的编码格式为 unicode 在这个字符集里面所有的语言字符都可以通过特定的符号来表示。一般用在中文字符串前面，防止因为源码储存格式问题，导致再次使用时出现乱码。python3 中默认都是 unicode 编码格式</p>\n<ul>\n<li>pass</li>\n</ul>\n","categories":["python"],"tags":["python","常用方法","字符串"]},{"title":"python 运算符","url":"/2022/12/05/python/python%20%E8%BF%90%E7%AE%97%E7%AC%A6/","content":"<h1 id=\"运算符的分类\"><a href=\"#运算符的分类\" class=\"headerlink\" title=\"运算符的分类\"></a>运算符的分类</h1><p>python 运算符分为 算术运算符、赋值运算符、比较运算符、布尔运算符、位运算符</p>\n<h2 id=\"算术运算符\"><a href=\"#算术运算符\" class=\"headerlink\" title=\"算术运算符\"></a>算术运算符</h2><p>算术运算符分为 标准运算符、取余运算符、幂运算符</p>\n<ul>\n<li>算术运算符满足以下规则<ul>\n<li><img src=\"/./images/python/operator/1.png\"></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"标准运算符\"><a href=\"#标准运算符\" class=\"headerlink\" title=\"标准运算符\"></a>标准运算符</h3><blockquote>\n<p>+ -  *  /  //</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h4 id=\"整除运算符\"><a href=\"#整除运算符\" class=\"headerlink\" title=\"整除运算符\"></a>整除运算符</h4><p>其中/为整除运算符，若两者异号，则向下取整</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    value1 = <span class=\"number\">20</span>/-<span class=\"number\">3</span></span><br><span class=\"line\">    value2 = <span class=\"number\">20</span>//-<span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/operator/2.png\"></p>\n<h4 id=\"取余运算符\"><a href=\"#取余运算符\" class=\"headerlink\" title=\"取余运算符\"></a>取余运算符</h4><p>% 为取余运算符。规则是同号则直接取余数。异号余数 &#x3D; 被除数 - 除数*商</p>\n<p>其中以上的 商 为两者整除而来 如  -20%3的商为 -20&#x2F;&#x2F;3</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    value1 = -<span class=\"number\">20</span>%-<span class=\"number\">3</span></span><br><span class=\"line\">    value2 = -<span class=\"number\">20</span>%<span class=\"number\">3</span></span><br><span class=\"line\">    value3 = <span class=\"number\">20</span>%-<span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value2)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value3)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/operator/3.png\"></p>\n<h4 id=\"幂运算符\"><a href=\"#幂运算符\" class=\"headerlink\" title=\"幂运算符\"></a>幂运算符</h4><p>**为幂运算符，a**b 表示 a 的 b 次 幂</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    value1 = -<span class=\"number\">2</span>**<span class=\"number\">3</span></span><br><span class=\"line\">    value2 = -<span class=\"number\">2</span>**-<span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/operator/4.png\"></p>\n<h2 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h2><p>&#x3D; 即为赋值运算符。</p>\n<ul>\n<li><p>执行顺序为 从右往左 a&#x3D;b&#x3D;c&#x3D;1</p>\n</li>\n<li><p>支持参数赋值 a +&#x3D; b，a &#x2F;&#x2F;&#x3D; b …..</p>\n</li>\n<li><p>支持系列解包赋值 a，b &#x3D; b， a，常用于交换两者的值</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    value1 = <span class=\"number\">1</span></span><br><span class=\"line\">    value2 = <span class=\"number\">2</span></span><br><span class=\"line\">    value1, value2 = value2, value1</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value2)</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>  返回</p>\n<p>  <img src=\"/./images/python/operator/5.png\"></p>\n</li>\n</ul>\n<h2 id=\"比较运算符\"><a href=\"#比较运算符\" class=\"headerlink\" title=\"比较运算符\"></a>比较运算符</h2><blockquote>\n<p>&gt;，&lt;， &gt;&#x3D;，&lt;&#x3D;，!&#x3D;，&#x3D;&#x3D;</p>\n</blockquote>\n<p>返回值为 bool 类型，比较的是两者的 _value 值</p>\n<p>is ，is not。is 代表 是 id 相等，is not 代表 id 不相等</p>\n<p>返回值为 bool 类型，比较的是两者的 id 值</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    value1 = <span class=\"number\">1</span></span><br><span class=\"line\">    value2 = <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value1 == value2)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;-----------------------&quot;</span>)</span><br><span class=\"line\">    value3 = [<span class=\"number\">1</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>]]</span><br><span class=\"line\">    value4 = [<span class=\"number\">1</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>]]</span><br><span class=\"line\">    value5 = value3</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(value3), <span class=\"built_in\">id</span>(value4), <span class=\"built_in\">id</span>(value5))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;-----------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value3 <span class=\"keyword\">is</span> value4)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value3 <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> value5)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value4 <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> value5)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/operator/6.png\"></p>\n<h2 id=\"bool-运算符\"><a href=\"#bool-运算符\" class=\"headerlink\" title=\"bool 运算符\"></a>bool 运算符</h2><p>python 一切对象都有对应的 bool 值</p>\n<p><img src=\"/./images/python/operator/7.png\"></p>\n<p>and ，or，not，in，not in （其中 in， not in 表示是否在序列中）</p>\n<ul>\n<li><p>其中 and 和 or 拥有短路性。即 a and b a为false，b不再进行。同理 a or b，a为真 b不再进行</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">m = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test1</span>():</span><br><span class=\"line\">    m.clear()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(m)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test2</span>():</span><br><span class=\"line\">    m.append(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(m)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_bool</span>():</span><br><span class=\"line\">    a = <span class=\"literal\">True</span></span><br><span class=\"line\">    b = <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(b <span class=\"keyword\">and</span> test1())</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a <span class=\"keyword\">or</span> test2())</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_bool()</span><br></pre></td></tr></table></figure>\n\n<p>  返回</p>\n<p>  <img src=\"/./images/python/operator/8.png\"></p>\n</li>\n<li><p>注意 a and b 其中 a，b不一定是bool 类型。a and b 返回值也不一定是 bool 类型</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"literal\">None</span> <span class=\"keyword\">and</span> <span class=\"number\">5</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"number\">1</span> <span class=\"keyword\">and</span> <span class=\"string\">&#x27;hello&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"literal\">None</span> <span class=\"keyword\">or</span> <span class=\"literal\">None</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;hello&quot;</span> <span class=\"keyword\">or</span> <span class=\"literal\">None</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>  返回</p>\n<p>  <img src=\"/./images/python/operator/9.png\"></p>\n<p>  实际中不确定 a，b 类型情况下想返回 bool 类型建议 bool(a) and bool(b) 这样能确定100%返回 bool 类型</p>\n</li>\n</ul>\n<h2 id=\"位运算符\"><a href=\"#位运算符\" class=\"headerlink\" title=\"位运算符\"></a>位运算符</h2><p>&amp; 按位与。| 按位或。&gt;&gt; 按位右移。&lt;&lt;按位左移。^为异或。~为按位取反</p>\n<p>以下为运算规则</p>\n<p><img src=\"/./images/python/operator/10.png\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"number\">3</span> &amp; <span class=\"number\">6</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"number\">3</span> | <span class=\"number\">6</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"number\">3</span> &gt;&gt; <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"number\">3</span> &lt;&lt; <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/operator/11.png\"></p>\n<p>注意，参与运算要按照补码进行计算</p>\n<p>原码，反码，补码规则如下</p>\n<ul>\n<li>正数<ul>\n<li>原码，反码，补码相同。符号位都为0</li>\n</ul>\n</li>\n<li>负数<ul>\n<li>原码符号位为1.反码是符号位不变，其余按位取反。补码是反码 + 1</li>\n</ul>\n</li>\n</ul>\n<p>根据以上规则我们可以计算出负数的 按位与 和 按位或</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(-<span class=\"number\">3</span> &amp; -<span class=\"number\">6</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(-<span class=\"number\">3</span> | -<span class=\"number\">6</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(-<span class=\"number\">3</span> &gt;&gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(-<span class=\"number\">3</span> &lt;&lt; <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/operator/12.png\"></p>\n<p>验算</p>\n<p><img src=\"/./images/python/operator/13.png\"></p>\n<p>同理可以算出其他值。</p>\n<ul>\n<li>注意移位运算符符号位补位为当前符号。即符号位永远保持同号</li>\n</ul>\n<h3 id=\"按位取反\"><a href=\"#按位取反\" class=\"headerlink\" title=\"~  按位取反\"></a>~  按位取反</h3><p>值得注意的是按位取反符号位要参与</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(~-<span class=\"number\">3</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(~<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/operator/14.png\"></p>\n<h3 id=\"异或\"><a href=\"#异或\" class=\"headerlink\" title=\"^异或\"></a>^异或</h3><p>即A^B &#x3D; （A and !B）or (!A and B)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"number\">5</span> ^ -<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/operator/15.png\"></p>\n<p>异或可以不借助第三方参数进行交换值</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">exchange</span>(<span class=\"params\">a, b</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a, b)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;-----------------&quot;</span>)</span><br><span class=\"line\">    a = a ^ b</span><br><span class=\"line\">    b = a ^ b</span><br><span class=\"line\">    a = a ^ b</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a, b)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    exchange(<span class=\"number\">6</span>, <span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/operator/16.png\"></p>\n<p>证明</p>\n<p><img src=\"/./images/python/operator/17.png\"></p>\n<h1 id=\"运算符优先级\"><a href=\"#运算符优先级\" class=\"headerlink\" title=\"运算符优先级\"></a>运算符优先级</h1><p>运算符优先级参考如下：</p>\n<p><img src=\"/./images/python/operator/18.png\"></p>\n<p>python3 官方参考</p>\n<p><img src=\"/./images/python/operator/19.png\"></p>\n","categories":["python"],"tags":["python","运算符"]},{"title":"python 类详解","url":"/2022/12/10/python/python%20%E7%B1%BB%E8%AF%A6%E8%A7%A3/","content":"<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><ul>\n<li><a href=\"/2022/12/10/python/python%20%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/\" title=\"python 内存详解\">python 内存详解</a></li>\n</ul>\n<p>python 作为贯彻一切皆为对象的法则，那么类的组成就很重要了</p>\n<h1 id=\"类的定义\"><a href=\"#类的定义\" class=\"headerlink\" title=\"类的定义\"></a>类的定义</h1><p>python 用 class 定义类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class HelloWorld:</span><br><span class=\"line\">    pass</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &#x27;__main__&#x27;:</span><br><span class=\"line\">    print(HelloWorld)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/class/1.png\"></p>\n<p>#类的命名法则</p>\n<p>python 类名的法则遵循驼峰法则，如 HelloWorld，GetRequest …… 这点和 python 的函数名和变量名不同</p>\n<ul>\n<li>参考 <a href=\"/2022/12/08/python/python%20%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/\" title=\"python 函数详解\">python 函数详解</a></li>\n</ul>\n<h1 id=\"类对象的初始化\"><a href=\"#类对象的初始化\" class=\"headerlink\" title=\"类对象的初始化\"></a>类对象的初始化</h1><p>python 初始化类使用类名() 的方式进行初始化</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorld</span>:</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    helloworld = HelloWorld()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(helloworld.__class__)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/class/2.png\"></p>\n<h1 id=\"类结构的组成\"><a href=\"#类结构的组成\" class=\"headerlink\" title=\"类结构的组成\"></a>类结构的组成</h1><p>python 为类提供</p>\n<ol>\n<li>类变量</li>\n<li>类方法</li>\n<li>实例方法</li>\n<li>实例变量</li>\n<li>静态方法</li>\n</ol>\n<p>其中前三项称为类属性，都能通过对象取调用它们，也可以通过类名直接访问</p>\n<h2 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h2><p>python 类中最简单的一种方法，直接在类中写入方法，但是要在方法前添加 @staticmethod 装饰器来修饰。静态方法与类对象无关。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestStaticMethod</span>:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @staticmethod</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">random</span>():</span><br><span class=\"line\">        a = random.randrange(<span class=\"number\">10</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test = TestStaticMethod()</span><br><span class=\"line\">    test.random()</span><br><span class=\"line\">    TestStaticMethod.random()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/class/3.png\"></p>\n<ul>\n<li>从以上我们可以看出，静态方法可以通过对象调用也可以通过类名调用</li>\n</ul>\n<p>值得注意的是，静态方法由于参数没有 self 这个对象，那么无法调用 实例变量和实例方法</p>\n<h2 id=\"类变量\"><a href=\"#类变量\" class=\"headerlink\" title=\"类变量\"></a>类变量</h2><p>直接在类体里定义的变量我们称为类变量。因为这个变量属于类本身，因为类本身也是一个对象，但是这个类变量不属于类的对象，却可以通过类的对象调用。可以参考 <a href=\"/2022/12/10/python/python%20%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/\" title=\"python 内存详解\">python 内存详解</a></p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestClassVariable</span>:</span><br><span class=\"line\">    a = <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test = TestClassVariable()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test.a)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(TestClassVariable.a)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/class/4.png\"></p>\n<ul>\n<li>可以看到对象和类名都能直接访问类变量</li>\n</ul>\n<h2 id=\"python-类特点\"><a href=\"#python-类特点\" class=\"headerlink\" title=\"python 类特点\"></a>python 类特点</h2><p>和 java 不同，python 动态语言特点初始化多个类实例后，类对象会跟着变化</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestClassVariable</span>:</span><br><span class=\"line\">    a = <span class=\"string\">&quot;old&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test1 = TestClassVariable()</span><br><span class=\"line\">    TestClassVariable.a = <span class=\"string\">&quot;new&quot;</span></span><br><span class=\"line\">    test2 = TestClassVariable()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test1.a)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test2.a)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/class/5.png\"></p>\n<h2 id=\"动态赋值\"><a href=\"#动态赋值\" class=\"headerlink\" title=\"动态赋值\"></a>动态赋值</h2><p>python 为动态编程语言，可以动态地给类变量赋值，但是前提是一定要用类名调用，否则系统会认为这是动态给实例变量赋值，参考下文有关实例变量的解释</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestClassVariable</span>:</span><br><span class=\"line\">    a = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test1 = TestClassVariable()</span><br><span class=\"line\">    TestClassVariable.b = <span class=\"string\">&quot;新添加&quot;</span></span><br><span class=\"line\">    test2 = TestClassVariable()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(TestClassVariable.b)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test1.b)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test2.b)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/class/6.png\"></p>\n<p>如果我们用对象赋值会发生什么呢</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestClassVariable</span>:</span><br><span class=\"line\">    a = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test1 = TestClassVariable()</span><br><span class=\"line\">    test1.b = <span class=\"string\">&quot;新添加&quot;</span></span><br><span class=\"line\">    test2 = TestClassVariable()</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(TestClassVariable.b)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> AttributeError <span class=\"keyword\">as</span> a:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(test1.b)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(test2.b)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> AttributeError <span class=\"keyword\">as</span> a:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(a)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/class/7.png\"></p>\n<ul>\n<li>所以，类变量是属于类本身的，类的对象仅仅是通过类指针去访问而已，python 解释器相当于把 test.a 当做了 TestClassVariable.a 而已</li>\n</ul>\n<h2 id=\"类方法\"><a href=\"#类方法\" class=\"headerlink\" title=\"类方法\"></a>类方法</h2><p>类方法是在类中定义的方式使用 @classmethod 装饰器修饰的方法，它也属于类属性</p>\n","categories":["python"],"tags":["python","类"]},{"title":"python 迭代器和生成器","url":"/2022/12/10/python/python%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/","content":"<h1 id=\"迭代器（iterator）\"><a href=\"#迭代器（iterator）\" class=\"headerlink\" title=\"迭代器（iterator）\"></a>迭代器（iterator）</h1><p>python 独有的一种数据类型。要理清迭代器是什么，首先得弄懂什么要可迭代（iterable）</p>\n<h2 id=\"可迭代类与可迭代对象\"><a href=\"#可迭代类与可迭代对象\" class=\"headerlink\" title=\"可迭代类与可迭代对象\"></a>可迭代类与可迭代对象</h2><p>python 规定如果一个类定义了一个 <code>__iter__()</code> 的魔法方法的话，那么这个类就是 可迭代类，它的实例化对象就是一个 可迭代对象</p>\n<p>我们可以导入 <code>collections</code> 包的 <code>abc</code> 模块查看某个对象是否是 <code>Iterable</code> 的</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> abc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestIterable</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__iter__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    iterable = TestIterable()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">isinstance</span>(iterable, abc.Iterable))</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/iterator/1.png\"></p>\n<p>从上面我们可以看到，类 <code>TestIterable</code> 定义了一个 <code>__iter__()</code> 方法，并且要返回一个对象，这里是它本身，那么 <code>TestIterable</code> 类就被称为 可迭代类，它的对象 <code>iterable</code> 就被称为 可迭代对象</p>\n<h3 id=\"可迭代对象的-iter-方法\"><a href=\"#可迭代对象的-iter-方法\" class=\"headerlink\" title=\"可迭代对象的 __iter()__方法\"></a>可迭代对象的 <code>__iter()__</code>方法</h3><p>由于 <code>__iter__()</code> 是可迭代对象的方法，那么它本身可以调用它</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestIterable</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__iter__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;我是可迭代对象的 __iter__() 方法&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    iterable = TestIterable()</span><br><span class=\"line\">    iterable.__iter__()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/iterator/2.png\"></p>\n<h3 id=\"内置函数-iter\"><a href=\"#内置函数-iter\" class=\"headerlink\" title=\"内置函数 iter()\"></a>内置函数 <code>iter()</code></h3><p>python 提供一个内置方法 <code>iter()</code> 方法可以直接调用对象的 <code>__iter__()</code> 方法</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestIterable</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__iter__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;我是可迭代对象的 __iter__() 方法&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    iterable = TestIterable()</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"built_in\">iter</span>(iterable)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> TypeError <span class=\"keyword\">as</span> t:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(t)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/iterator/3.png\"></p>\n<ul>\n<li>以上不难发现，<code>iter()</code> 方法确实是调用了 <code>__iter__()</code> 方法，但是本身抛出了一个异常，因为返回值不是一个 迭代器，而是一个无类型的 None</li>\n</ul>\n<h3 id=\"对-for-循环进行重新认识\"><a href=\"#对-for-循环进行重新认识\" class=\"headerlink\" title=\"对 for 循环进行重新认识\"></a>对 for 循环进行重新认识</h3><figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_iterable</span>():</span><br><span class=\"line\">    test_list = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\">    test_tuple = (<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">    test_dict = &#123;<span class=\"number\">1</span>:<span class=\"string\">&quot;FIRST&quot;</span>, <span class=\"number\">2</span>:<span class=\"string\">&quot;SECOND&quot;</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> test_list:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(i)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> test_tuple:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(j)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> test_dict:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(k)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_iterable()</span><br></pre></td></tr></table></figure>\n\n<p>是什么能让 <code>list</code>，<code>tuple</code>，<code>dict</code> 进行 for in 循环呢。答案是 <code>list</code>，<code>tuple</code>，<code>dict</code> 是可迭代类，理由如下</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_iterable</span>():</span><br><span class=\"line\">    test_list = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\">    test_tuple = (<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">    test_dict = &#123;<span class=\"number\">1</span>:<span class=\"string\">&quot;FIRST&quot;</span>, <span class=\"number\">2</span>:<span class=\"string\">&quot;SECOND&quot;</span>&#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">dir</span>(test_list))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">dir</span>(test_tuple))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">dir</span>(test_dict))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_iterable()</span><br></pre></td></tr></table></figure>\n\n<p>通过内置 <code>dir()</code> 找到三个不同对象所有的类属性</p>\n<p><img src=\"/./images/python/iterator/4.png\"></p>\n<ul>\n<li>注意到这三个类都定义了 <code>__iter__()</code> 方法，所以他们的对象才都时可迭代的，因此才能被 for in 循环遍历</li>\n</ul>\n<h3 id=\"可迭代对象进行-for-循环\"><a href=\"#可迭代对象进行-for-循环\" class=\"headerlink\" title=\"可迭代对象进行 for 循环\"></a>可迭代对象进行 for 循环</h3><figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestIterable</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__iter__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;我是可迭代对象的 __iter__() 方法&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    iterable = TestIterable()</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> iterable:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(i)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> TypeError <span class=\"keyword\">as</span> t:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(t)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/iterator/5.png\"></p>\n<ul>\n<li>可以看到 for in 循环和 <code>iter()</code> 方法一样，同样调用了 <code>__iter__()</code> 方法，并且也会提示抛出了一个异常，因为返回值不是一个 迭代器，而是一个无类型的 None。以下讲解什么是迭代器</li>\n</ul>\n<h2 id=\"迭代类和迭代器\"><a href=\"#迭代类和迭代器\" class=\"headerlink\" title=\"迭代类和迭代器\"></a>迭代类和迭代器</h2><p>了解完可迭代类和可迭代对象后，我们对迭代类和迭代器作出讲解</p>\n<p>python 规定一个类如果同时定义了 <code>__iter__()</code> 和 <code>__next__()</code>方法时，那么我们就称这个类为迭代类或者叫迭代器类，同理它的对象被称为 迭代对象 或者叫 迭代器</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> abc</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestIterator</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__iter__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__next__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    iterator = TestIterator()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">isinstance</span>(iterator, abc.Iterable))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">isinstance</span>(iterator, abc.Iterator))</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/iterator/6.png\"></p>\n<ul>\n<li>发现迭代器依旧本身也是一个可迭代对象，因为它的类同样包含 <code>__iter__()</code> 方法，不同的是，它还是迭代器，因为其中包含 <code>__next__()</code> 方法</li>\n</ul>\n<h3 id=\"对迭代器对象的-iter\"><a href=\"#对迭代器对象的-iter\" class=\"headerlink\" title=\"对迭代器对象的 iter()\"></a>对迭代器对象的 <code>iter()</code></h3><p>首先，我们对迭代器对象进行 <code>iter()</code>方法处理</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestIterator</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__iter__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__next__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    iterator = TestIterator()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">iter</span>(iterator))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(<span class=\"built_in\">iter</span>(iterator)))</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/iterator/7.png\"></p>\n<ul>\n<li>会发现这次和上面可迭代对象不同的是，迭代器由于返回的 self 本身是迭代器，所以，<code>iter()</code> 方法并没有报错</li>\n</ul>\n<h3 id=\"迭代器调用-next-方法\"><a href=\"#迭代器调用-next-方法\" class=\"headerlink\" title=\"迭代器调用 __next__()方法\"></a>迭代器调用 <code>__next__()</code>方法</h3><figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestIterator</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__iter__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__next__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;这是迭代器的 __next__() 方法&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    iterator = TestIterator()</span><br><span class=\"line\">    iterator.__next__()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/iterator/8.png\"></p>\n<p>同理，<code>__next__()</code> 方法也有内置方法 <code>next()</code> 方法作为快速调用</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestIterator</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__iter__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__next__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;这是迭代器的 __next__() 方法&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    iterator = TestIterator()</span><br><span class=\"line\">    <span class=\"built_in\">next</span>(iterator)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/iterator/9.png\"></p>\n<h3 id=\"对迭代器的-for-in-循环\"><a href=\"#对迭代器的-for-in-循环\" class=\"headerlink\" title=\"对迭代器的 for in 循环\"></a>对迭代器的 for in 循环</h3><figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestIterator</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__iter__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__next__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;这是迭代器的 __next__() 方法&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    iterator = TestIterator()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> iterator:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(i)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/iterator/10.png\"></p>\n<p>你会发现陷入了死循环</p>\n<ul>\n<li><p>原因如下：</p>\n</li>\n<li><p><code>for i in iterable</code> 内部先调用了 <code>iter(iterable)</code> 方法返回一个迭代器的对象 iterator，再循环调用 <code>next(iterator)</code> 方法，这也是为什么会陷入死循环的原因</p>\n</li>\n</ul>\n<h3 id=\"解决-for-in-死循环\"><a href=\"#解决-for-in-死循环\" class=\"headerlink\" title=\"解决 for in 死循环\"></a>解决 for in 死循环</h3><p>要想不陷入死循环，我们按照官方的定义，在 <code>__next__()</code> 方法 <code>raise</code> 一个 <code>StopIteration</code> 异常就可以</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestIterator</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__iter__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__next__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;这是迭代器的 __next__() 方法&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> StopIteration(<span class=\"string\">&quot;循环结束&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    iterator = TestIterator()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> iterator:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(i)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/iterator/11.png\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>综上所诉，for in 循环后的对象一定要是可迭代对象，在 python 中，可迭代对象分为 纯可迭代对象和迭代器。所以，要想 for in 循环不报错，那么可迭代对象的 <code>__iter__()</code> 方法一定返回的是一个迭代器，而迭代器的 <code>__iter__()</code> 方法返回对的绝对多数情况是它本身 self，且 <code>__next__()</code> 配合 <code>raise StopIteration</code> 可以终止循环</p>\n<h2 id=\"自定义-range-方法\"><a href=\"#自定义-range-方法\" class=\"headerlink\" title=\"自定义 range() 方法\"></a>自定义 <code>range()</code> 方法</h2><p>以下是基于可迭代对象和迭代器写的一个新的简单的 <code>range()</code> 方法</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RangeIterator</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, number: <span class=\"built_in\">int</span></span>):</span><br><span class=\"line\">        self.number = number</span><br><span class=\"line\">        self.__count = -<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__iter__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__next__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.__count &lt; self.number - <span class=\"number\">1</span>:</span><br><span class=\"line\">            self.__count += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.__count</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> StopIteration</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NewRange</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, number: <span class=\"built_in\">int</span></span>):</span><br><span class=\"line\">        self.number = number</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__iter__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RangeIterator(self.number)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> NewRange(<span class=\"number\">0</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(i)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;*&quot;</span>*<span class=\"number\">30</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> NewRange(<span class=\"number\">5</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(j)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/iterator/12.png\"></p>\n<h2 id=\"迭代器实现-range\"><a href=\"#迭代器实现-range\" class=\"headerlink\" title=\"迭代器实现 range()\"></a>迭代器实现 <code>range()</code></h2><p>同理，因为迭代器本身也是可迭代对象，那么只用迭代器类也可以实现 <code>range()</code> 循环</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NewRange</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, number: <span class=\"built_in\">int</span></span>):</span><br><span class=\"line\">        self.number = number</span><br><span class=\"line\">        self.__count = -<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__iter__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__next__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.__count &lt; self.number - <span class=\"number\">1</span>:</span><br><span class=\"line\">            self.__count += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> self.__count</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> StopIteration</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> NewRange(<span class=\"number\">0</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(i)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;*&quot;</span>*<span class=\"number\">30</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> NewRange(<span class=\"number\">5</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(j)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/iterator/13.png\"></p>\n<h2 id=\"可迭代对象实现单向链表\"><a href=\"#可迭代对象实现单向链表\" class=\"headerlink\" title=\"可迭代对象实现单向链表\"></a>可迭代对象实现单向链表</h2><p>以下是基于迭代器实现单向链表</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NodeIterator</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, node_obj</span>):</span><br><span class=\"line\">        self.node_obj = node_obj</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__iter__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__next__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.node_obj:</span><br><span class=\"line\">            name = self.node_obj.name</span><br><span class=\"line\">            self.node_obj = self.node_obj.<span class=\"built_in\">next</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> name</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> StopIteration</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NodeIterable</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, name</span>):</span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.<span class=\"built_in\">next</span> = <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__iter__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> NodeIterator(self)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    node1 = NodeIterable(<span class=\"string\">&quot;first&quot;</span>)</span><br><span class=\"line\">    node2 = NodeIterable(<span class=\"string\">&quot;second&quot;</span>)</span><br><span class=\"line\">    node3 = NodeIterable(<span class=\"string\">&quot;third&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    node1.<span class=\"built_in\">next</span> = node2</span><br><span class=\"line\">    node2.<span class=\"built_in\">next</span> = node3</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> node <span class=\"keyword\">in</span> node1:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(node)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/iterator/14.png\"></p>\n<h2 id=\"迭代器实现单向链表\"><a href=\"#迭代器实现单向链表\" class=\"headerlink\" title=\"迭代器实现单向链表\"></a>迭代器实现单向链表</h2><figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, name</span>):</span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.<span class=\"built_in\">next</span> = <span class=\"literal\">None</span></span><br><span class=\"line\">        self.obj = self</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__iter__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__next__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.obj:</span><br><span class=\"line\">            nodes = self.obj.name</span><br><span class=\"line\">            self.obj = self.obj.<span class=\"built_in\">next</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> nodes</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> StopIteration</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    node1 = Node(<span class=\"string\">&quot;first&quot;</span>)</span><br><span class=\"line\">    node2 = Node(<span class=\"string\">&quot;second&quot;</span>)</span><br><span class=\"line\">    node3 = Node(<span class=\"string\">&quot;third&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    node1.<span class=\"built_in\">next</span> = node2</span><br><span class=\"line\">    node2.<span class=\"built_in\">next</span> = node3</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> node <span class=\"keyword\">in</span> node1:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(node)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/iterator/15.png\"></p>\n<ul>\n<li>next 指针指向的始终是下一个对象，如果判定 <code>self.obj.next</code> 指向的下一个对象是 None，即没有下一个对象，那么遍历整个链表成功</li>\n</ul>\n<h2 id=\"通过迭代器解决环链问题\"><a href=\"#通过迭代器解决环链问题\" class=\"headerlink\" title=\"通过迭代器解决环链问题\"></a>通过迭代器解决环链问题</h2><p>class Node:</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, name</span>):</span><br><span class=\"line\">    self.name = name</span><br><span class=\"line\">    self.<span class=\"built_in\">next</span> = <span class=\"literal\">None</span></span><br><span class=\"line\">    self.flag = <span class=\"number\">0</span>  <span class=\"comment\"># 设置一个标志</span></span><br><span class=\"line\">    self.fast = self  <span class=\"comment\"># 设置两个从相同节点出发速度不同的指针</span></span><br><span class=\"line\">    self.slow = self</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">__iter__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">__next__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">    <span class=\"comment\"># 如果遍历多次出现了快慢指针一样,说明必然有环</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.flag == <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> StopIteration</span><br><span class=\"line\">    <span class=\"comment\"># 如果标志位为2直接跳出循环</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.flag == <span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> StopIteration</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        self.fast = self.fast.<span class=\"built_in\">next</span>.<span class=\"built_in\">next</span></span><br><span class=\"line\">        self.slow = self.slow.<span class=\"built_in\">next</span></span><br><span class=\"line\">    <span class=\"comment\"># 如果有报错,说明必然无环,设置标志位为2</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> AttributeError:</span><br><span class=\"line\">        self.flag = <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.fast == self.slow:</span><br><span class=\"line\">        self.flag = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    head = Node(<span class=\"string\">&quot;first&quot;</span>)</span><br><span class=\"line\">    node2 = Node(<span class=\"string\">&quot;second&quot;</span>)</span><br><span class=\"line\">    node3 = Node(<span class=\"string\">&quot;third&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 设置无环链表</span></span><br><span class=\"line\">    head.<span class=\"built_in\">next</span> = node2</span><br><span class=\"line\">    node2.<span class=\"built_in\">next</span> = node3</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> node <span class=\"keyword\">in</span> head:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node <span class=\"keyword\">is</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;该链表是环链&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> node <span class=\"keyword\">is</span> <span class=\"literal\">False</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;该链表不是环链&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    head = Node(<span class=\"string\">&quot;first&quot;</span>)</span><br><span class=\"line\">    node2 = Node(<span class=\"string\">&quot;second&quot;</span>)</span><br><span class=\"line\">    node3 = Node(<span class=\"string\">&quot;third&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 设置一个有环链表</span></span><br><span class=\"line\">    head.<span class=\"built_in\">next</span> = node2</span><br><span class=\"line\">    node2.<span class=\"built_in\">next</span> = node3</span><br><span class=\"line\">    node3.<span class=\"built_in\">next</span> = head</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> node <span class=\"keyword\">in</span> head:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node <span class=\"keyword\">is</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;该链表是环链&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> node <span class=\"keyword\">is</span> <span class=\"literal\">False</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;该链表不是环链&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/iterator/16.png\"></p>\n<h1 id=\"生成器（generator）\"><a href=\"#生成器（generator）\" class=\"headerlink\" title=\"生成器（generator）\"></a>生成器（generator）</h1><p>如果一个方法中拥有关键字 <code>yield</code>，不管这个 <code>yield</code> 关键字位置在哪，那么这个方法就被称为生成器。因为方法加载需要在方法区，方法区识别有 <code>yield</code> 后，会在堆中创建一个生成器 （generator）</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">generator</span>():</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">type</span>(generator()))</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/iterator/17.png\"></p>\n<h2 id=\"yield-关键字\"><a href=\"#yield-关键字\" class=\"headerlink\" title=\"yield 关键字\"></a><code>yield</code> 关键字</h2><p><code>yield</code> 关键字的作用是，当调用方法时，会创建一个生成器对象，并不会运行方法。如果调用 <code>next()</code> 方法时，会先执行方法直到碰到一个 <code>yield</code>，并将一个 <code>yield</code> 返回值作为第一返回值返回，如果再次调用 <code>next()</code> 方法时，依旧会执行接下的代码直到碰到下一个 <code>yield</code>，并返回值，如果没有碰到 <code>yield</code>，则会抛出 <code>StopIteration</code> 异常</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">generator</span>(<span class=\"params\">number</span>):</span><br><span class=\"line\">    <span class=\"keyword\">while</span> number &lt; <span class=\"number\">3</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;begin&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> number</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;end&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>()</span><br><span class=\"line\">        number += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    generator = generator(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">next</span>(generator))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">next</span>(generator))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">next</span>(generator))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">next</span>(generator))</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/iterator/18.png\"></p>\n<h2 id=\"生成器与迭代器关系\"><a href=\"#生成器与迭代器关系\" class=\"headerlink\" title=\"生成器与迭代器关系\"></a>生成器与迭代器关系</h2><p>生成器是一个特殊的迭代器，可以被 for in 循环遍历</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">generator</span>(<span class=\"params\">number</span>):</span><br><span class=\"line\">    <span class=\"keyword\">while</span> number &lt; <span class=\"number\">3</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;begin&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> number</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;end&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>()</span><br><span class=\"line\">        number += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    generator = generator(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> generator:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(i)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/iterator/19.png\"></p>\n<ul>\n<li>该 for in 循环相当于每次都对 <code>generator</code> 进行一次 <code>next()</code> 方法操作，只是最后一步不会抛出异常</li>\n</ul>\n<h2 id=\"yield-语句返回值\"><a href=\"#yield-语句返回值\" class=\"headerlink\" title=\"yield 语句返回值\"></a><code>yield</code> 语句返回值</h2><p><code>yield</code> 语句本身也有值，但是默认为 None</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">generator</span>(<span class=\"params\">number</span>):</span><br><span class=\"line\">    <span class=\"keyword\">while</span> number &lt; <span class=\"number\">3</span>:</span><br><span class=\"line\">        a = <span class=\"keyword\">yield</span> number</span><br><span class=\"line\">        number += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    generator = generator(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> generator:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(i)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/iterator/20.png\"></p>\n<ul>\n<li>你会发现，a 的值永远是 None</li>\n</ul>\n<h2 id=\"send-方法\"><a href=\"#send-方法\" class=\"headerlink\" title=\"send() 方法\"></a><code>send()</code> 方法</h2><p>通过 <code>send()</code> 方法修改 <code>yield</code> 返回值</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">generator</span>(<span class=\"params\">number</span>):</span><br><span class=\"line\">    <span class=\"keyword\">while</span> number &lt; <span class=\"number\">3</span>:</span><br><span class=\"line\">        a = <span class=\"keyword\">yield</span> number</span><br><span class=\"line\">        number += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;a的值是<span class=\"subst\">&#123;a&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    generator = generator(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">next</span>(generator))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(generator.send(<span class=\"number\">3</span>))</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/iterator/21.png\"></p>\n<h2 id=\"send-方法本质\"><a href=\"#send-方法本质\" class=\"headerlink\" title=\"send() 方法本质\"></a><code>send()</code> 方法本质</h2><p> <code>send()</code> 方法本质就是 <code>next()</code> 方法，不过是让 yield 语句有值罢了。所以 <code>next()</code> 语句相当于 <code>send(None)</code>，但是不能初始时给生成器传值</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">generator</span>(<span class=\"params\">number</span>):</span><br><span class=\"line\">    <span class=\"keyword\">while</span> number &lt; <span class=\"number\">3</span>:</span><br><span class=\"line\">        a = <span class=\"keyword\">yield</span> number</span><br><span class=\"line\">        number += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;a的值是<span class=\"subst\">&#123;a&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    generator = generator(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(generator.send(<span class=\"number\">3</span>))</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/iterator/22.png\"></p>\n<h2 id=\"生成器完定义range-方法\"><a href=\"#生成器完定义range-方法\" class=\"headerlink\" title=\"生成器完定义range() 方法\"></a>生成器完定义<code>range()</code> 方法</h2><figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">range_generator</span>(<span class=\"params\">number</span>):</span><br><span class=\"line\">    count = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> count &lt; number:</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> count</span><br><span class=\"line\">        count += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range_generator(<span class=\"number\">5</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(i)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/iterator/23.png\"></p>\n<h2 id=\"生成器完成单向链表\"><a href=\"#生成器完成单向链表\" class=\"headerlink\" title=\"生成器完成单向链表\"></a>生成器完成单向链表</h2><figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, name</span>):</span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.<span class=\"built_in\">next</span> = <span class=\"literal\">None</span></span><br><span class=\"line\">        self.obj = self</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__iter__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">while</span> self.obj:</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> self.obj.name</span><br><span class=\"line\">            self.obj = self.obj.<span class=\"built_in\">next</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    node1 = Node(<span class=\"string\">&quot;first&quot;</span>)</span><br><span class=\"line\">    node2 = Node(<span class=\"string\">&quot;second&quot;</span>)</span><br><span class=\"line\">    node3 = Node(<span class=\"string\">&quot;third&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    node1.<span class=\"built_in\">next</span> = node2</span><br><span class=\"line\">    node2.<span class=\"built_in\">next</span> = node3</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> node1:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(i)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/iterator/24.png\"></p>\n<h2 id=\"利用生成器判定是否是环链表\"><a href=\"#利用生成器判定是否是环链表\" class=\"headerlink\" title=\"利用生成器判定是否是环链表\"></a>利用生成器判定是否是环链表</h2><figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, name</span>):</span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.<span class=\"built_in\">next</span> = <span class=\"literal\">None</span></span><br><span class=\"line\">        self.flag = <span class=\"number\">0</span></span><br><span class=\"line\">        self.fast = self</span><br><span class=\"line\">        self.slow = self</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__iter__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        loop = <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> loop:</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> self.flag</span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.flag == <span class=\"number\">1</span>:</span><br><span class=\"line\">                loop = <span class=\"literal\">False</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> self.flag == <span class=\"number\">2</span>:</span><br><span class=\"line\">                loop = <span class=\"literal\">False</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                self.fast = self.fast.<span class=\"built_in\">next</span>.<span class=\"built_in\">next</span></span><br><span class=\"line\">                self.slow = self.slow.<span class=\"built_in\">next</span></span><br><span class=\"line\">            <span class=\"keyword\">except</span> AttributeError:</span><br><span class=\"line\">                self.flag = <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> self.fast == self.slow:</span><br><span class=\"line\">                self.flag = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    node1 = Node(<span class=\"string\">&quot;first&quot;</span>)</span><br><span class=\"line\">    node2 = Node(<span class=\"string\">&quot;second&quot;</span>)</span><br><span class=\"line\">    node3 = Node(<span class=\"string\">&quot;third&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    node1.<span class=\"built_in\">next</span> = node2</span><br><span class=\"line\">    node2.<span class=\"built_in\">next</span> = node3</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> node1:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">pass</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> i == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;该链表是环链表&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;该链表不是环链表&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    node1 = Node(<span class=\"string\">&quot;first&quot;</span>)</span><br><span class=\"line\">    node2 = Node(<span class=\"string\">&quot;second&quot;</span>)</span><br><span class=\"line\">    node3 = Node(<span class=\"string\">&quot;third&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    node1.<span class=\"built_in\">next</span> = node2</span><br><span class=\"line\">    node2.<span class=\"built_in\">next</span> = node3</span><br><span class=\"line\">    node3.<span class=\"built_in\">next</span> = node1</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> node1:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">pass</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> i == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;该链表是环链表&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;该链表不是环链表&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/iterator/25.png\"></p>\n","categories":["python"],"tags":["python","迭代器和生成器"]},{"title":"正交表工具使用方法","url":"/2022/12/05/%E6%B5%8B%E8%AF%95/%E6%AD%A3%E4%BA%A4%E8%A1%A8%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","content":"<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><ul>\n<li><a href=\"https://blog.csdn.net/qq_54444533/article/details/124828947\">https://blog.csdn.net/qq_54444533/article/details/124828947</a></li>\n</ul>\n<h1 id=\"官方网站\"><a href=\"#官方网站\" class=\"headerlink\" title=\"官方网站\"></a>官方网站</h1><ul>\n<li><a href=\"https://www.satisfice.com/download/allpairs\">https://www.satisfice.com/download/allpairs</a></li>\n</ul>\n<span id=\"more\"></span>\n\n<h1 id=\"使用步骤\"><a href=\"#使用步骤\" class=\"headerlink\" title=\"使用步骤\"></a>使用步骤</h1><ol>\n<li><p>下载后解压</p>\n<p> <img src=\"/./images/test/Orthogonal-tool/1.png\"></p>\n</li>\n<li><p>将该目录添加至环境变量 PATH</p>\n<p> <img src=\"/./images/test/Orthogonal-tool/2.png\"></p>\n<ul>\n<li>输入 <code>allpairs</code> 命令显示以上则安装成功</li>\n</ul>\n</li>\n<li><p>使用方法</p>\n<ol>\n<li><p>第一步</p>\n<p> 对需要正交表的条件项目依次填入 csv 中，格式如下</p>\n<p> <img src=\"/./images/test/Orthogonal-tool/3.png\"></p>\n</li>\n<li><p>第二步</p>\n<p> 复制全部内容到 txt 文档</p>\n<p> <img src=\"/./images/test/Orthogonal-tool/4.png\"></p>\n<p> 注意不要在意 txt 文档格式混乱，allpairs 会自动识别。并且最后一行不能有换行符。否则会报错</p>\n<p> <img src=\"/./images/test/Orthogonal-tool/5.png\"></p>\n</li>\n<li><p>第三步</p>\n<p> 用如下命令</p>\n<p> <code>allpiars 测试数据.txt &gt; 你需要生成的testcase.xlsx 表格中</code></p>\n<p> <img src=\"/./images/test/Orthogonal-tool/6.png\"></p>\n</li>\n<li><p>最后查看结果</p>\n<p> <img src=\"/./images/test/Orthogonal-tool/7.png\"></p>\n<p> 注意点</p>\n<ul>\n<li><p>表格下方是所有笛卡尔积结果。上方才是需要测试的数据</p>\n</li>\n<li><p>其中前缀为~的项表示无关数据，可以任意取值</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n","categories":["测试","测试理论"],"tags":["测试工具"]},{"title":"python 驻留机制","url":"/2022/12/08/python/python%20%E9%A9%BB%E7%95%99%E6%9C%BA%E5%88%B6/","content":"<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><p><a href=\"http://t.zoukankan.com/hiyong-p-14999364.html\">http://t.zoukankan.com/hiyong-p-14999364.html</a></p>\n<h1 id=\"引入原因\"><a href=\"#引入原因\" class=\"headerlink\" title=\"引入原因\"></a>引入原因</h1><p>在 Python 内存机制中，为了避免重复开辟新的内存空间造成的性能浪费，引入了一个机制叫驻留机制</p>\n<ul>\n<li>内存机制有关参考 <a href=\"/2022/12/10/python/python%20%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/\" title=\"python 内存详解\">python 内存详解</a></li>\n</ul>\n<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><p>新建的变量中，仅保存一份副本，多个对象共享该副本，驻留只针对不可变数据类型，比如字符串，布尔值，数字，元组。在这些固定数据类型处理中，使用驻留可以有效节省时间和空间，当然在驻留池中创建或者插入新的内容会消耗一定的时间。</p>\n<h1 id=\"发生环境\"><a href=\"#发生环境\" class=\"headerlink\" title=\"发生环境\"></a>发生环境</h1><ol>\n<li>交互模式下会发生驻留机制</li>\n<li>pycharm 和 python python.py 文件模式运行解释器进行了优化，返回结果并不为发生了驻留机制</li>\n</ol>\n<h1 id=\"在交互模式下驻留机制的几种情况\"><a href=\"#在交互模式下驻留机制的几种情况\" class=\"headerlink\" title=\"在交互模式下驻留机制的几种情况\"></a>在交互模式下驻留机制的几种情况</h1><h2 id=\"字符串长度为0或1时\"><a href=\"#字符串长度为0或1时\" class=\"headerlink\" title=\"字符串长度为0或1时\"></a>字符串长度为0或1时</h2><ul>\n<li><p>交互模式下</p>\n<p><img src=\"/./images/python/intern/1.png\"></p>\n</li>\n<li><p>pycharm模式下</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_intern</span>():</span><br><span class=\"line\">    a = <span class=\"string\">&quot;$&quot;</span></span><br><span class=\"line\">    b = <span class=\"string\">&quot;$&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a <span class=\"keyword\">is</span> b)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_intern()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/intern/2.png\"></p>\n</li>\n<li><p>命令行模式下</p>\n<p><img src=\"/./images/python/intern/3.png\"></p>\n</li>\n</ul>\n<h2 id=\"符合标识符的字符串-字母，数字，下划线\"><a href=\"#符合标识符的字符串-字母，数字，下划线\" class=\"headerlink\" title=\"符合标识符的字符串(字母，数字，下划线)\"></a>符合标识符的字符串(字母，数字，下划线)</h2><p>这意味着不符合标识的字符串不会驻留</p>\n<ul>\n<li><p>交互模式下</p>\n<p><img src=\"/./images/python/intern/4.png\"></p>\n</li>\n<li><p>pycharm 模式下</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_intern</span>():</span><br><span class=\"line\">    a = <span class=\"string\">&quot;_hello1&quot;</span></span><br><span class=\"line\">    b = <span class=\"string\">&quot;_hello1&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a <span class=\"keyword\">is</span> b)</span><br><span class=\"line\">    a = <span class=\"string\">&quot;$_hello1#&quot;</span></span><br><span class=\"line\">    b = <span class=\"string\">&quot;$_hello1#&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a <span class=\"keyword\">is</span> b)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_intern()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/intern/5.png\"></p>\n</li>\n<li><p>命令行模式下</p>\n<p><img src=\"/./images/python/intern/6.png\"></p>\n</li>\n</ul>\n<h2 id=\"编译时会发生驻留\"><a href=\"#编译时会发生驻留\" class=\"headerlink\" title=\"编译时会发生驻留\"></a>编译时会发生驻留</h2><p>这意味着运行不会发生驻留</p>\n<ul>\n<li><p>python 优化了类似 str1+str2，str1*int 等生成的字符串默认驻留。前提是字面量赋值。</p>\n</li>\n<li><p>交互模式下</p>\n<p><img src=\"/./images/python/intern/7.png\"></p>\n</li>\n<li><p>pycharm 模式下</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_intern</span>():</span><br><span class=\"line\">    a = <span class=\"string\">&quot;hello&quot;</span></span><br><span class=\"line\">    b = <span class=\"string\">&quot;HELLO&quot;</span></span><br><span class=\"line\">    c = b.lower()</span><br><span class=\"line\">    d = <span class=\"string\">&quot;hel&quot;</span> + <span class=\"string\">&quot;lo&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;c:<span class=\"subst\">&#123;c&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;d:<span class=\"subst\">&#123;d&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;-----------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a <span class=\"keyword\">is</span> c)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a <span class=\"keyword\">is</span> d)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_intern()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/intern/8.png\"></p>\n</li>\n<li><p>命令行模式下</p>\n<p><img src=\"/./images/python/intern/9.png\"></p>\n<p>值得注意的是这次 pycharm 和命令行不再对这种情况进行优化</p>\n<p>如果换成是变量相加的话驻留机制不会产生</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_intern</span>():</span><br><span class=\"line\">    a = <span class=\"string\">&quot;hello&quot;</span></span><br><span class=\"line\">    b = <span class=\"string\">&quot;he&quot;</span></span><br><span class=\"line\">    c = <span class=\"string\">&quot;llo&quot;</span></span><br><span class=\"line\">    d = b + c</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;a:<span class=\"subst\">&#123;a&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;d:<span class=\"subst\">&#123;d&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;-----------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a <span class=\"keyword\">is</span> d)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_intern()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/intern/10.png\"></p>\n</li>\n</ul>\n<h2 id=\"数字类型区间位于-5-256-时会进行驻留\"><a href=\"#数字类型区间位于-5-256-时会进行驻留\" class=\"headerlink\" title=\"数字类型区间位于 -5~256 时会进行驻留\"></a>数字类型区间位于 -5~256 时会进行驻留</h2><p>这意味着在此区间外将不会驻留</p>\n<ul>\n<li><p>交互模式</p>\n<p><img src=\"/./images/python/intern/11.png\"></p>\n</li>\n<li><p>pycharm 模式下</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_intern</span>():</span><br><span class=\"line\">    a = -<span class=\"number\">5</span></span><br><span class=\"line\">    b = -<span class=\"number\">5</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a <span class=\"keyword\">is</span> b)</span><br><span class=\"line\">    a = -<span class=\"number\">6</span></span><br><span class=\"line\">    b = -<span class=\"number\">6</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a <span class=\"keyword\">is</span> b)</span><br><span class=\"line\">    a = <span class=\"number\">256</span></span><br><span class=\"line\">    b = <span class=\"number\">256</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a <span class=\"keyword\">is</span> b)</span><br><span class=\"line\">    a = <span class=\"number\">257</span></span><br><span class=\"line\">    b = <span class=\"number\">257</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a <span class=\"keyword\">is</span> b)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_intern()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/intern/12.png\"></p>\n</li>\n<li><p>命令行模式</p>\n<p><img src=\"/./images/python/intern/13.png\"></p>\n</li>\n</ul>\n<h2 id=\"元组类型的驻留\"><a href=\"#元组类型的驻留\" class=\"headerlink\" title=\"元组类型的驻留\"></a>元组类型的驻留</h2><p>元组类型当元组为空，或者元组中只有一个元素且元素范围满足上述字符串和数字驻留规则会驻留</p>\n<p>由于元组不可变不存在增加元素，则不存在 运行时不驻留的特点</p>\n<ul>\n<li><p>交互模式下</p>\n<p><img src=\"/./images/python/intern/14.png\"></p>\n</li>\n<li><p>pychram 模式下</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_intern</span>():</span><br><span class=\"line\">    a = ()</span><br><span class=\"line\">    b = ()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a <span class=\"keyword\">is</span> b)</span><br><span class=\"line\">    a = (-<span class=\"number\">5</span>,)</span><br><span class=\"line\">    b = (-<span class=\"number\">5</span>,)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a <span class=\"keyword\">is</span> b)</span><br><span class=\"line\">    a = (<span class=\"number\">256</span>,)</span><br><span class=\"line\">    b = (<span class=\"number\">256</span>,)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a <span class=\"keyword\">is</span> b)</span><br><span class=\"line\">    a = (-<span class=\"number\">6</span>,)</span><br><span class=\"line\">    b = (-<span class=\"number\">6</span>,)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a <span class=\"keyword\">is</span> b)</span><br><span class=\"line\">    a = (<span class=\"number\">257</span>,)</span><br><span class=\"line\">    b = (<span class=\"number\">257</span>,)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a <span class=\"keyword\">is</span> b)</span><br><span class=\"line\">    a = (<span class=\"string\">&quot;%&quot;</span>,)</span><br><span class=\"line\">    b = (<span class=\"string\">&quot;%&quot;</span>,)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a <span class=\"keyword\">is</span> b)</span><br><span class=\"line\">    a = (<span class=\"string\">&quot;_hello&quot;</span>,)</span><br><span class=\"line\">    b = (<span class=\"string\">&quot;_hello&quot;</span>,)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a <span class=\"keyword\">is</span> b)</span><br><span class=\"line\">    a = (<span class=\"string\">&quot;#hello&quot;</span>,)</span><br><span class=\"line\">    b = (<span class=\"string\">&quot;#hello&quot;</span>,)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a <span class=\"keyword\">is</span> b)</span><br><span class=\"line\">    a = ([])</span><br><span class=\"line\">    b = ([])</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a <span class=\"keyword\">is</span> b)</span><br><span class=\"line\">    a = (<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">    b = (<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a <span class=\"keyword\">is</span> b)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_intern()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/intern/15.png\"></p>\n</li>\n<li><p>命令行模式下</p>\n<p><img src=\"/./images/python/intern/16.png\"></p>\n</li>\n</ul>\n<h2 id=\"强制驻留\"><a href=\"#强制驻留\" class=\"headerlink\" title=\"强制驻留\"></a>强制驻留</h2><ul>\n<li><p>使用 sys 模块 的 <code>intern()</code> 方法实现强制驻留</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_intern</span>():</span><br><span class=\"line\">    a = <span class=\"string\">&quot;#hello&quot;</span></span><br><span class=\"line\">    b = <span class=\"string\">&quot;&quot;</span>.join(<span class=\"string\">&quot;#hello&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a <span class=\"keyword\">is</span> b)</span><br><span class=\"line\">    a = sys.intern(b)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a <span class=\"keyword\">is</span> b)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_intern()</span><br></pre></td></tr></table></figure>\n\n<p>返回</p>\n<p><img src=\"/./images/python/intern/17.png\"></p>\n</li>\n</ul>\n<h1 id=\"注意情况\"><a href=\"#注意情况\" class=\"headerlink\" title=\"注意情况\"></a>注意情况</h1><p>避免频繁的创建和销毁，提升效率和节约内存，因此拼接和修改字符串是会比较影响性能的。因为是不可变的，所以字符串的操作都不是 replace，而是新建对象，这也是为什么拼接多字符串的时候不建议用+而用 join()，join() 是先计算出所有字符串的长度，然后再拷贝，只 new 一次对象。需要注意的是，并不是所有的字符串都会采用 intern机制，当且仅当只包含下划线、数字、字母的字符串才会被 intern</p>\n","categories":["python"],"tags":["python","驻留机制"]},{"title":"软件开发模型（SDLC)","url":"/2022/12/05/%E6%B5%8B%E8%AF%95/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B%EF%BC%88SDLC)/","content":"<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><ul>\n<li><a href=\"https://cloud.tencent.com/developer/article/1724043\">https://cloud.tencent.com/developer/article/1724043</a></li>\n</ul>\n<h1 id=\"常用的开发模型\"><a href=\"#常用的开发模型\" class=\"headerlink\" title=\"常用的开发模型\"></a>常用的开发模型</h1><ol>\n<li>瀑布模型</li>\n<li>V型</li>\n<li>迭代和增量模型</li>\n<li>螺旋模型</li>\n<li>大爆炸模型</li>\n<li>敏捷模型</li>\n<li>原型模型</li>\n<li>DevOps</li>\n</ol>\n<span id=\"more\"></span>\n\n<h2 id=\"瀑布模型\"><a href=\"#瀑布模型\" class=\"headerlink\" title=\"瀑布模型\"></a>瀑布模型</h2><p><img src=\"/./images/test/SDLC-modules/1.png\"></p>\n<h3 id=\"瀑布模型的特点\"><a href=\"#瀑布模型的特点\" class=\"headerlink\" title=\"瀑布模型的特点\"></a>瀑布模型的特点</h3><p>瀑布模型（Waterfall） 是最简单的软件开发历史上第一个 SDLC 模型。在瀑布模型中，开发过程是线性的。任务和阶段按严格顺序一个接一个地完成。进度平稳地向下流动，就像瀑布上的水一样。</p>\n<h3 id=\"瀑布模型的缺点\"><a href=\"#瀑布模型的缺点\" class=\"headerlink\" title=\"瀑布模型的缺点\"></a>瀑布模型的缺点</h3><p>瀑布模型的主要缺点是不灵活。瀑布易于理解且易于管理。但是过早的延迟会拖延整个项目的时间表。由于一旦完成阶段，几乎没有修改的余地，因此只有进入维护阶段才能解决问题。如果需要灵活性，或者项目是长期的且正在进行的，则此模型不能很好地工作</p>\n<h2 id=\"V-型\"><a href=\"#V-型\" class=\"headerlink\" title=\"V 型\"></a>V 型</h2><p><img src=\"/./images/test/SDLC-modules/2.png\"></p>\n<p>V 形模型也称为 V 模型或验证与验证模型，是瀑布方法的扩展。使用 V 模型时，进度并不会直线移动，而是在实施和开发后逐渐上升。</p>\n<p>对于 V 型 SDLC 项目，早期测试介入是与 瀑布模型相比的主要区别。每个开发阶段都有一个并行测试阶段，这有助于在继续下一步之前验证和验证每个步骤。</p>\n<h2 id=\"迭代和增量模型\"><a href=\"#迭代和增量模型\" class=\"headerlink\" title=\"迭代和增量模型\"></a>迭代和增量模型</h2><p><img src=\"/./images/test/SDLC-modules/3.png\"></p>\n<p>迭代和增量 SDLC 模型将迭代设计和工作流与增量构建模型结合在一起。在这种情况下，团队将按周期开发产品，并以渐进方式构建小零件。</p>\n<p>开发过程从简单实施一组严格限制的小型产品需求开始。然后对该产品进行增强，并使其本身成为更完整的版本，直到完成并准备好进行部署为止。每次迭代都可能包含设计更新和新功能。</p>\n<p>迭代和增量模型的一个有价值的特点是可以在不知道所有需求的情况下开始开发。该模型包含其他 SDLC 模型的步骤-需求收集，设计，实施和测试，但要经过多次构建。开发团队可以利用先前构建中取得的成就来改善下一构建。</p>\n<p>迭代和增量 SDLC 模型可能看起来像一组微型瀑布模型或微型 V 形模型。</p>\n<h2 id=\"螺旋模型\"><a href=\"#螺旋模型\" class=\"headerlink\" title=\"螺旋模型\"></a>螺旋模型</h2><p><img src=\"/./images/test/SDLC-modules/4.png\"></p>\n<p>螺旋 SDLC 模型是原型方法和瀑布方法的结合。螺旋模型被认为是最灵活的 SDLC 方法之一。它从迭代模型及其重复中获得启发。该项目以“螺旋式”的方式反复经历四个阶段，直到完成为止，从而可以进行多轮改进。</p>\n<ol>\n<li>规划</li>\n<li>风险分析</li>\n<li>工程</li>\n<li>评价</li>\n</ol>\n<p>螺旋模型主要用于大型项目，它允许构建高度定制的产品，并且用户反馈可以在项目的早期就被纳入。但可能有项目会形成永无止境的螺旋式发展的风险。</p>\n<h2 id=\"大爆炸模型\"><a href=\"#大爆炸模型\" class=\"headerlink\" title=\"大爆炸模型\"></a>大爆炸模型</h2><p><img src=\"/./images/test/SDLC-modules/5.png\"></p>\n<p>Big Bang 模型通常不遵循任何特定过程或说明。开发从当前可用的资源和工作开始，几乎没有计划或根本没有计划。结果，客户得到的产品甚至可能无法满足要求。功能是动态实现的。</p>\n<p>Big Bang SDLC 模型的主要思想是将所有可用资源分配给产品本身的开发，主要是在编码方面，而不用担心满足计划。这是仅用于一两个软件工程师的小型项目的 SDLC 方法之一。</p>\n<h2 id=\"敏捷模型\"><a href=\"#敏捷模型\" class=\"headerlink\" title=\"敏捷模型\"></a>敏捷模型</h2><p><img src=\"/./images/test/SDLC-modules/6.png\"></p>\n<p>敏捷（Agile） SDLC 模型是迭代和增量方法的组合，致力于通过早期交付工作软件来适应灵活的需求并满足用户和客户的需求。敏捷项目中的需求和解决方案可能会在开发过程中发展。</p>\n<p>通过敏捷开发，该产品被分为小的增量构建，并以迭代方式交付。将所有任务划分为较小的时间范围，以便为每个版本准备工作功能。最终产品版本包含所有必需的功能。敏捷仍然是技术行业中使用最广泛的SDLC。</p>\n<h2 id=\"DevOps模型\"><a href=\"#DevOps模型\" class=\"headerlink\" title=\"DevOps模型\"></a>DevOps模型</h2><p><img src=\"/./images/test/SDLC-modules/7.png\"></p>\n<p>DevOps是新手模型。DevOps来自两个趋势：敏捷方法和精益方法的应用。通常，DevOps 是通过自动化基础架构和工作流程并持续跟踪应用程序性能来执行的。DevOps方法使您可以增加部署频率，编写代码并缩短部署新代码所需的时间。</p>\n<p>DevOps是工具，实践和方法的组合，鼓励开发人员，运维人员和 QA人员共同努力，以进行持续的开发，测试和部署活动，以加速创新并交付更高质量和更可靠的软件产品和功能。</p>\n","categories":["测试","测试理论"],"tags":["开发模型"]},{"title":"测试用例设计方法","url":"/2022/12/05/%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/","content":"<h1 id=\"测试用例的分类\"><a href=\"#测试用例的分类\" class=\"headerlink\" title=\"测试用例的分类\"></a>测试用例的分类</h1><p>分为黑盒测试和白盒测试两种</p>\n<h2 id=\"黑盒测试\"><a href=\"#黑盒测试\" class=\"headerlink\" title=\"黑盒测试\"></a>黑盒测试</h2><p><img src=\"/./images/test/Testcase-Designer/1.png\"></p>\n<h2 id=\"白盒测试\"><a href=\"#白盒测试\" class=\"headerlink\" title=\"白盒测试\"></a>白盒测试</h2><p><img src=\"/./images/test/Testcase-Designer/1.png\"></p>\n<span id=\"more\"></span>\n\n<h1 id=\"设计测试用例的方法\"><a href=\"#设计测试用例的方法\" class=\"headerlink\" title=\"设计测试用例的方法\"></a>设计测试用例的方法</h1><h2 id=\"等价类划分法（简称等价类）\"><a href=\"#等价类划分法（简称等价类）\" class=\"headerlink\" title=\"等价类划分法（简称等价类）\"></a>等价类划分法（简称等价类）</h2><h3 id=\"等价类划分法的定义\"><a href=\"#等价类划分法的定义\" class=\"headerlink\" title=\"等价类划分法的定义\"></a>等价类划分法的定义</h3><p>将输入（输出）域划分成若干个子集合中，从划分的子集合中选取代表数据进行测试，如果选取的数据测试没有问题，就认为其他数据测试的效果是等价的</p>\n<h3 id=\"等价类划分法的分类\"><a href=\"#等价类划分法的分类\" class=\"headerlink\" title=\"等价类划分法的分类\"></a>等价类划分法的分类</h3><p>有效等价类</p>\n<p>无效等价类</p>\n<h3 id=\"等价类划分原则\"><a href=\"#等价类划分原则\" class=\"headerlink\" title=\"等价类划分原则\"></a>等价类划分原则</h3><ol>\n<li>如果输入（输出）是一个取值范围或者某个值的个数时，则划分成一个有效等价类和两个无效等价类<ul>\n<li>举例<ul>\n<li>某个大厦招聘保安，年龄要求18~60周岁（包括18和60）<ul>\n<li>一个有效等价类：18~60</li>\n<li>两个无效等价类：&lt;18；&gt;60</li>\n</ul>\n</li>\n<li>并且从以上区间选取带有标志性的数据测试<ul>\n<li>如有效等价类区间里选取 18 60 50…..，无效等价类里选取 10 70 80 …..</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>如果输入（输出）是一个有限集合或者必须如何的条件，则划分成一个有效等价类和一个无效等价类<ul>\n<li>举例<ul>\n<li>一个集合：以下城市进入上海需要提供核酸检测报告（沈阳；大连；深圳；广州；合肥；六安；营口；瑞丽）<ul>\n<li>一个有效等价类：集合内；</li>\n<li>一个无效等价类：集合外（菏泽）</li>\n</ul>\n</li>\n<li>并且从以上区间选取带有标志性的数据测试<ul>\n<li>如有效等价类选取大连……，无效等价类选取 菏泽……</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>如果输入（输出）是一个布尔量，则划分成一个有效等价类和一个无效等价类<ul>\n<li>举例<ul>\n<li>某个问卷调查 App 如果性别选项选择男请转到第五题：<ul>\n<li>一个有效：男</li>\n<li>一个无效：女</li>\n</ul>\n</li>\n<li>如果性别选项选择女请转到第二题：<ul>\n<li>一个有效：女</li>\n<li>一个无效：男</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>很明显布尔类型是第二种等价类的特殊情况</li>\n</ul>\n</li>\n<li>如果输入（输出）已经划分出有效和无效等价类，针对有效等价类部分不同的取值处理方式不一样，细分成多个有效等价类和一个无效等价类<ul>\n<li>举例<ul>\n<li>某个认证考试百分制；60分及格可以获得认证证书<ul>\n<li>一个有效等价类：&gt;&#x3D;60分<ul>\n<li>细化等价类：   60<del>69分—合格；70</del>79分—中等；80<del>89分—良好；90</del>99分—优秀；100分—完美</li>\n</ul>\n</li>\n<li>一个无效等价类：&lt;60分</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>如果输入（输出）要同时满足多个条件，则划分成一个有效等价类和多个无效等价类<ul>\n<li>举例<ul>\n<li>学习系统登录密码修改：6~12位；<ul>\n<li>一个有效等价类：大小写字母与数字的组合满足所有要求</li>\n<li>多个无效等价类：少于6位；大于12位；缺少数字；缺少小写字母；缺少大写字母；含有其他字母</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>很明显从以上看出当有限集合数量过于庞大时，我们不采用第二种等价类划分法，采用当前的划分方法</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"等价类划分法使用步骤\"><a href=\"#等价类划分法使用步骤\" class=\"headerlink\" title=\"等价类划分法使用步骤\"></a>等价类划分法使用步骤</h3><ol>\n<li>分析需求<ul>\n<li>将软件需求规格说明书划分成需求子片段</li>\n<li>分析需求子片段，找出输入条件</li>\n</ul>\n</li>\n<li>分析输入条件，判定是否需要结合等价类划分原则划分等价，需要则继续</li>\n<li>为了防止测试遗漏，为划分的等价类进行编号</li>\n<li>从划分的等价类中选取代表数据进行测试，直到所有的等价类全部被覆盖</li>\n<li>将选取的数据结合测试用例写作格式完成最终测试用例的编写</li>\n</ol>\n<h3 id=\"等价类的注意事项\"><a href=\"#等价类的注意事项\" class=\"headerlink\" title=\"等价类的注意事项\"></a>等价类的注意事项</h3><ol>\n<li>一条测试用例尽量覆盖多个有效等价类；</li>\n<li>一条测试用例只覆盖一个无效等价类；</li>\n<li>这符合之前等价类设计方法的最后一条，因为实际输入要么是庞大的集合，要么是无穷的区间。总之应该以有效等价类覆盖越多越好</li>\n</ol>\n<h2 id=\"边界值\"><a href=\"#边界值\" class=\"headerlink\" title=\"边界值\"></a>边界值</h2><p>对于等价类划分法的问题是等价类划分法追求有效等价类覆盖率和数量，然而拥有无穷数的区间却使用一个等价类设计思路，这显然和宗旨相悖。基于以上问题，那么边界值设计方法可以对以上问题进行补充</p>\n<h3 id=\"边界值的三个重要的参数\"><a href=\"#边界值的三个重要的参数\" class=\"headerlink\" title=\"边界值的三个重要的参数\"></a>边界值的三个重要的参数</h3><ol>\n<li>上点：区间边界的点</li>\n<li>离点：离区间边界点最近的点<ul>\n<li>如果是开区间离点落在区间内，如果是闭区间离点落在区间外<ul>\n<li>即离点不能落在区间里</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>内点：落在区间内任意的点</li>\n</ol>\n<ul>\n<li>举例\t<ul>\n<li>某个大厦招聘保安，年龄要求[18，60]周岁<ul>\n<li>上点：18；60</li>\n<li>离点：17；61</li>\n<li>内点：30</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"边界值的选取原则\"><a href=\"#边界值的选取原则\" class=\"headerlink\" title=\"边界值的选取原则\"></a>边界值的选取原则</h3><ol>\n<li>如果输入（输出）是一个取值范围时，则以边界和边界附近的值作为测试用例数据优先选取<ul>\n<li>这就是对等价类不足的设计手段，因为等价类不能精确地锁定哪些数据需要拿来测试。</li>\n</ul>\n</li>\n<li>如果输入（输出）是一个有序的集合，则以第一个元素和最后一个元素作为测试用例<ul>\n<li>这个是基于对第二种等价类划分原则进行补充。</li>\n</ul>\n</li>\n<li>如果输入（输出）的值的个数是个取值范围，则以最大个数、最大个数+1、最小个数、最小个数-1作为测试用例数据优先选取；<ul>\n<li>这个是对以上两条内容的补充</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"边界值的使用步骤\"><a href=\"#边界值的使用步骤\" class=\"headerlink\" title=\"边界值的使用步骤\"></a>边界值的使用步骤</h3><ol>\n<li>分析需求<ul>\n<li>将软件需求规格说明书划分成需求子片段</li>\n<li>分析需求子片段，找出输入条件</li>\n</ul>\n</li>\n<li>分析输入条件，判定是否需要边界值法，如果需要结合等价类划分原则划分等价类<ul>\n<li>很明显，边界值划分法是基于等价类划分法的补充，一定要优先择取等价类划分，根据划分情况选择合适的数据</li>\n</ul>\n</li>\n<li>判断是否需要边界值和需要哪种边界值方法<ul>\n<li>分析等价类，是否需要边界值补充</li>\n<li>结合边界值数据选取原则确定边界值的选取</li>\n</ul>\n</li>\n<li>将选取的数据结合测试用例写作格式完成最终测试用例的编写</li>\n</ol>\n<h2 id=\"等价类和边界值适用范围\"><a href=\"#等价类和边界值适用范围\" class=\"headerlink\" title=\"等价类和边界值适用范围\"></a>等价类和边界值适用范围</h2><ul>\n<li>特点：不测试各种组合。测试效率比较高，效果一般。比较容易理解和易于使用的一种方法</li>\n<li>适用范围：功能测试；性能测试；界面测试（GUI测试）；兼容测试</li>\n<li>注意接口测试一般不选取等价类划分法去测试，一般功能测试可以使用等价类划分法</li>\n</ul>\n<h2 id=\"判定表\"><a href=\"#判定表\" class=\"headerlink\" title=\"判定表\"></a>判定表</h2><p>分析和表达多种输入条件下完成不同动作的一种工具，这种方法能够将具有复杂逻辑关系和多种条件组合的情况表达清晰。</p>\n<p>很显然，判定表是针对有限布尔集合或者输入是处于多个有限集合而言的。而一般功能的输出的集合一般只有一两个元素，然后由于有 switch-case 这种情况的出现，我们就可以考虑由判定表方法完成</p>\n<h3 id=\"判定表的四个重要参数\"><a href=\"#判定表的四个重要参数\" class=\"headerlink\" title=\"判定表的四个重要参数\"></a>判定表的四个重要参数</h3><ol>\n<li>条件桩：输入条件<ul>\n<li>表示输入取值的集合</li>\n</ul>\n</li>\n<li>条件项：输入条件的取值<ul>\n<li>表示具体输入的集合元素</li>\n</ul>\n</li>\n<li>动作桩：输出结果<ul>\n<li>表示输出的取值集合</li>\n</ul>\n</li>\n<li>动作项：输出结果的取值<ul>\n<li>表示具体输出的集合元素</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"判定表的使用步骤\"><a href=\"#判定表的使用步骤\" class=\"headerlink\" title=\"判定表的使用步骤\"></a>判定表的使用步骤</h3><ol>\n<li>分析需求<ul>\n<li>将软件需求规格说明书划分成需求子片段；</li>\n</ul>\n</li>\n<li>分析输入条件，判定是否需要判定表设计方法，如果需要则继续</li>\n<li>找出条件桩、条件项、动作桩、动作项；</li>\n<li>将条件项进行组合，确定测试组合数量（条件项的个数相乘），得出测试规则；</li>\n<li>分析生成的规则，对相似规则进行合并化简（合并有风险，化简需谨慎—对软件系统内部的逻辑结构非常了解；资源有限）；</li>\n<li>分析每条生成的规则，必要时结合等价类边界值生成最终的测试用例。</li>\n</ol>\n<h3 id=\"判定表的适用范围\"><a href=\"#判定表的适用范围\" class=\"headerlink\" title=\"判定表的适用范围\"></a>判定表的适用范围</h3><p>从以上分析我们不难发现，判定表只使用输入输出为一个少元素或者布尔值的集合，因为如果输入输出量太大，那么根据组合数原理，测试用例量将会特别多影响测试效率。</p>\n<p>所以适合功能测试，如修改密码成功与否，登录成功与否，下单成功与否。</p>\n<h3 id=\"判定表的特点\"><a href=\"#判定表的特点\" class=\"headerlink\" title=\"判定表的特点\"></a>判定表的特点</h3><ol>\n<li>条件桩的顺序对生成规则没有影响</li>\n<li>动作桩的顺序对生成的规则没有影响</li>\n<li>每条规则都是独立的相互之间没有影响</li>\n</ol>\n<h3 id=\"判定表的写法\"><a href=\"#判定表的写法\" class=\"headerlink\" title=\"判定表的写法\"></a>判定表的写法</h3><p><img src=\"/./images/test/Testcase-Designer/3.png\"></p>\n<p>以上不难分析出理论上有 2**条件项的测试用例产生。</p>\n<h2 id=\"因果图\"><a href=\"#因果图\" class=\"headerlink\" title=\"因果图\"></a>因果图</h2><p>因果图属于对判定表的一种补充。如果边界值法是对等价类划分法无穷转化为有穷的补充，那么因果图就是对判定表复杂的逻辑输入输出到简化的逻辑输入输出的补充</p>\n<h3 id=\"因果图的三个重要参数\"><a href=\"#因果图的三个重要参数\" class=\"headerlink\" title=\"因果图的三个重要参数\"></a>因果图的三个重要参数</h3><p>因果图顾名思义为 因—果 键值对，那么它有三个重要参数</p>\n<ol>\n<li>原因 : C（course）</li>\n<li>结果:  R（result）</li>\n<li>中间项：当多个原因之间不是单纯的与和或的关系，可以利用中间节点存取中间结果，使得因果图更加清晰</li>\n</ol>\n<p>因果图的因果关系</p>\n<ol>\n<li>逻辑关系<ol>\n<li><p>恒等</p>\n<p> <img src=\"/./images/test/Testcase-Designer/4.png\"></p>\n</li>\n<li><p>与</p>\n<p> <img src=\"/./images/test/Testcase-Designer/5.png\"></p>\n</li>\n<li><p>或</p>\n<p> <img src=\"/./images/test/Testcase-Designer/6.png\"></p>\n</li>\n<li><p>非</p>\n<p> <img src=\"/./images/test/Testcase-Designer/7.png\"></p>\n</li>\n</ol>\n</li>\n<li>制约关系<ol>\n<li>互斥<ul>\n<li>Exclusive</li>\n<li>有多个输入(原因)，至多只能有一个为真，不可以同时都为真，可以同时都为假</li>\n</ul>\n</li>\n<li>包容<ul>\n<li>Inclusive</li>\n<li>有多个输入(原因)，至少有一个为真，可以同时都为真，不可以同时都为假</li>\n</ul>\n</li>\n<li>唯一<ul>\n<li>Only</li>\n<li>有多个输入(原因)，有且只能有一个为真，不可以同时都为真，不可以同时都为假</li>\n</ul>\n</li>\n<li>要求<ul>\n<li>Require</li>\n<li>有两个输入(原因)，A为真，B为真；A为假，B不做要求</li>\n</ul>\n</li>\n<li>强制<ul>\n<li>Mandatory</li>\n<li>有两个输入(原因)，A为真，B为假；A为假，B不做要求</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"因果图的使用步骤\"><a href=\"#因果图的使用步骤\" class=\"headerlink\" title=\"因果图的使用步骤\"></a>因果图的使用步骤</h3><ol>\n<li>分析需求<ul>\n<li>将软件需求规格说明书划分成需求子片段；</li>\n</ul>\n</li>\n<li>分析输入输出，判定是否需要判定表设计方法，如果需要则是否需要借助因果图，如果需要则继续</li>\n<li>分析原因和结果之间的关系，画出因果图</li>\n<li>分析原因之间是否存在制约关系，做出标识</li>\n<li>根据有因果图生成判定表</li>\n<li>分析判定表，进行合并和化简</li>\n<li>必要时结合等价类、边界值生成最终的测试用例</li>\n</ol>\n<h3 id=\"因果图画法\"><a href=\"#因果图画法\" class=\"headerlink\" title=\"因果图画法\"></a>因果图画法</h3><p><img src=\"/./images/test/Testcase-Designer/8.png\"></p>\n<h2 id=\"正交表\"><a href=\"#正交表\" class=\"headerlink\" title=\"正交表\"></a>正交表</h2><p>正交表起源于伽罗瓦的数学理论。因为输入的是一组有限集合，那么多组输入可以简化。所以正交表是对判定表和因果测试用例数的简化</p>\n<h3 id=\"正交表的使用步骤\"><a href=\"#正交表的使用步骤\" class=\"headerlink\" title=\"正交表的使用步骤\"></a>正交表的使用步骤</h3><ol>\n<li>需求分析<ul>\n<li>将软件需求规格说明书划分成需求子片段</li>\n</ul>\n</li>\n<li>分析输入输出，看是否需要用到判定表和因果图，如果需要：找出因子和状态，构造一张因子状态表</li>\n<li>使用正交表工具 allpairs 进行输出测试用例<br> 正交表工具使用方法参考<ul>\n<li><a href=\"/2022/12/05/%E6%B5%8B%E8%AF%95/%E6%AD%A3%E4%BA%A4%E8%A1%A8%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/\" title=\"正交表工具使用方法\">正交表工具使用方法</a></li>\n</ul>\n</li>\n<li>必要时可以结合等价类边界值生成最终的测试用例</li>\n</ol>\n<h3 id=\"正交表的特点和适用范围\"><a href=\"#正交表的特点和适用范围\" class=\"headerlink\" title=\"正交表的特点和适用范围\"></a>正交表的特点和适用范围</h3><p>很明显正交表极大地简化了判定表的测试用例量，所以基本判定表都会使用正交表。特别适合做兼容性测试，表单，配置测试等</p>\n<h2 id=\"状态迁移图\"><a href=\"#状态迁移图\" class=\"headerlink\" title=\"状态迁移图\"></a>状态迁移图</h2><p>在给定的条件下状态能够正确的跳转以及是否有非法转移和未可达的状态</p>\n<p>状态迁移图的关键词</p>\n<ol>\n<li>有限状态机<ul>\n<li>拥有有限个数量的状态，每个状态可以迁移到零个或多个状态</li>\n</ul>\n</li>\n<li>状态<ul>\n<li>某一时刻的表现</li>\n</ul>\n</li>\n<li>跳转条件<ul>\n<li>输入（使得状态发生变化的操作）</li>\n</ul>\n</li>\n<li>迁移<ul>\n<li>状态变化的过程</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"状态迁移图的使用步骤\"><a href=\"#状态迁移图的使用步骤\" class=\"headerlink\" title=\"状态迁移图的使用步骤\"></a>状态迁移图的使用步骤</h3><ol>\n<li>将软件需求规格说明书划分成需求子片段</li>\n<li>分析需求子片段，找出状态和条状条件</li>\n<li>假定一个初始状态，以圆圈（代表状态）为节点以箭线（输入）为跳转条件画出状态迁移图</li>\n<li>根据状态迁移图得出状态事件转换表（第一列代表上一状态；第二列代表跳转条件；第三列代表下一状态；第四列代表输出结果）</li>\n<li>通过状态转换事件表得出状态转换树（矩形框代表状态）</li>\n<li>通过状态转换树找出测试路径</li>\n<li>添加一些非法测试</li>\n<li>必要时可以结合等价类和边界值进行测试</li>\n</ol>\n<h2 id=\"场景测试法\"><a href=\"#场景测试法\" class=\"headerlink\" title=\"场景测试法\"></a>场景测试法</h2><ul>\n<li>pass</li>\n</ul>\n","categories":["测试","测试理论"],"tags":["测试用例","测试用例设计"]},{"title":"软件质量模型","url":"/2022/12/05/%E6%B5%8B%E8%AF%95/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E6%A8%A1%E5%9E%8B/","content":"<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><ul>\n<li><a href=\"https://cloud.tencent.com/developer/article/1457805\">https://cloud.tencent.com/developer/article/1457805</a></li>\n</ul>\n<h1 id=\"官方\"><a href=\"#官方\" class=\"headerlink\" title=\"官方\"></a>官方</h1><p>软件质量模型是现 ISO/IEC25015 或 ISO/IEC9126 发布的软件质量保证的模型</p>\n<ul>\n<li>它可以用官方的解释来判断一个软件质量的好坏与否</li>\n</ul>\n<h1 id=\"质量模型\"><a href=\"#质量模型\" class=\"headerlink\" title=\"质量模型\"></a>质量模型</h1><p>质量模型涉及6大特性和27个子特性</p>\n<span id=\"more\"></span>\n\n<p><img src=\"/./images/test/QA-modules/1.png\"></p>\n<h2 id=\"功能性\"><a href=\"#功能性\" class=\"headerlink\" title=\"功能性\"></a><em>功能性</em></h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><ol>\n<li><p><em>软件产品提供明确、隐含要求的能力</em></p>\n<p>2.<em>适合性</em> 软件产品为指定的任务和用户提供一组合适的功能的能力（投入运行后，功能是否合适、正确、完整等）</p>\n<p>3.<em>准确性</em> 软件产品提供具有所需精度的正确或相符的结果或效果的能力（实际与预期的差别）</p>\n<p>4.<em>互操作性</em> 软件产品与一个或更多的规定系统进行交互的能力（如果与其它软件有定义接口，数据传输的正确程度）</p>\n</li>\n<li><p><em>安全保密性</em> 软件产品保护信息和数据的能力，使未授权的人不能阅读或修改这些信息和数据，而不拒绝授权人员阅读或修改这些信息和数据(访问的可审核性（正常、病毒）、可控制性）</p>\n<p>6.<em>功能性的依从性</em> 软件产品遵循与功能性相关的标准、约定或法规及类似规定的能力（非法）</p>\n</li>\n</ol>\n<h2 id=\"可靠性\"><a href=\"#可靠性\" class=\"headerlink\" title=\"可靠性\"></a><em>可靠性</em></h2><ol>\n<li><em>在指定条件下使用时，软件产品维持规定的性能级别的能力</em></li>\n<li><em>成熟性</em> 软件产品为避免由软件内部的故障而导致失效的能力（潜在的故障密度、失效的测试用例数量、故障排除）</li>\n<li><em>容错性</em> 在软件出现故障或者违反其指定接口的情况下，软件产品维持规定的性能级别的能力</li>\n<li><em>易恢复性</em> 在失效发生的情况下，软件产品重建规定的性能级别并恢复受直接影响的数据的能力（重启能力、重启时间）</li>\n<li><em>可靠性的依从性</em> 软件产品遵循与可靠性相关的标准、约定或法规的能力（非法）</li>\n</ol>\n<h2 id=\"易用性\"><a href=\"#易用性\" class=\"headerlink\" title=\"易用性\"></a><em>易用性</em></h2><ol>\n<li><em>在指定条件下使用时，软件产品被理解、学习、使用和在指定条件下使用时，软件产品被理解、学习、使用和吸引用户的能力</em></li>\n<li><em>易理解性</em> 软件产品使用户能理解软件是否合适以及如何能将软件用于特定的任务和使用条件的能力（文档、功能的初始印象）</li>\n<li><em>易学性</em> 软件产品使用户能学会其应用的能力（使用者学习满足需求的能力）</li>\n<li><em>易操作性</em> 软件产品使用户能操作和控制它的能力</li>\n<li><em>吸引性</em> 软件产品吸引用户的能力</li>\n<li><em>易用性的依从性</em> 软件产品遵循与易用性相关的标准、约定、风格指南或法规的能力（非法）</li>\n</ol>\n<h2 id=\"效率\"><a href=\"#效率\" class=\"headerlink\" title=\"效率\"></a><em>效率</em></h2><ol>\n<li><em>在规定条件下，相对于所用资源的数量，软件产品可提在规定条件下，相对于所用资源的数量，软件产品可提供适当性能的能力</em></li>\n<li><em>时间特性</em> 在规定条件下，软件产品执行其功能时，提供适当的响应和处理时间以及吞吐率的能力（如响应时间）</li>\n<li><em>资源利用性</em> 在规定条件下，软件产品执行其功能时，使用合适数量和类别的资源的能力（如内存占用）</li>\n<li><em>效率依从性</em> 软件产品遵循与效率相关的标准或约定的能力（非法）</li>\n</ol>\n<h2 id=\"可维护性\"><a href=\"#可维护性\" class=\"headerlink\" title=\"可维护性\"></a><em>可维护性</em></h2><ol>\n<li><em>软件产品可被修改的能力。修改可能包括修正、改进或软件对环境、需求和功能规格说明变化的适应</em></li>\n<li><em>易分析性</em> 软件产品诊断软件中的缺陷或失效原因或识别待修改部分的能力。</li>\n<li><em>易改变性</em> 软件产品使指定的修改可以被实现的能力（变更难易的程度）</li>\n<li><em>稳定性</em> 软件产品避免由于软件修改而造成意外结果的能力（由于软件修改而造成的意外）</li>\n<li><em>易测试性</em> 软件产品修改能被确认的能力</li>\n<li><em>维护性的依从性</em> 软件产品遵循与维护性相关的标准或约定的能力（非法）</li>\n</ol>\n<h2 id=\"可移植性\"><a href=\"#可移植性\" class=\"headerlink\" title=\"可移植性\"></a><em>可移植性</em></h2><ol>\n<li><em>软件产品从一种环境迁移到另一种环境的能力</em></li>\n<li><em>适应性</em> 软件产品毋需采用额外的活动或手段就可适应不同指定环境的能力（屏幕大小）</li>\n<li><em>易安装性</em> 软件产品在指定环境中被安装的能力（用户在指定环境中被安装的能力，与易操作性互相影响）</li>\n<li><em>共存性</em> 软件产品在公共环境中同与其分享公共资源的其他独立软件共存的能力（共享资源的其它软件）</li>\n<li><em>易替换性</em> 软件产品在同样环境下，替代另一个相同用途的软件产品的能力（版本迭代、新旧兼容）</li>\n<li><em>可移植性的依从性</em> 软件产品遵循与可移植性相关的标准或约定的能力（非法）</li>\n</ol>\n<h2 id=\"软件的使用质量模型\"><a href=\"#软件的使用质量模型\" class=\"headerlink\" title=\"软件的使用质量模型\"></a>软件的使用质量模型</h2><p>基于用户观点的软件产品用于指定的环境和使用周境时的质量。它测量用户在特定环境中能达到其目标的程度，而不是测量软件自身的属性。</p>\n<p>基本的软件使用质量模型包括4大特性</p>\n<p><img src=\"/./images/test/QA-modules/2.png\"></p>\n","categories":["测试","测试理论"],"tags":["质量模型"]}]