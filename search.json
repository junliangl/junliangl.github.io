[{"title":"正交表工具使用方法","url":"/2022/12/05/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/%E6%AD%A3%E4%BA%A4%E8%A1%A8%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","content":"<p>正交表工具使用方法</p>\n<ul>\n<li>参考链接<ul>\n<li><a href=\"https://blog.csdn.net/qq_54444533/article/details/124828947\">https://blog.csdn.net/qq_54444533/article/details/124828947</a></li>\n</ul>\n</li>\n<li>官方网站<ul>\n<li><a href=\"https://www.satisfice.com/download/allpairs\">https://www.satisfice.com/download/allpairs</a></li>\n</ul>\n</li>\n<li>下载后解压<ul>\n<li><img src=\"/./images/test-theory/Orthogonal-tool/1.png\"></li>\n</ul>\n</li>\n<li>将该目录添加至环境变量 PATH<ul>\n<li><img src=\"/./images/test-theory/Orthogonal-tool/2.png\"></li>\n<li>输入 <code>allpairs</code> 命令显示以上则安装成功</li>\n</ul>\n</li>\n<li>使用方法<ul>\n<li>第一步<ul>\n<li>对需要正交表的条件项目依次填入 csv 中，格式如下</li>\n<li><img src=\"/./images/test-theory/Orthogonal-tool/3.png\"></li>\n</ul>\n</li>\n<li>第二步<ul>\n<li>复制全部内容到 txt 文档</li>\n<li><img src=\"/./images/test-theory/Orthogonal-tool/4.png\"></li>\n<li>注意不要在意 txt 文档格式混乱，allpairs 会自动识别。并且最后一行不能有换行符。否则会报错<ul>\n<li><img src=\"/./images/test-theory/Orthogonal-tool/5.png\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>第三步<ul>\n<li>用如下命令<ul>\n<li><code>allpiars 测试数据.txt &gt; 你需要生成的testcase.xlsx 表格中</code></li>\n<li><img src=\"/./images/test-theory/Orthogonal-tool/6.png\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>最后查看结果<ul>\n<li><img src=\"/./images/test-theory/Orthogonal-tool/7.png\"></li>\n</ul>\n</li>\n<li>值得注意的是，表格下方是所有笛卡尔积结果。上方才是需要测试的数据<ul>\n<li>其中前缀为~的项表示无关数据，可以任意取值</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["测试理论"]},{"title":"docker","url":"/2022/12/05/linux/docker/","content":"<h1 id=\"docker详解\"><a href=\"#docker详解\" class=\"headerlink\" title=\"docker详解\"></a>docker详解</h1>","categories":["linux"]},{"title":"软件开发模型（SDLC)","url":"/2022/12/05/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B%EF%BC%88SDLC)/","content":"<p>软件开发模型（SDLC）</p>\n<ul>\n<li><p>参考链接</p>\n<ul>\n<li><a href=\"https://cloud.tencent.com/developer/article/1724043\">https://cloud.tencent.com/developer/article/1724043</a></li>\n</ul>\n</li>\n<li><p>软件开发模型多种多样，下面讲解以下常用的开发模型</p>\n<ul>\n<li>瀑布模型</li>\n<li>V型</li>\n<li>迭代和增量模型</li>\n<li>螺旋模型</li>\n<li>大爆炸模型</li>\n<li>敏捷模型</li>\n<li>原型模型</li>\n<li>DevOps</li>\n</ul>\n</li>\n<li><p>瀑布模型</p>\n<ul>\n<li><img src=\"/./images/test-theory/SDLC-modules/1.png\"></li>\n<li>瀑布模型（Waterfall） 是最简单的软件开发历史上第一个 SDLC 模型。在瀑布模型中，开发过程是线性的。任务和阶段按严格顺序一个接一个地完成。进度平稳地向下流动，就像瀑布上的水一样。</li>\n<li>瀑布模型的主要缺点是不灵活。瀑布易于理解且易于管理。但是过早的延迟会拖延整个项目的时间表。由于一旦完成阶段，几乎没有修改的余地，因此只有进入维护阶段才能解决问题。如果需要灵活性，或者项目是长期的且正在进行的，则此模型不能很好地工作</li>\n</ul>\n</li>\n<li><p>V 型</p>\n<ul>\n<li><img src=\"/./images/test-theory/SDLC-modules/2.png\"></li>\n<li>V 形模型也称为 V 模型或验证与验证模型，是瀑布方法的扩展。使用 V 模型时，进度并不会直线移动，而是在实施和开发后逐渐上升。</li>\n<li>对于 V 型 SDLC 项目，早期测试介入是与 瀑布模型相比的主要区别。每个开发阶段都有一个并行测试阶段，这有助于在继续下一步之前验证和验证每个步骤。</li>\n</ul>\n</li>\n<li><p>迭代和增量模型</p>\n<ul>\n<li><img src=\"/./images/test-theory/SDLC-modules/3.png\"></li>\n<li>迭代和增量 SDLC 模型将迭代设计和工作流与增量构建模型结合在一起。在这种情况下，团队将按周期开发产品，并以渐进方式构建小零件。</li>\n<li>开发过程从简单实施一组严格限制的小型产品需求开始。然后对该产品进行增强，并使其本身成为更完整的版本，直到完成并准备好进行部署为止。每次迭代都可能包含设计更新和新功能。</li>\n<li>迭代和增量模型的一个有价值的特点是可以在不知道所有需求的情况下开始开发。该模型包含其他 SDLC 模型的步骤-需求收集，设计，实施和测试，但要经过多次构建。开发团队可以利用先前构建中取得的成就来改善下一构建。</li>\n<li>迭代和增量 SDLC 模型可能看起来像一组微型瀑布模型或微型 V 形模型。</li>\n</ul>\n</li>\n<li><p>4.螺旋模型</p>\n<ul>\n<li><img src=\"/./images/test-theory/SDLC-modules/4.png\"></li>\n<li>螺旋 SDLC 模型是原型方法和瀑布方法的结合。螺旋模型被认为是最灵活的 SDLC 方法之一。它从迭代模型及其重复中获得启发。该项目以“螺旋式”的方式反复经历四个阶段，直到完成为止，从而可以进行多轮改进。<ul>\n<li>规划</li>\n<li>风险分析</li>\n<li>工程</li>\n<li>评价</li>\n</ul>\n</li>\n<li>螺旋模型主要用于大型项目，它允许构建高度定制的产品，并且用户反馈可以在项目的早期就被纳入。但可能有项目会形成永无止境的螺旋式发展的风险。</li>\n</ul>\n</li>\n<li><p>大爆炸模型</p>\n<ul>\n<li><img src=\"/./images/test-theory/SDLC-modules/5.png\"></li>\n<li>Big Bang 模型通常不遵循任何特定过程或说明。开发从当前可用的资源和工作开始，几乎没有计划或根本没有计划。结果，客户得到的产品甚至可能无法满足要求。功能是动态实现的。</li>\n<li>Big Bang SDLC 模型的主要思想是将所有可用资源分配给产品本身的开发，主要是在编码方面，而不用担心满足计划。这是仅用于一两个软件工程师的小型项目的 SDLC 方法之一。</li>\n</ul>\n</li>\n<li><p>敏捷模型</p>\n<ul>\n<li><img src=\"/./images/test-theory/SDLC-modules/6.png\"></li>\n<li>敏捷（Agile） SDLC 模型是迭代和增量方法的组合，致力于通过早期交付工作软件来适应灵活的需求并满足用户和客户的需求。敏捷项目中的需求和解决方案可能会在开发过程中发展。</li>\n<li>通过敏捷开发，该产品被分为小的增量构建，并以迭代方式交付。将所有任务划分为较小的时间范围，以便为每个版本准备工作功能。最终产品版本包含所有必需的功能。敏捷仍然是技术行业中使用最广泛的SDLC。</li>\n</ul>\n</li>\n<li><p>DevOps模型</p>\n<ul>\n<li><img src=\"/./images/test-theory/SDLC-modules/7.png\"></li>\n<li>DevOps是新手模型。DevOps来自两个趋势：敏捷方法和精益方法的应用。通常，DevOps 是通过自动化基础架构和工作流程并持续跟踪应用程序性能来执行的。DevOps方法使您可以增加部署频率，编写代码并缩短部署新代码所需的时间。</li>\n<li>DevOps是工具，实践和方法的组合，鼓励开发人员，运维人员和 QA人员共同努力，以进行持续的开发，测试和部署活动，以加速创新并交付更高质量和更可靠的软件产品和功能。</li>\n</ul>\n</li>\n</ul>\n","categories":["测试理论"]},{"title":"测试用例设计方法","url":"/2022/12/05/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/","content":"<p>测试用例设计方法</p>\n<ul>\n<li>测试用例该如何设计呢</li>\n<li>测试上可以分为黑盒测试和白盒测试两种<ul>\n<li><p>黑盒测试</p>\n<ul>\n<li><img src=\"/./images/test-theory/Testcase-Designer/1.png\"></li>\n</ul>\n</li>\n<li><p>白盒测试</p>\n<ul>\n<li><img src=\"/./images/test-theory/Testcase-Designer/1.png\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>等价类划分法（简称等价类）<ul>\n<li>定义<ul>\n<li>将输入（输出）域划分成若干个子集合中，从划分的子集合中选取代表数据进行测试，如果选取的数据测试没有问题，就认为其他数据测试的效果是等价的</li>\n</ul>\n</li>\n<li>分为 <ul>\n<li>有效等价类</li>\n<li>无效等价类</li>\n</ul>\n</li>\n<li>等价类划分原则<ul>\n<li>如果输入（输出）是一个取值范围或者某个值的个数时，则划分成一个有效等价类和两个无效等价类<ul>\n<li>举例<ul>\n<li>某个大厦招聘保安，年龄要求18~60周岁（包括18和60）<ul>\n<li>一个有效等价类：18~60</li>\n<li>两个无效等价类：&lt;18；&gt;60</li>\n</ul>\n</li>\n<li>并且从以上区间选取带有标志性的数据测试<ul>\n<li>如有效等价类区间里选取 18 60 50…..，无效等价类里选取 10 70 80 …..</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>如果输入（输出）是一个有限集合或者必须如何的条件，则划分成一个有效等价类和一个无效等价类<ul>\n<li>举例<ul>\n<li>一个集合：以下城市进入上海需要提供核酸检测报告（沈阳；大连；深圳；广州；合肥；六安；营口；瑞丽）<ul>\n<li>一个有效等价类：集合内；</li>\n<li>一个无效等价类：集合外（菏泽）</li>\n</ul>\n</li>\n<li>并且从以上区间选取带有标志性的数据测试<ul>\n<li>如有效等价类选取大连……，无效等价类选取 菏泽……</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>如果输入（输出）是一个布尔量，则划分成一个有效等价类和一个无效等价类<ul>\n<li>举例<ul>\n<li>某个问卷调查 App 如果性别选项选择男请转到第五题：<ul>\n<li>一个有效：男</li>\n<li>一个无效：女</li>\n</ul>\n</li>\n<li>如果性别选项选择女请转到第二题：<ul>\n<li>一个有效：女</li>\n<li>一个无效：男</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>很明显布尔类型是第二种等价类的特殊情况</li>\n</ul>\n</li>\n<li>如果输入（输出）已经划分出有效和无效等价类，针对有效等价类部分不同的取值处理方式不一样，细分成多个有效等价类和一个无效等价类<ul>\n<li>举例<ul>\n<li>某个认证考试百分制；60分及格可以获得认证证书<ul>\n<li>一个有效等价类：&gt;&#x3D;60分<ul>\n<li>细化等价类：   60<del>69分—合格；70</del>79分—中等；80<del>89分—良好；90</del>99分—优秀；100分—完美</li>\n</ul>\n</li>\n<li>一个无效等价类：&lt;60分</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>如果输入（输出）要同时满足多个条件，则划分成一个有效等价类和多个无效等价类<ul>\n<li>举例<ul>\n<li>学习系统登录密码修改：6~12位；<ul>\n<li>一个有效等价类：大小写字母与数字的组合满足所有要求</li>\n<li>多个无效等价类：少于6位；大于12位；缺少数字；缺少小写字母；缺少大写字母；含有其他字母</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>很明显从以上看出当有限集合数量过于庞大时，我们不采用第二种等价类划分法，采用当前的划分方法</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>使用步骤<ul>\n<li>分析需求<ul>\n<li>将软件需求规格说明书划分成需求子片段</li>\n<li>分析需求子片段，找出输入条件</li>\n</ul>\n</li>\n<li>分析输入条件，判定是否需要结合等价类划分原则划分等价，需要则继续</li>\n<li>为了防止测试遗漏，为划分的等价类进行编号</li>\n<li>从划分的等价类中选取代表数据进行测试，直到所有的等价类全部被覆盖</li>\n<li>将选取的数据结合测试用例写作格式完成最终测试用例的编写</li>\n<li>值得注意的是<ul>\n<li>一条测试用例尽量覆盖多个有效等价类；</li>\n<li>一条测试用例只覆盖一个无效等价类；</li>\n<li>这符合之前等价类设计方法的最后一条，因为实际输入要么是庞大的集合，要么是无穷的区间。总之应该以有效等价类覆盖越多越好</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>边界值<ul>\n<li>对于等价类划分法的问题是等价类划分法追求有效等价类覆盖率和数量，然而拥有无穷数的区间却使用一个等价类设计思路，这显然和宗旨相悖。基于以上问题，那么边界值设计方法可以对以上问题进行补充</li>\n<li>边界值有三个重要的参数<ul>\n<li>上点：区间边界的点</li>\n<li>离点：离区间边界点最近的点<ul>\n<li>如果是开区间离点落在区间内，如果是闭区间离点落在区间外<ul>\n<li>即离点不能落在区间里</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>内点：落在区间内任意的点</li>\n<li>举例<ul>\n<li>某个大厦招聘保安，年龄要求[18，60]周岁<ul>\n<li>上点：18；60</li>\n<li>离点：17；61</li>\n<li>内点：30</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>通过以上三个重要参数介绍基于边界值的选取原则<ul>\n<li>如果输入（输出）是一个取值范围时，则以边界和边界附近的值作为测试用例数据优先选取<ul>\n<li>这就是对等价类不足的设计手段，因为等价类不能精确地锁定哪些数据需要拿来测试。</li>\n</ul>\n</li>\n<li>如果输入（输出）是一个有序的集合，则以第一个元素和最后一个元素作为测试用例<ul>\n<li>这个是基于对第二种等价类划分原则进行补充。</li>\n</ul>\n</li>\n<li>如果输入（输出）的值的个数是个取值范围，则以最大个数、最大个数+1、最小个数、最小个数-1作为测试用例数据优先选取；<ul>\n<li>这个是对以上两条内容的补充</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>使用步骤<ul>\n<li>分析需求<ul>\n<li>将软件需求规格说明书划分成需求子片段</li>\n<li>分析需求子片段，找出输入条件</li>\n</ul>\n</li>\n<li>分析输入条件，判定是否需要边界值法，如果需要结合等价类划分原则划分等价类<ul>\n<li>很明显，边界值划分法是基于等价类划分法的补充，一定要优先择取等价类划分，根据划分情况选择合适的数据</li>\n</ul>\n</li>\n<li>判断是否需要边界值和需要哪种边界值方法<ul>\n<li>分析等价类，是否需要边界值补充</li>\n<li>结合边界值数据选取原则确定边界值的选取</li>\n</ul>\n</li>\n<li>将选取的数据结合测试用例写作格式完成最终测试用例的编写</li>\n</ul>\n</li>\n<li>等价类和边界值适用范围<ul>\n<li>特点：不测试各种组合。测试效率比较高，效果一般。比较容易理解和易于使用的一种方法</li>\n<li>适用范围：功能测试；性能测试；界面测试（GUI测试）；兼容测试</li>\n<li>注意接口测试一般不选取等价类划分法去测试，一般功能测试可以使用等价类划分法</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>判定表<ul>\n<li>分析和表达多种输入条件下完成不同动作的一种工具，这种方法能够将具有复杂逻辑关系和多种条件组合的情况表达清晰。</li>\n<li>很显然，判定表是针对有限布尔集合或者输入是处于多个有限集合而言的。而一般功能的输出的集合一般只有一两个元素，然后由于有 switch-case 这种情况的出现，我们就可以考虑由判定表方法完成</li>\n<li>判定表一样有三个重要的参数<ul>\n<li>条件桩：输入条件<ul>\n<li>表示输入取值的集合</li>\n</ul>\n</li>\n<li>条件项：输入条件的取值<ul>\n<li>表示具体输入的集合元素</li>\n</ul>\n</li>\n<li>动作桩：输出结果<ul>\n<li>表示输出的取值集合</li>\n</ul>\n</li>\n<li>动作项：输出结果的取值<ul>\n<li>表示具体输出的集合元素</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>使用步骤<ul>\n<li>分析需求<ul>\n<li>将软件需求规格说明书划分成需求子片段；</li>\n</ul>\n</li>\n<li>分析输入条件，判定是否需要判定表设计方法，如果需要则继续</li>\n<li>找出条件桩、条件项、动作桩、动作项；</li>\n<li>将条件项进行组合，确定测试组合数量（条件项的个数相乘），得出测试规则；</li>\n<li>分析生成的规则，对相似规则进行合并化简（合并有风险，化简需谨慎—对软件系统内部的逻辑结构非常了解；资源有限）；</li>\n<li>分析每条生成的规则，必要时结合等价类边界值生成最终的测试用例。</li>\n</ul>\n</li>\n<li>判定表适用范围<ul>\n<li>从以上分析我们不难发现，判定表只使用输入输出为一个少元素或者布尔值的集合，因为如果输入输出量太大，那么根据组合数原理，测试用例量将会特别多影响测试效率。</li>\n<li>所以适合功能测试，如修改密码成功与否，登录成功与否，下单成功与否。</li>\n</ul>\n</li>\n<li>判定表特点<ul>\n<li>条件桩的顺序对生成规则没有影响</li>\n<li>动作桩的顺序对生成的规则没有影响</li>\n<li>每条规则都是独立的相互之间没有影响</li>\n</ul>\n</li>\n<li>判定表写法<ul>\n<li><img src=\"/./images/test-theory/Testcase-Designer/3.png\"></li>\n<li>以上不难分析出理论上有 2**条件项的测试用例产生。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>因果图<ul>\n<li>因果图属于对判定表的一种补充。如果边界值法是对等价类划分法无穷转化为有穷的补充，那么因果图就是对判定表复杂的逻辑输入输出到简化的逻辑输入输出的补充</li>\n<li>因果图顾名思义为 因—果 键值对，那么它有三个重要参数<ul>\n<li>原因 : C（course）</li>\n<li>结果:  R（result）</li>\n<li>中间项：当多个原因之间不是单纯的与和或的关系，可以利用中间节点存取中间结果，使得因果图更加清晰</li>\n</ul>\n</li>\n<li>因果有了，因果关系如下<ul>\n<li>逻辑关系<ul>\n<li>恒等<ul>\n<li>图标<ul>\n<li><img src=\"/./images/test-theory/Testcase-Designer/4.png\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>与<ul>\n<li>图标<ul>\n<li><img src=\"/./images/test-theory/Testcase-Designer/5.png\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>或<ul>\n<li>图标<ul>\n<li><img src=\"/./images/test-theory/Testcase-Designer/6.png\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>非<ul>\n<li>图标<ul>\n<li><img src=\"/./images/test-theory/Testcase-Designer/7.png\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>制约关系<ul>\n<li>互斥<ul>\n<li>Exclusive</li>\n<li>有多个输入(原因)，至多只能有一个为真，不可以同时都为真，可以同时都为假</li>\n</ul>\n</li>\n<li>包容<ul>\n<li>Inclusive</li>\n<li>有多个输入(原因)，至少有一个为真，可以同时都为真，不可以同时都为假</li>\n</ul>\n</li>\n<li>唯一<ul>\n<li>Only</li>\n<li>有多个输入(原因)，有且只能有一个为真，不可以同时都为真，不可以同时都为假</li>\n</ul>\n</li>\n<li>要求<ul>\n<li>Require</li>\n<li>有两个输入(原因)，A为真，B为真；A为假，B不做要求</li>\n</ul>\n</li>\n<li>强制<ul>\n<li>Mandatory</li>\n<li>有两个输入(原因)，A为真，B为假；A为假，B不做要求</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>使用步骤<ul>\n<li>分析需求<ul>\n<li>将软件需求规格说明书划分成需求子片段；</li>\n</ul>\n</li>\n<li>分析输入输出，判定是否需要判定表设计方法，如果需要则是否需要借助因果图，如果需要则继续</li>\n<li>分析原因和结果之间的关系，画出因果图</li>\n<li>分析原因之间是否存在制约关系，做出标识</li>\n<li>根据有因果图生成判定表</li>\n<li>分析判定表，进行合并和化简</li>\n<li>必要时结合等价类、边界值生成最终的测试用例</li>\n</ul>\n</li>\n<li>因果图画法<ul>\n<li><img src=\"/./images/test-theory/Testcase-Designer/8.png\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>正交表<ul>\n<li>正交表起源于伽罗瓦的数学理论。因为输入的是一组有限集合，那么多组输入可以简化。所以正交表是对判定表和因果测试用例数的简化</li>\n<li>使用步骤<ul>\n<li>需求分析<ul>\n<li>将软件需求规格说明书划分成需求子片段</li>\n</ul>\n</li>\n<li>分析输入输出，看是否需要用到判定表和因果图，如果需要：找出因子和状态，构造一张因子状态表</li>\n<li>使用正交表工具 allpairs 进行输出测试用例<ul>\n<li>正交表工具使用方法参考<ul>\n<li><a href=\"https://quip.com/47tSAq3WmZ9P\">https://quip.com/47tSAq3WmZ9P</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>必要时可以结合等价类边界值生成最终的测试用例</li>\n</ul>\n</li>\n<li>特点和适用范围<ul>\n<li>很明显正交表极大地简化了判定表的测试用例量，所以基本判定表都会使用正交表</li>\n<li>特别适合做兼容性测试，表单，配置测试等</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>状态迁移图<ul>\n<li>定义<ul>\n<li>在给定的条件下状态能够正确的跳转以及是否有非法转移和未可达的状态</li>\n</ul>\n</li>\n<li>相关关键词如下<ul>\n<li>有限状态机<ul>\n<li>拥有有限个数量的状态，每个状态可以迁移到零个或多个状态</li>\n</ul>\n</li>\n<li>状态<ul>\n<li>某一时刻的表现</li>\n</ul>\n</li>\n<li>跳转条件<ul>\n<li>输入（使得状态发生变化的操作）</li>\n</ul>\n</li>\n<li>迁移<ul>\n<li>状态变化的过程</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>使用步骤<ul>\n<li>将软件需求规格说明书划分成需求子片段</li>\n<li>分析需求子片段，找出状态和条状条件</li>\n<li>假定一个初始状态，以圆圈（代表状态）为节点以箭线（输入）为跳转条件画出状态迁移图</li>\n<li>根据状态迁移图得出状态事件转换表（第一列代表上一状态；第二列代表跳转条件；第三列代表下一状态；第四列代表输出结果）</li>\n<li>通过状态转换事件表得出状态转换树（矩形框代表状态）</li>\n<li>通过状态转换树找出测试路径</li>\n<li>添加一些非法测试</li>\n<li>必要时可以结合等价类和边界值进行测试</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>场景测试法</li>\n</ul>\n","categories":["测试理论"]},{"title":"软件质量模型","url":"/2022/12/05/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E6%A8%A1%E5%9E%8B/","content":"<p>软件质量模型</p>\n<ul>\n<li><p>参考链接</p>\n<ul>\n<li><a href=\"https://cloud.tencent.com/developer/article/1457805\">https://cloud.tencent.com/developer/article/1457805</a></li>\n</ul>\n</li>\n<li><p>软件质量模型是现 ISO&#x2F;IEC25015 或 ISO&#x2F;IEC9126 发布的软件质量保证的模型</p>\n<ul>\n<li>它可以用官方的解释来判断一个软件质量的好坏与否</li>\n</ul>\n</li>\n<li><p>质量模型涉及6大特性和27个子特性</p>\n<ul>\n<li><img src=\"/./images/test-theory/QA-modules/1.png\"></li>\n<li><em>功能性</em><ul>\n<li><em>软件产品提供明确、隐含要求的能力</em></li>\n<li><em>适合性</em> 软件产品为指定的任务和用户提供一组合适的功能的能力（投入运行后，功能是否合适、正确、完整等）</li>\n<li><em>准确性</em> 软件产品提供具有所需精度的正确或相符的结果或效果的能力（实际与预期的差别）</li>\n<li><em>互操作性</em> 软件产品与一个或更多的规定系统进行交互的能力（如果与其它软件有定义接口，数据传输的正确程度）</li>\n<li><em>安全保密性</em> 软件产品保护信息和数据的能力，使未授权的人不能阅读或修改这些信息和数据，而不拒绝授权人员阅读或修改这些信息和数据(访问的可审核性（正常、病毒）、可控制性）</li>\n<li><em>功能性的依从性</em> 软件产品遵循与功能性相关的标准、约定或法规及类似规定的能力（非法）</li>\n</ul>\n</li>\n<li><em>可靠性</em><ul>\n<li><em>在指定条件下使用时，软件产品维持规定的性能级别的能力</em></li>\n<li><em>成熟性</em> 软件产品为避免由软件内部的故障而导致失效的能力（潜在的故障密度、失效的测试用例数量、故障排除）</li>\n<li><em>容错性</em> 在软件出现故障或者违反其指定接口的情况下，软件产品维持规定的性能级别的能力</li>\n<li><em>易恢复性</em> 在失效发生的情况下，软件产品重建规定的性能级别并恢复受直接影响的数据的能力（重启能力、重启时间）</li>\n<li><em>可靠性的依从性</em> 软件产品遵循与可靠性相关的标准、约定或法规的能力（非法）</li>\n</ul>\n</li>\n<li><em>易用性</em><ul>\n<li><em>在指定条件下使用时，软件产品被理解、学习、使用和在指定条件下使用时，软件产品被理解、学习、使用和吸引用户的能力</em></li>\n<li><em>易理解性</em> 软件产品使用户能理解软件是否合适以及如何能将软件用于特定的任务和使用条件的能力（文档、功能的初始印象）</li>\n<li><em>易学性</em> 软件产品使用户能学会其应用的能力（使用者学习满足需求的能力）</li>\n<li><em>易操作性</em> 软件产品使用户能操作和控制它的能力</li>\n<li><em>吸引性</em> 软件产品吸引用户的能力</li>\n<li><em>易用性的依从性</em> 软件产品遵循与易用性相关的标准、约定、风格指南或法规的能力（非法）</li>\n</ul>\n</li>\n<li><em>效率</em><ul>\n<li><em>在规定条件下，相对于所用资源的数量，软件产品可提在规定条件下，相对于所用资源的数量，软件产品可提供适当性能的能力</em></li>\n<li><em>时间特性</em> 在规定条件下，软件产品执行其功能时，提供适当的响应和处理时间以及吞吐率的能力（如响应时间）</li>\n<li><em>资源利用性</em> 在规定条件下，软件产品执行其功能时，使用合适数量和类别的资源的能力（如内存占用）</li>\n<li><em>效率依从性</em> 软件产品遵循与效率相关的标准或约定的能力（非法）</li>\n</ul>\n</li>\n<li><em>可维护性</em><ul>\n<li><em>软件产品可被修改的能力。修改可能包括修正、改进或软件对环境、需求和功能规格说明变化的适应</em></li>\n<li><em>易分析性</em> 软件产品诊断软件中的缺陷或失效原因或识别待修改部分的能力。<em>易改变性。</em>软件产品使指定的修改可以被实现的能力（变更难易的程度）</li>\n<li><em>稳定性</em> 软件产品避免由于软件修改而造成意外结果的能力（由于软件修改而造成的意外）</li>\n<li><em>易测试性</em> 软件产品修改能被确认的能力</li>\n<li><em>维护性的依从性</em> 软件产品遵循与维护性相关的标准或约定的能力（非法）</li>\n</ul>\n</li>\n<li><em>可移植性</em><ul>\n<li><em>软件产品从一种环境迁移到另一种环境的能力</em></li>\n<li><em>适应性</em> 软件产品毋需采用额外的活动或手段就可适应不同指定环境的能力（屏幕大小）</li>\n<li><em>易安装性</em> 软件产品在指定环境中被安装的能力（用户在指定环境中被安装的能力，与易操作性互相影响）</li>\n<li><em>共存性</em> 软件产品在公共环境中同与其分享公共资源的其他独立软件共存的能力（共享资源的其它软件）</li>\n<li><em>易替换性</em> 软件产品在同样环境下，替代另一个相同用途的软件产品的能力（版本迭代、新旧兼容）</li>\n<li><em>可移植性的依从性</em> 软件产品遵循与可移植性相关的标准或约定的能力（非法）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>软件的使用质量模型</p>\n<ul>\n<li>基于用户观点的软件产品用于指定的环境和使用周境时的质量。它测量用户在特定环境中能达到其目标的程度，而不是测量软件自身的属性。</li>\n<li>基本的软件使用质量模型包括4大特性<ul>\n<li><img src=\"/./images/test-theory/QA-modules/2.png\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["测试理论"]},{"title":"Python pytest 模块单元测试","url":"/2022/12/05/python/pytest/","content":"<h1 id=\"一、简单入门：\"><a href=\"#一、简单入门：\" class=\"headerlink\" title=\"一、简单入门：\"></a>一、简单入门：</h1><ul>\n<li><p>准备 requirements.txt 写入以下插件和包</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">`pytest`</span><br><span class=\"line\">`pytest-html`</span><br><span class=\"line\">`pytest-xdist`</span><br><span class=\"line\">`pytest-ordering`</span><br><span class=\"line\">`pytest-rerunfailures`</span><br><span class=\"line\">`allure-pytest`</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装插件</p>\n<ul>\n<li><code>pip install -r requirements.txt</code></li>\n</ul>\n</li>\n<li><p>编写一个简单的测试脚本 test.py</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pytest</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestCase</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_number</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> <span class=\"literal\">True</span> <span class=\"keyword\">is</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行 pytest </p>\n<ul>\n<li><code>pytest -vs test.py</code></li>\n</ul>\n</li>\n<li><p>运行结果如下</p>\n<ul>\n<li><img src=\"/./images/python/pytest/1.png\"></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"二、详细讲解\"><a href=\"#二、详细讲解\" class=\"headerlink\" title=\"二、详细讲解\"></a>二、详细讲解</h1><ul>\n<li><p>运行</p>\n<ul>\n<li><p>python test.py 脚本下 写入 main 方法调用 pytest.main() 去执行</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    pytest.main([<span class=\"string\">&#x27;-s&#x27;</span>, <span class=\"string\">&#x27;./test_number.py&#x27;</span>])</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>终端模式下也可以通过 pytest 命令执行</p>\n<ul>\n<li><code>pytest -vs test.py</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>参数解析</p>\n<ul>\n<li><p>默认不加参数即运行</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    pytest.main()</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>pytest test.py</code></li>\n</ul>\n</li>\n<li><p>以上默认运行以下测试用例<br>  * 名字带有 test 开头或 test 结尾的 python 模块<br>  * 名字以 Test 开头且不能含有 <strong>init</strong> 方法的类<br>  * 名字以 test 开头的方法</p>\n</li>\n<li><p>常用的参数解释</p>\n<ul>\n<li>-s<ul>\n<li>打印输出调试信息</li>\n</ul>\n</li>\n<li>-v<ul>\n<li>输出更详细的信息</li>\n</ul>\n</li>\n<li>-n number (输入几个线程)<ul>\n<li>多线程或分布式运行</li>\n</ul>\n</li>\n<li>–reruns number (输入重跑次数)<ul>\n<li>运行用例失败重跑</li>\n</ul>\n</li>\n<li>-x<ul>\n<li>只要一个用例失败那么停止测试</li>\n</ul>\n</li>\n<li>–maxfail&#x3D;number<ul>\n<li>出现 number 次用例失败就停止测试</li>\n</ul>\n</li>\n<li>-k string<ul>\n<li>根据测试用例的部分字符串(string)指定</li>\n</ul>\n</li>\n<li>-rA<ul>\n<li>测试结果的简单统计</li>\n</ul>\n</li>\n<li>-m<ul>\n<li>指定被 <code>pytest.mark</code> 标记过的方法</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>编辑 pytest.ini 配置文件达到命令行运行的效果。配置好后 只需要 pytest 即可一键运行</p>\n<ul>\n<li>系统根目录下创建 pytest.ini 配置文件<ul>\n<li><code>touch pytest.ini</code></li>\n</ul>\n</li>\n<li>修改该文件编码格式为 ANSI 格式，创建好需要更改编码格式</li>\n<li>作用<ul>\n<li>改变 pytest 的默认行为，无需命令行输出冗余命令</li>\n</ul>\n</li>\n<li>运行规则<ul>\n<li>pytest 自动读取 pytest.ini 配置文件并按照配置文件规则执行</li>\n</ul>\n</li>\n<li>一些具体参数如下 pytest.ini  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">`[pytest]`</span><br><span class=\"line\">`#encoding = ANSI`</span><br><span class=\"line\"></span><br><span class=\"line\">`#命令行参数，用空格分隔`</span><br><span class=\"line\">`addopts = -vs` </span><br><span class=\"line\">`#测试用例的文件路径`</span><br><span class=\"line\">`testpaths = .`</span><br><span class=\"line\">`#配置测试搜素的 python 文件名称`</span><br><span class=\"line\">`python_files = test*.py</span><br><span class=\"line\">#配置测试搜索的测试类名</span><br><span class=\"line\">python_classes = Test*`</span><br><span class=\"line\">`#配置测试搜索的测试函数名`</span><br><span class=\"line\">`python_functions = test*`</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>pytest 装饰器解释</p>\n<ul>\n<li>有时候我们希望某个方法有专门的作用和不同的作用那么就可以采用 pytest装饰器修饰<ul>\n<li><p><code>@pytest.mark.yourname</code></p>\n<ul>\n<li>用该装饰器装饰的方法可以用 <code>pytest -m &quot;yourname&quot;</code>进行操作</li>\n<li>多个被 mark 过的方法 可以使用逻辑运算符and or not进行连接<ul>\n<li>如 <code>pytest -m &quot;first or second&quot;</code><ul>\n<li>表示 first 方法 和 second 方法都被执行</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><code>@pytest.mark.skip(reason=yourreasons)</code></p>\n<ul>\n<li>用该装饰器装饰的方法会被 pytest 无条件跳过</li>\n</ul>\n</li>\n<li><p><code>@pytest.mark.skipif(condition=yourcondition, reason=yourreasons)</code></p>\n<ul>\n<li>用该装饰器装饰的方法会被 pytest 判定:如果 condition 表达式为 True，则跳过该测试，反之则不跳过</li>\n</ul>\n</li>\n<li><p><code>@pytest.mark.run(order=number)</code></p>\n<ul>\n<li>用该装饰器装饰的方法会被 pytest 识别并依照 number 的值的顺序跑测试用例</li>\n</ul>\n</li>\n<li><p><code>@pytest.fixture(scope=scope, params=params, autouse=bool, ids=ids, name=name)</code></p>\n<ul>\n<li><p>用fixtrue标记的方法一般用于前置和后置处理，类似 setup &amp; teardown 的功能</p>\n</li>\n<li><p>其中 scope 参数有以下四个值:</p>\n<ul>\n<li>“function”<ul>\n<li>代表着作用于 方法</li>\n</ul>\n</li>\n<li>“class”<ul>\n<li>代表着作用于 类</li>\n</ul>\n</li>\n<li>“modules”<ul>\n<li>代表着作用于一个 python 文件</li>\n</ul>\n</li>\n<li>“sessions”<ul>\n<li>代表着作用于整个 pytest 测试流程</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>其中 autouse 参数有 True 和 False 两个 bool 值</p>\n<ul>\n<li>如果 autouse&#x3D;True，那么默认测试用例方法都会执行fixture，前提是在自己的scope里</li>\n</ul>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@pytest.fixture(<span class=\"params\">scope=<span class=\"string\">&quot;function&quot;</span>, autouse=<span class=\"literal\">True</span>, params=[(<span class=\"params\"><span class=\"string\">&quot;这是&quot;</span>, <span class=\"string\">&quot;first&quot;</span></span>), (<span class=\"params\"><span class=\"string\">&quot;这是&quot;</span>, <span class=\"string\">&quot;second&quot;</span></span>)]</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">sayhello</span>(<span class=\"params\">request</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;测试开始&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> request.param</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;测试结束&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestCase</span>:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @pytest.mark.run(<span class=\"params\">order=<span class=\"number\">3</span></span>)</span></span><br><span class=\"line\">    <span class=\"comment\"># @pytest.mark.first</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">test_number</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>如果 autouse&#x3D;Flase，那么测试用例方法参数需要添加 fixture 修饰的方法名字</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@pytest.fixture(<span class=\"params\">scope=<span class=\"string\">&quot;function&quot;</span>, autouse=<span class=\"literal\">False</span>, params=[(<span class=\"params\"><span class=\"string\">&quot;这是&quot;</span>, <span class=\"string\">&quot;first&quot;</span></span>), (<span class=\"params\"><span class=\"string\">&quot;这是&quot;</span>, <span class=\"string\">&quot;second&quot;</span></span>)]</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">sayhello</span>(<span class=\"params\">request</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">​    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;测试开始&quot;</span>)</span><br><span class=\"line\">​    <span class=\"keyword\">yield</span> request.param</span><br><span class=\"line\">​    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;测试结束&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestCase</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">​    @pytest.mark.run(order=<span class=\"number\">3</span>)</span><br><span class=\"line\">​    \\<span class=\"comment\"># @pytest.mark.first</span></span><br><span class=\"line\">​    <span class=\"keyword\">def</span> <span class=\"title function_\">test_number</span>(<span class=\"params\">self, sayhello</span>):</span><br><span class=\"line\">​        <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>其中 params 参数控制着传参</p>\n<ul>\n<li><code>params=[(&quot;这是&quot;, &quot;first&quot;), (&quot;这是&quot;, &quot;second&quot;)]</code></li>\n<li>其中 params 可以等于一个 列表或字典，或者 字典列表与元祖列表</li>\n<li>如果要获得 params 的参数，则fxiture修饰的方法需要添加固定的 request 参数，且返回request.param 用于测试方法接受</li>\n<li>如果测试方法要接收 params 参数，即时autouse&#x3D;True，也要在测试方法参数上添加需要的fixture方法名<ul>\n<li>未加方法名结果<ul>\n<li><img src=\"/./images/python/pytest/2.png\"></li>\n</ul>\n</li>\n<li>添加方法名结果<ul>\n<li><img src=\"/./images/python/pytest/3.png\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>使用方法</p>\n<ul>\n<li><p>借助python yeild 生成器控制前置和后置输出</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@pytest.fixture(<span class=\"params\">scope=<span class=\"string\">&quot;function&quot;</span>, autouse=<span class=\"literal\">True</span>, params=[(<span class=\"params\"><span class=\"string\">&quot;这是&quot;</span>, <span class=\"string\">&quot;first&quot;</span></span>), (<span class=\"params\"><span class=\"string\">&quot;这是&quot;</span>, <span class=\"string\">&quot;second&quot;</span></span>)]</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">sayhello</span>(<span class=\"params\">request</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">​    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;测试开始&quot;</span>)</span><br><span class=\"line\">​    <span class=\"keyword\">yield</span> request.param</span><br><span class=\"line\">​    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;测试结束&quot;</span>)</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>实际使用</p>\n<ul>\n<li>一般情况下 pytest 有一个机制:即把 fixture 集中放入一个名叫 conftest.py 的文件下，pytest会自动识别该文件并作出相应的响应</li>\n<li>作用域<ul>\n<li>该文件可以存放在任何目录下</li>\n<li>只对当前目录及当前路径以下的目录下起作用<ul>\n<li><img src=\"/./images/python/pytest/4.png\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><code>@pytest.mark.parametrize(argsname，argsvalues)</code></p>\n<ul>\n<li><p>用该装饰器修饰的方法可以进行参数化</p>\n</li>\n<li><p>argsname 代表着参数名，argsvalues代表参数值</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pytest</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestCase2</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">​    @pytest.mark.parametrize(argnames=<span class=\"string\">&quot;a&quot;</span>, argvalues=[<span class=\"string\">&quot;FIRST&quot;</span>, <span class=\"string\">&quot;SECOND&quot;</span>])</span><br><span class=\"line\">​    <span class=\"keyword\">def</span> <span class=\"title function_\">test_number</span>(<span class=\"params\">self, a: <span class=\"built_in\">list</span></span>):</span><br><span class=\"line\">​        <span class=\"built_in\">print</span>(a)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>结果</p>\n<ul>\n<li><img src=\"/./images/python/pytest/5.png\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["python"]},{"title":"Python 虚拟环境 venv 的创建","url":"/2022/12/05/python/python-venv/","content":"<ul>\n<li>python 项目为了类似 docker 一样隔离提供 venv 虚拟环境</li>\n<li>使用方法<ul>\n<li><code>python -m venv【params】venvpath</code></li>\n<li>venv 参数如下</li>\n<li><img src=\"/./images/python/venv/1.png\"></li>\n<li>一般来说只需要<ul>\n<li><code>python -m venv --upgrade-deps venvpath</code></li>\n<li>除非需要之前的一些 site-package 否则不加 <code>--system-site-package</code></li>\n<li>建议加上 <code>--upgrade-deps</code><ul>\n<li>这样无需手动更新 pip 造成无权限问题而导致原来的 pip 被删除</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>安装好以后可以打开 Scripts&#x2F; 目录下的 <code>activate.bat</code> 批处理文件进入虚拟环境<ul>\n<li>activate</li>\n<li><img src=\"/./images/python/venv/2.png\"></li>\n<li>也可以在 git-bash 里用 source 命令执行<ul>\n<li><img src=\"/./images/python/venv/3.png\"></li>\n</ul>\n</li>\n<li>可以用 pip list 查看包情况判断是否进入 python 虚拟环境</li>\n</ul>\n</li>\n<li>如何退出<ul>\n<li>同样在虚环境里执行 deactivate.bat <ul>\n<li><img src=\"/./images/python/venv/4.png\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>pycharm 新建项目如何使用虚拟环境<ul>\n<li>只需新建项目里配置虚拟环境解释器路径</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["python"]},{"title":"python 运算符","url":"/2022/12/05/python/python%E8%BF%90%E7%AE%97%E7%AC%A6/","content":"<ul>\n<li>python 运算符分为 算术运算符、赋值运算符、布尔运算符、比较运算符、位运算符<ul>\n<li><p>算术运算符分为 标准运算符、取余运算符、幂运算符</p>\n<ul>\n<li><p>算术运算符满足以下规则</p>\n<ul>\n<li><img src=\"/./images/python/operator/1.png\"></li>\n</ul>\n</li>\n<li><p>标准运算符</p>\n<ul>\n<li><blockquote>\n<p>+ -  *  &#x2F;  &#x2F;&#x2F;</p>\n</blockquote>\n</li>\n<li><p>其中为整除运算符，若两者异号，则向下取整</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    value1 = <span class=\"number\">20</span>/-<span class=\"number\">3</span></span><br><span class=\"line\">    value2 = <span class=\"number\">20</span>//-<span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回<ul>\n<li><img src=\"/./images/python/operator/2.png\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>% 为取余运算符。规则是同号则直接取余数。异号余数 &#x3D; 被除数 - 除数*商</p>\n<ul>\n<li><p>其中以上的 商 为两者整除而来 如  -20%3的商为 -20&#x2F;&#x2F;3</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    value1 = -<span class=\"number\">20</span>%-<span class=\"number\">3</span></span><br><span class=\"line\">    value2 = -<span class=\"number\">20</span>%<span class=\"number\">3</span></span><br><span class=\"line\">    value3 = <span class=\"number\">20</span>%-<span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value2)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value3)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>返回</p>\n<ul>\n<li><img src=\"/./images/python/operator/3.png\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>为幂运算符，a</strong>b 表示 a 的 b 次 幂</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    value1 = -<span class=\"number\">2</span>**<span class=\"number\">3</span></span><br><span class=\"line\">    value2 = -<span class=\"number\">2</span>**-<span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>返回<ul>\n<li><img src=\"/./images/python/operator/4.png\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>赋值运算符</p>\n<ul>\n<li>&#x3D; 即为赋值运算符。<ul>\n<li><p>执行顺序为 从右往左 a&#x3D;b&#x3D;c&#x3D;1</p>\n</li>\n<li><p>支持参数赋值 a +&#x3D; b，a &#x2F;&#x2F;&#x3D; b …..</p>\n</li>\n<li><p>支持系列解包赋值 a，b &#x3D; b， a，常用于交换两者的值</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    value1 = <span class=\"number\">1</span></span><br><span class=\"line\">    value2 = <span class=\"number\">2</span></span><br><span class=\"line\">    value1, value2 = value2, value1</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value1)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value2)</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>返回<ul>\n<li><img src=\"/./images/python/operator/5.png\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>比较运算符</p>\n<ul>\n<li><blockquote>\n<p>&gt;，&lt;， &gt;&#x3D;，&lt;&#x3D;，!&#x3D;，&#x3D;&#x3D;</p>\n</blockquote>\n<ul>\n<li>返回值为 bool 类型，比较的是两者的 _value 值</li>\n</ul>\n</li>\n<li><p>is ，is not。is 代表 是 id 相等，is not 代表 id 不相等</p>\n<ul>\n<li><p>返回值为 bool 类型，比较的是两者的 id 值</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    value1 = <span class=\"number\">1</span></span><br><span class=\"line\">    value2 = <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value1 == value2)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;-----------------------&quot;</span>)</span><br><span class=\"line\">    value3 = [<span class=\"number\">1</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>]]</span><br><span class=\"line\">    value4 = [<span class=\"number\">1</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>]]</span><br><span class=\"line\">    value5 = value3</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">id</span>(value3), <span class=\"built_in\">id</span>(value4), <span class=\"built_in\">id</span>(value5))</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;-----------------------&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value3 <span class=\"keyword\">is</span> value4)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value3 <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> value5)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(value4 <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> value5)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>返回</p>\n<ul>\n<li><img src=\"/./images/python/operator/6.png\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>bool 运算符</p>\n<ul>\n<li>python 一切对象都有对应的 bool 值<ul>\n<li><img src=\"/./images/python/operator/7.png\"></li>\n</ul>\n</li>\n<li>and ，or，not，in，not in （其中 in， not in 表示是否在序列中）<ul>\n<li><p>其中 and 和 or 拥有短路性。即 a and b a为false，b不再进行。同理 a or b，a为真 b不再进行</p>\n</li>\n<li><p>m &#x3D; [1, 2, 3]</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test1</span>():</span><br><span class=\"line\">    m.clear()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(m)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test2</span>():</span><br><span class=\"line\">    m.append(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(m)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test_bool</span>():</span><br><span class=\"line\">    a = <span class=\"literal\">True</span></span><br><span class=\"line\">    b = <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(b <span class=\"keyword\">and</span> test1())</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a <span class=\"keyword\">or</span> test2())</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test_bool()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>返回</p>\n<ul>\n<li><img src=\"/./images/python/operator/8.png\"></li>\n</ul>\n</li>\n<li><p>注意 a and b 其中 a，b不一定是bool 类型。a and b 返回值也不一定是 bool 类型</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"literal\">None</span> <span class=\"keyword\">and</span> <span class=\"number\">5</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"number\">1</span> <span class=\"keyword\">and</span> <span class=\"string\">&#x27;hello&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"literal\">None</span> <span class=\"keyword\">or</span> <span class=\"literal\">None</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;hello&quot;</span> <span class=\"keyword\">or</span> <span class=\"literal\">None</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回<ul>\n<li><img src=\"/./images/python/operator/9.png\"></li>\n</ul>\n</li>\n<li>实际中不确定 a，b 类型情况下想返回 bool 类型建议 bool(a) and bool(b) 这样能确定100%返回 bool 类型</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>位运算符</p>\n<ul>\n<li><p>&amp; 按位与。| 按位或。&gt;&gt; 按位右移。&lt;&lt;按位左移。^为异或。~为按位取反</p>\n</li>\n<li><p>以下为运算规则</p>\n<ul>\n<li><img src=\"/./images/python/operator/10.png\"></li>\n</ul>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"number\">3</span> &amp; <span class=\"number\">6</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"number\">3</span> | <span class=\"number\">6</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"number\">3</span> &gt;&gt; <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"number\">3</span> &lt;&lt; <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>返回</p>\n<ul>\n<li><img src=\"/./images/python/operator/11.png\"></li>\n</ul>\n</li>\n<li><p>注意，参与运算要按照补码进行计算</p>\n<ul>\n<li>原码，反码，补码规则如下<ul>\n<li>正数<ul>\n<li>原码，反码，补码相同。符号位都为0</li>\n</ul>\n</li>\n<li>负数<ul>\n<li>原码符号位为1.反码是符号位不变，其余按位取反。补码是反码 + 1</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>根据以上规则我们可以计算出负数的 按位与 和 按位或</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(-<span class=\"number\">3</span> &amp; -<span class=\"number\">6</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(-<span class=\"number\">3</span> | -<span class=\"number\">6</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(-<span class=\"number\">3</span> &gt;&gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(-<span class=\"number\">3</span> &lt;&lt; <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回<ul>\n<li><img src=\"/./images/python/operator/12.png\"></li>\n</ul>\n</li>\n<li>验算<ul>\n<li><img src=\"/./images/python/operator/13.png\"></li>\n<li>同理可以算出其他值。<ul>\n<li>注意移位运算符符号位补位为当前符号。即符号位永远保持同号</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>~ 按位取反</p>\n<ul>\n<li><p>值得注意的是按位取反符号位要参与</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(~-<span class=\"number\">3</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(~<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>返回</p>\n<ul>\n<li><img src=\"/./images/python/operator/14.png\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>^异或</p>\n<ul>\n<li><p>即A^B &#x3D; （A and !B）or (!A and B)</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"number\">5</span> ^ -<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    test()</span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>返回</p>\n<ul>\n<li><img src=\"/./images/python/operator/15.png\"></li>\n</ul>\n</li>\n<li><p>异或可以不借助第三方参数进行交换值</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">exchange</span>(<span class=\"params\">a, b</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a, b)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;-----------------&quot;</span>)</span><br><span class=\"line\">    a = a ^ b</span><br><span class=\"line\">    b = a ^ b</span><br><span class=\"line\">    a = a ^ b</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a, b)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    exchange(<span class=\"number\">6</span>, <span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>返回<ul>\n<li><img src=\"/./images/python/operator/16.png\"></li>\n<li><img src=\"/./images/python/operator/17.png\"></li>\n</ul>\n</li>\n<li>证明</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>运算符优先级参考如下：</p>\n<ul>\n<li><img src=\"/./images/python/operator/18.png\"></li>\n<li>python3 官方参考<ul>\n<li><img src=\"/./images/python/operator/19.png\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["python"]}]