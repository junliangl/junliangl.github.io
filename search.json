[{"title":"python 基本数据类型常用方法","url":"/2022/12/07/python/python 基本数据类型常用方法/","content":"\n- 参考链接\n\n  - 以下数据类型有些内容会涉及内存驻留机制，请参考\n    \n    [Python 驻留机制](https://quip.com/f16qAxQw5oKt)\n    \n  - https://www.cnblogs.com/laizhenghua/articles/12875044.html\n\n- 基本数据类型是 python 操作的重点，经常遗忘，在此写下\n\n- 基本数据类型有 数字类型（int，float，complex），字符串类型（str），列表类型（list）元组（tuple），字典（dict），集合（set）\n\n- <!-- more -->\n\n- 数字类型--->不可变类型\n\n  - pass\n\n- 字符串类型--->不可变类型::这代表着以下方法如若修改列表，str 的 id(str) 值会更改，与 list不同。\n\n  - 字符串具体操作方法请参考\n\n    - [Python 字符串常用方法介绍](https://quip.com/ppriAWQACObt)\n\n  - 切片\n\n    - `str[n]` 表示正数获取字符串的元素，表示从左往右数第 n+1 个元素:\n\n      ```python\n      def test():`\n          `test_str = \"junliangl\"`\n          `print(test_str[3])`\n      \n      `if __name__ == '__main__':`\n          `test()`\n      ```\n\n    - 输出\n\n      ![](./images/python/data-type/1.png)\n\n    - `str[-n]` 表示负数获取字符串的元素，表示从右往左数第 n 个元素\n\n      ```python\n      def test():\n          test_str = \"junliangl\"\n          print(test_str[-2])\n      \n      if __name__ == '__main__':\n          test()\n      ```\n\n    - 输出\n\n      ![](./images/python/data-type/2.png)\n\n    - str[m:n] 表示从 m+1 取到第 n 的元素，不包含第 n 个元素（左闭右开原则）。如果截取不到，那么则返回空串 `\"\"`\n\n      ```python\n      def test():\n          test_str = \"junliangl\"\n          print(test_str[0:0])\n          print(test_str[0:1])\n          print(test_str[2:5])\n      \n      if __name__ == '__main__':\n          test()\n      ```\n\n    - 输出\n\n      ![](./images/python/data-type/3.png)\n\n      - str[:n] 表示取第 1 个 到第 n 的元素，不包含第 n 个元素；str[n:] 表示取第 n+1 个 到最后一个元素\n\n        ```python\n        def test():\n            test_str = \"junliangl\"\n            print(test_str[:-2])\n            print(test_str[2:])\n            print(test_str[:-10])\n        \n        if __name__ == '__main__':\n            test()\n        ```\n\n    - 输出\n\n      ![](./images/python/data-type/4.png)\n\n    - str[a : b : c] \n\n      - 如果 c 不写或者为正，则按照正方向截取。就代表着 a < b，否则返回空串\n\n        ```python\n        def test():\n            test_str = \"junliangl\"\n            “print(test_str[2:6:])\n            print(test_str[6:2:3])\n        \n        if __name__ == '__main__':\n            test()\n        ```\n\n      - 输出\n\n        ![](./images/python/data-type/5.png)\n\n        - 如果 c 为负，则按照反方向截取。就代表着 a > b ，否则返回空串\n\n          ```python\n          def test():\n              test_str = \"junliangl\"\n              print(test_str[8:4:-3])\n              print(test_str[-2:-7:-2])\n              print(test_str[-6 : -1 : -1])\n          \n          if __name__ == '__main__':\n              test()\n          ```\n\n      - 输出\n\n        ![](./images/python/data-type/6.png)\n\n\n      - 应用\n        - `str[::-1]`\n          - 直接表示字符串反串\n\n\n  - `len() `方法求字符串长度\n\n    ```python\n    def test():\n        test_str = \"junliangl\"\n        print(len(test_str))\n    \n    \n    if __name__ == '__main__':\n        test()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/7.png)\n\n  - `lower()` 与 `upper() `表示字符串字母全变为小写和大写\n\n    ```python\n    def test():\n        test_str = \"JUNliangL\"\n        print(test_str.lower())\n        print(test_str.upper())\n    \n    \n    if __name__ == '__main__':\n        test()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/8.png)\n\n  - `startwith(str)` 和 `endwith(str)` 表示是否以某一子串开始或结尾\n\n    ```python\n    def test():\n        test_str = \"JUNliangL\"\n        print(test_str.startswith(\"JUN\"))\n        print(test_str.endswith(\"GL\"))\n    \n    if __name__ == '__main__':\n        test()\n    ```\n\n    - 输出\n\n      ![](./images/python/data-type/9.png)\n\n  - `join(s) `方法表示以指定字符串结合\n\n    ```python\n    def test():\n        test_str = \"----\"\n        print(test_str.join(\"1234\"))\n        print(test_str.join([\"1\", \"2\", \"3\", \"4\"]))\n    \n    \n    if __name__ == '__main__':\n        test()\n    ```\n\n    - 输出\n\n      ![](./images/python/data-type/10.png)\n\n  - `replace(old_str，new_str，count)` 表示把 old_str 子串替换成 new_str ，count是替换数量，默认值是替换全部\n\n    ```python\n    def test():\n        old_test_str = \"junliangl bad bad bad\"\n        print(old_test_str)\n        print(id(old_test_str))\n        print(\"----------------\")\n        new_test_str = old_test_str.replace(\"bad\", \"good\")\n        print(new_test_str)\n        print(id(new_test_str))\n        print(\"----------------\")\n        print(new_test_str.replace(\"good\", \"bad\", 2))\n    \n    \n    if __name__ == '__main__':\n        test()\n    ```\n\n    - 输出\n\n      ![](./images/python/data-type/11.png)\n\n    - 很明显看出 replace() 方法不改变原来的字符串，创建了一个新的对象指向不同的字符串常量。\n\n  - `count(str，start，end)` 表示计算 str 子串在原来字符串中出现的次数。start 和 end 控制返回，默认值则代表整个字符串范围\n\n    ```python\n    def test():\n        test_str = \"junliangl bad bad bad good good\"\n        print(test_str.count(\"bad\", 9, 13))\n        print(test_str.count(\"good\"))\n        print(test_str.count(\"bad\"))\n    \n    \n    if __name__ == '__main__':\n        test()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/12.png)\n\n  - `split(str，count) `表示当前字符串以什么子串分隔，返回值为一个字符串列表 list。count 表示分隔几次，默认值是全部。没有子串则返回字符串列表\n\n    ```python\n    def test():\n        test_str = \"junliangl bad bad bad good good\"\n        print(test_str.split(\" \"))\n        test_str = \"junliangl,bad,bad,bad,good,good\"\n        print(test_str.split(\",\", 2))\n        test_str = \"junliangl,bad,bad,bad,good,good\"\n        print(test_str.split(\".\"))\n    \n    \n    if __name__ == '__main__':\n        test()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/13.png)\n\n  - `strip(str) `表示当前字符串去除以 str 子串开头和结尾。默认参数则去除首尾的空白字符(空格、\\n、\\t)\n\n    ```python\n    def test():\n        old_test_str = \"123 junliangl 123\"\n        print(id(old_test_str))\n        print(old_test_str)\n        print(\"-----------------\")\n        new_test_str = old_test_str.strip(\"123\")\n        print(old_test_str)\n        print(id(new_test_str))\n        print(new_test_str)\n        print(new_test_str.strip())\n    \n    \n    if __name__ == '__main__':\n        test()\n    ```\n\n    - 输出\n\n      ![](./images/python/data-type/14.png)\n\n    - 很明显看出 strip() 方法不改变原来的字符串，创建了一个新的对象指向不同的字符串常量。\n\n  - `isdigit()` 表示如果字符串只包含数字，是则返回 True，否则返回 False\n\n    ```python\n    def test():\n        test1_str = \"junliangl 123\"\n        test2_str = \"123\"\n        print(test1_str.isdigit())\n        print(test2_str.isdigit())\n    \n    \n    if __name__ == '__main__':\n        test()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/15.png)\n\n  - `encode(encoding=)`对字符串进行编码，encoding填写编码格式。`decode(encoding=)`对字符串解码\n\n    ```python\n    def test_str():\n        str_test = \"测试\"\n        encode = str_test.encode(encoding=\"GBK\")\n        print(encode)\n        new_str = encode.decode(encoding=\"GBK\")\n        print(new_str)\n        print(b'\\xb2\\xe2\\xc6\\xd4'.decode(encoding=\"GBK\"))\n    \n    \n    if __name__ == '__main__':\n        test_str()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/16.png)\n\n- 列表类型--->可变类型:这代表着以下方法如若修改列表，列表的 id(list)值不变，与 str 类型不同\n\n  - `list[n] `索引取值遵循字符串规则\n\n    ```python\n    def test():\n        test_list = ['junliangl', 1, [1, 2]]\n        print(test_list[0])\n        print(test_list[-1])\n    \n    \n    if __name__ == '__main__':\n        test()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/17.png)\n\n  - `list[a:b:c] `切片类似 str \n\n    ```python\n    def test():\n        test_list = ['junliangl', 1, [1, 2], 'best', 'good']\n        print(test_list[:3])\n        print(test_list[3:])\n        print(test_list[:-3])\n        print(test_list[-3:])\n        print(test_list[1:-2])\n        print(test_list[1:4:1])\n        print(test_list[-2:-4:-1])\n    \n    \n    if __name__ == '__main__':\n        test()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/18.png)\n\n  - `len(list) `代表列表长度\n\n    ```python\n    def test():\n        test_list = ['junliangl', 'best', 'good']\n        print(len(test_list))\n    \n    \n    if __name__ == '__main__':\n        test()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/19.png)\n\n  - `append(s) `代表往列表末尾追加一个元素 s。改变列表后，列表地址不变，以下的方法同理\n\n    ```python\n    def test():\n        test_list = ['1', '2', '3']\n        print(id(test_list))\n        test_list.append('4')\n        print(id(test_list))\n        print(test_list)\n    \n    \n    if __name__ == '__main__':\n        test()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/20.png)\n\n  - `insert(index，obj)` 表示往当前列表 index 处替换为 obj，其他元素后移。若 index >= len(list)，则在末尾处添加；若 index <= -len(list)，则在首部添加。\n\n    ```python\n    def test():\n        test1_list = ['1', '2', '3']\n        test2_list = [1, 2, 3]\n        test1_list.insert(-1, '4')\n        print(test1_list)\n        test2_list.insert(2, 4)\n        print(test2_list)\n        test1_list.insert(100, '5')\n        print(test1_list)\n        test2_list.insert(-100, 5)\n        print(test2_list)\n    \n        \n    if __name__ == '__main__':\n        test()\n    ```\n\n    - 输出\n\n      ![](./images/python/data-type/21.png)\n\n  - `extend(iterable)` 表示往当前列表末尾添加一个序列而不是序列本身\n\n    ```python\n    def test():\n        test1_list = ['1', '2', '3']\n        test2_list = [1, 2, 3]\n        test1_list.append(test2_list)\n        print(test1_list)\n        test1_list = ['1', '2', '3']\n        test1_list.extend(test2_list)\n        print(test1_list)\n    \t\n    \n    if __name__ == '__main__':\n        test()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/22.png)\n\n  - `del(list[a:b:c])` 表示删除列表选择的元素\n\n    ```python\n    def test():\n        test_list = ['1', '2', '3', '4', '5']\n        del test_list[-1::-2]\n        print(test_list)\n    \n    \n    if __name__ == '__main__':\n        test()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/23.png)\n\n  - `pop(index)` 表示按照 index 删除，默认值为删除末尾的元素\n\n    ```python\n    def test():\n        test_list = ['1', '2', '3', '4', '5']\n        test_list.pop(-2)\n        print(test_list)\n        test_list.pop()\n        print(test_list)\n    \n    \n    if __name__ == '__main__':\n        test()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/24.png)\n\n  - `remove(obj)` 表示按照元素对象删除，默认删除寻找到的第一个元素\n\n    ```python\n    def test():\n        test_list = ['1', '2', '3', '4', '1']\n        test_list.remove('1')\n        print(test_list)\n    \n    if __name__ == '__main__':\n        test()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/25.png)\n\n  - `count(obj, start, end)` 统计某个元素在当前列表出现的次数\n\n    ```python\n    def test():\n        test_list = [1, 2, 3, 2, 3, 3]\n        print(test_list.count(2))\n        print(test_list.count(3))\n    \n    \n    if __name__ == '__main__':\n        test()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/26.png)\n\n  - `index(obj，start，end)` 表示从 `list[start] --- list[end]` 之间的 obj 出现在 list 的第一个索引值， 找不到的话抛出 `ValueError`\n\n    ```python\n    def test():\n        test_list = [1, 2, 3, 4, 5, 6]\n        try:\n            print(test_list.index(5, 1, 3))\n        except ValueError as v:\n            print(v)\n        print(test_list.index(4, 0, 5))\n    \n    \n    if __name__ == '__main__':\n        test()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/27.png)\n\n  - `clear() `表示清空列表中的元素\n\n    ```python\n    def test():\n        test_list = [1, [1, 2], 3]\n        test_list[1].clear()\n        print(test_list)\n        test_list.clear()\n        print(test_list)\n    \n    if __name__ == '__main__':\n        test()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/28.png)\n\n  - `reverse() `表示反转列表中的元素等价 `list[::-1]`\n\n    ```python\n    def test():\n        test_list = [1, [1, 2], 3]\n        test_list[1].reverse()\n        print(test_list)\n        test_list.reverse()\n        print(test_list)\n    \n    \n    if __name__ == '__main__':\n        test()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/29.png)\n\n  - `sort() `表示对列表进行排序，要保持类型一致，否则会报错\n\n    ```python\n    def test():\n        test1_list = [2, 3, 51, 10, 9]\n        test2_list = [12, '']\n        test1_list.sort()\n        print(test1_list)\n        try:\n            test2_list.sort()\n            print(test2_list)\n        except TypeError as t:\n            print(t)\n    \n    if __name__ == '__main__':\n        test()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/30.png)\n\n  - 关于 list 的拷贝\n\n    - 参考链接\n\n      - [Python 内存详解](https://quip.com/VkfeAXOaYK07)关于python的列表的内存机制\n\n    - 分为赋值拷贝，浅拷贝和深拷贝\n\n    - 赋值拷贝，直接将对象(地址)赋值传递给新的对象。这样更改原来的元素都会影响赋值拷贝后的列表\n\n      ```python\n      def test():\n          test1_list = [1, [1, 2], [3, 4]]\n          test2_list = test1_list\n          print(id(test1_list))\n          print(test1_list)\n          print(\"---------------------\")\n          print(id(test2_list))\n          print(test2_list)\n          print(\"---------------------\")\n          test1_list[1][0] = 10000\n          print(test1_list)\n          print(test2_list)\n      \n      if __name__ == '__main__':\n          test()\n      ```\n\n      - 返回\n\n        ![](./images/python/data-type/31.png)\n\n    - 浅拷贝。浅拷贝即未对所有层的内容进行拷贝，即其中包含赋值拷贝，即使他们的 id 值不一样。以下有几种使用方式\n\n      - `for`循环依次赋值\n\n        ```python\n        def test():\n            old = [1, [1, 2, 3], 3]\n            new = []\n            for i in range(len(old)):\n                new.append(old[i])\n            print(id(old))\n            print(old)\n            print(\"---------------------\")\n            print(id(new))\n            print(new)\n            new[0] = 3\n            new[1][0] = 3\n            print(\"---------------------\")\n            print(old)\n            print(new)\n        \n        if __name__ == '__main__':\n            test()\n        ```\n\n        - 返回\n\n          ![](./images/python/data-type/32.png)\n\n      - 使用`copy()` 方法\n\n        ```python\n        def test():\n            old = [1, [1, 2, 3], 3]\n            new = old.copy()\n            print(id(old))\n            print(old)\n            print(\"---------------------\")\n            print(id(new))\n            print(new)\n            new[0] = 3\n            new[1][0] = 3\n            print(\"---------------------\")\n            print(old)\n            print(new)\n        \n        if __name__ == '__main__':\n            test()\n        ```\n\n        - 返回\n\n          ![](./images/python/data-type/33.png)\n\n\n      - 使用切片\n    \n        ```python\n        def test():\n            old = [1, [1, 2, 3], 3]\n            new = old[:]\n            print(id(old))\n            print(old)\n            print(\"---------------------\")\n            print(id(new))\n            print(new)\n            new[0] = 3\n            new[1][0] = 3\n            print(\"---------------------\")\n            print(old)\n            print(new)\n        \n        if __name__ == '__main__':\n            test()\n        ```\n    \n        - 返回\n    \n          ![](./images/python/data-type/34.png)\n    \n      - 直接等值传递\n    \n        ```python\n        def test():\n            old = [1, [1, 2, 3], 3]\n            new = [1, [1, 2, 3], 3]\n            print(id(old))\n            print(old)\n            print(\"---------------------\")\n            print(id(new))\n            print(new)\n            new[0] = 3\n            new[1][0] = 3\n            print(\"---------------------\")\n            print(old)\n            print(new)\n        \n        if __name__ == '__main__':\n            test()\n        ```\n    \n        - 返回\n    \n          ![](./images/python/data-type/35.png)\n    \n    - 深拷贝，即创建与原对象完全无关的对象。需导入 copy 模块\n    \n      ```python\n      import copy\n      \n      def test():\n          old = [1, [1, 2, 3], 3]\n          new = copy.deepcopy(old)\n          print(id(old))\n          print(old)\n          print(\"---------------------\")\n          print(id(new))\n          print(new)\n          new[0] = 3\n          new[1][0] = 3\n          print(\"---------------------\")\n          print(old)\n          print(new)\n      \n      if __name__ == '__main__':\n          test()\n      ```\n    \n      - 返回\n    \n        ![](./images/python/data-type/36.png)\n\n- 元组类型--->不可变类型:元组相当于不可变的列表(为 id 值 无法变，但是对于列表元组等，可以更改里面的值)\n\n  ```python\n  def test():\n      test_tuple = (1, [1, 2])\n      print(test_tuple)\n      try:\n          test_tuple[0] = 2\n      except TypeError as t:\n          print(t)\n      try:\n          test_tuple[1][1] = 10000\n      except TypeError as t:\n          print(t)\n      print(test_tuple)\n  \n  if __name__ == '__main__':\n      test()\n  ```\n\n  - 返回\n\n    ![](./images/python/data-type/37.png)\n\n  - 元组类型转换\n\n    - `tuple(obj)` obj 只要为可迭代类型都能转换。对于 dict 类型转换只转换 key 值\n\n      ```python\n      def test():\n          test1_tuple = tuple(\"junliangl\")\n          print(test1_tuple)\n          test2_tuple = tuple({\"first\": 1, \"second\": 2})\n          print(test2_tuple)\n      \n      if __name__ == '__main__':\n          test()\n      ```\n\n      - 返回\n\n        ![](./images/python/data-type/38.png)\n\n    - `tuple[a:b:c] `切片，索引。和 list 一致 \n\n      `pass`\n\n    - `len(tuple)` 和 list 一致\n\n      `pass`\n\n    - `index(obj, start, end)` 和列表一致\n\n      `pass`\n\n    - `count(obj, start, end)`和列表一致\n\n      `pass`\n\n- 字典类型--->可变类型:这代表着以下方法如若修改字典，字典的 id(dict)值不变，与 str 类型不同\n\n  - 参考链接\n\n    - https://www.cnblogs.com/wakey/p/16246920.html\n    - https://blog.csdn.net/weixin_45228198/article/details/112771784\n\n  - 字典底层采用 hash表（散列表）的形式存储数据。内存形式如下\n\n    ![](./images/python/data-type/39.png)\n\n    - \\1. 插入数据\n      - d[\"name\"]=\"jack\"\n      - 首先对键- -“name”计算哈希值，然后对当前C数组arr的长度求余\n      - 得到一个索引值，假如为5，则将当前的（哈希值，键，值）作为一个整体存入arr[5]\n    - 2.哈希碰撞\n      - 当插入的键，经过哈希计算，求余后若得到与之前一样的索引，比如5\n      - 因此索引处已经存有数据，无法再次存入，那么就将当前的索引+ 一个偏移量\n      - 重新计算索引位置，然后存入数据，这在python中为开放地址法\n    - \\3. 扩容（可变）\n      - 当存入的数据超过总长度的2/3时，字典会成倍扩容，对旧数据根据新数组长度计算索引，重新存入\n    - 4.更新值\n      - d[\"name\"]=\"tom\"\n      - 首先计算键- \"name\"的哈希值，然后对当前数组总长度求余，得到索引，若索引\n      - 对应位置的数据的键==“name”，则更新它的值\n    - 5.删除\n    - - del d[\"name\"]\n      - 计算当前键- \"name\" 的哈希值，求余，找到索引，删除数据，仍保持探测链\n      - 标记此处有过数据\n    - 优缺点\n      - 列表：遍历所有数据，一个一个的比较，数据量大时，时间复杂度高\n        字典：对要查找的键，计算哈希值，求余运算得到索引，一步到位，查找效率高。内存消耗极大，属于空间换取时间\n      - 注意：遍历字典时添加新建可能导致字典底层数组扩容，导致散列链发生变化，因此一般不要对字典遍历的同时进行修改\n\n  - 具体过程如下：\n\n    - 键值的存储过程\n      - 首先要计算data[\"name\"]的散列值\n      - 得到hash值后，我们从hash值最右边3位数字作为偏离量，即0b1xxxx000111101\n      - 我们查看偏移量\"101\" 对应的bucket是否为空，如果为空，则将键值对放进去\n      - 如果不为空，则依次去右边3位作为偏离量，即0b1xxxx000111101\n      - 再看偏离量\"111\" 对应的bucket是否为空，直到找到为空的bucket将键值对放进去。\n      - ![](./images/python/data-type/40.png)\n\n    - 字典查找值的过程\n      - 我们要计算data[\"name\"] 里面的\"name\"对象\n      - 确定偏离量，散列值的最右边3位数字作为偏离量 0b1xxxx000111101\n      - 查看偏离量\"101\"对应的bucket是否为空，如果为空，则返回None\n      - 如果不为空，则将这个bucket的键对象计算出对应的散列值和data[\"name\"]的\"name\"散列值进行比较，如果两个散列值相等，则将对应数组里的值对象返回，如果不相等，则再依次向前取3个【偏移量，如0b1xxxx000111101。依次取完，仍然没有找到，则返回None\n      - ![](./images/python/data-type/41.png)\n\n  - 字典的 key 必须是可散列的 数字类型，字符串类型，元组类型。如若是其他类型，则会报错\n\n    ```python\n    def test_dict():\n        a = {(1, 2): 1}\n        print(a)\n        try:\n            b = {[1, 2]: 1}\n            print(b)\n        except TypeError as t:\n            print(t)\n    \n    if __name__ == '__main__':\n        test_dict()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/42.png)\n\n  - 字典赋值\n\n    - `dict[key] = value`\n\n      ```python\n      def test_dict():\n          dict_test = {}\n          list_test = [[\"first\", \"value1\"], [\"second\", \"value2\"], [\"third\", \"value3\"]]\n          for i in list_test:\n              dict_test[i[0]] = i[1]\n          print(dict_test)\n      \n      if __name__ == '__main__':\n          test_dict()\n      ```\n\n      - 返回\n\n        ![](./images/python/data-type/43.png)\n\n    - 针对赋值操作，key 存在则修改，key 不存在则新增。所以字典里的 key 必须唯一\n\n  - `fromkeys(obj，value)` 表示遍历序列 obj 作为新 dict 的 key，value 整体作为 value\n\n    ```python\n    def test_dict():\n        dict_test1 = {}\n        dict_test2 = dict_test1.fromkeys((1, 2), 3)\n        print(dict_test1)\n        print(dict_test2)\n        dict_test3 = dict_test1.fromkeys([\"first\", \"second\"], [\"value1\", \"value2\"])\n        print(dict_test3)\n    \n    if __name__ == '__main__':\n        test_dict()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/44.png)\n\n  - `pop(key)` 方法代表删除，返回被删除的 value\n\n    ```python\n    def test_dict():\n        dict_test = {\"key\": \"value\", 5: 3}\n        value = dict_test.pop(\"key\")\n        print(value)\n        print(dict_test)\n    \n    if __name__ == '__main__':\n        test_dict()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/45.png)\n\n  - `popitem()` 后进先出原则删除字典最后添加的 key-value 对\n\n    ```python\n    def test_dict():\n        dict_test1 = {\"key\": \"value\", 5: 3}\n        print(dict_test1.popitem())\n        print(dict_test1)\n        print(\"------------------\")\n        dict_test2 = {5: 3, 6: 3, 2: 9}\n        print(dict_test2.popitem())\n        print(dict_test2)\n    \n    if __name__ == '__main__':\n        test_dict()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/46.png)\n\n  - `clear()` 清空字典\n\n    ```python\n    def test_dict():\n        dict_test = {\"key\": \"value\", 5: 3}\n        dict_test.clear()\n        print(dict_test)\n    \n    if __name__ == '__main__':\n        test_dict()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/47.png)\n\n  - `update(dict)` 更新字典。key 重复则更新 value，没有则新增\n\n    ```python\n    def test_dict():\n        dict_test = {\"first\": \"value1\", \"second\": \"value2\"}\n        print(dict_test)\n        dict_test.update({\"first\": \"update\", \"third\": \"value3\"})\n        print(dict_test)\n    \n    if __name__ == '__main__':\n        test_dict()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/48.png)\n\n  - get(key，obj) 判断字典的 key 是否存在，若存在返回对应的 value，不存在则返回 obj\n\n    ```python\n    def test_dict():\n        dict_test1 = {\"first\": \"value1\", \"second\": \"value2\"}\n        print(dict_test1.get(\"first\", \"first 不存在\"))\n        print(dict_test1.get(\"third\", \"third 不存在\"))\n    \n    if __name__ == '__main__':\n        test_dict()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/49.png)\n\n  - `setdefault(key，value) `如果当前 dict 存在 key，那么返回它的 value；否则把 key-value 键值对添加进字典并返回 vaule\n\n    ```python\n    def test_dict():\n        dict_test = {\"first\": \"value1\", \"second\": \"value2\"}\n        dict_test.setdefault(\"third\", \"value3\")\n        print(dict_test.setdefault(\"third\", \"setdefault\"))\n        print(dict_test)\n    \n    if __name__ == '__main__':\n        test_dict()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/50.png)\n\n  - `keys()` 获取 dict 的 keys。并返回该对象的生成器。这样节省了空间。如果要取值则可以自行强行转化成 list\n\n    ```python\n    def test_dict():\n        dict_test1 = {\"first\": 1, \"second\": 2}\n        keys = dict_test1.keys()\n        print(keys)\n        print(type(keys))\n        print(list(keys))\n    \n    if __name__ == '__main__':\n        test_dict()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/51.png)\n\n  - `values()` 获取 dict 的 values，其他同上\n\n    ```python\n    def test_dict():\n        dict_test1 = {\"first\": 1, \"second\": 2}\n        values = dict_test1.values()\n        print(values)\n        print(type(values))\n        print(list(values))\n    \n    if __name__ == '__main__':\n        test_dict()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/52.png)\n\n  - `items()`获取了dict 的 keys 和values 元组对，其他同上\n\n    ```python\n    def test_dict():\n        dict_test = {\"first\": 1, \"second\": 2}\n        items = dict_test.items()\n        print(items)\n        print(type(items))\n        print(list(items))\n    \n    if __name__ == '__main__':\n        test_dict()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/53.png)\n\n- 集合类型--->可变类型:这代表着以下方法如若修改字典，字典的 id(dict)值不变，与 str 类型不同\n\n  - 集合元素满足\n\n    - 必须是可散列的 数字，字符串，元组\n\n  - 底层原理\n\n    - 依旧采用 hash 表进行存储\n\n  - 创建空集合 `set()`\n\n    - 不能采用 `{}`，系统默认为 dict 类型\n\n      ```python\n      def test_set():\n          set_test = set()\n          dict_test = {}\n          print(set_test)\n          print(type(set_test))\n          print(\"-----------------\")\n          print(dict_test)\n          print(type(dict_test))\n      \n      if __name__ == '__main__':\n          test_set()\n      ```\n\n      - 返回\n\n        ![](./images/python/data-type/55.png)\n\n  - 如若不是空集合，则可以采用 `{values}` 方式创建\n\n    ```python\n    def test_set():\n        set_test = {1, 2}\n        print(set_test)\n        print(type(set_test))\n    \n    if __name__ == '__main__':\n        test_set()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/56.png)\n\n  - 由于集合内元素要参与 `hash(values)` 运算，所以得是不可变类型\n\n    ```python\n    def test_set():\n        try:\n            set_test = {1, [1, 2]}\n            print(set_test)\n        except TypeError as t:\n            print(t)\n    \n    if __name__ == '__main__':\n        test_set()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/57.png)\n\n  - 交集 `set1 & set2`\n\n    ```python\n    def test_set():\n        set1 = {1, 2, 3}\n        set2 = {2, 3, 4}\n        set3 = {6, 7, 8}\n        print(set1 & set2)\n        print(set2 & set3)\n    \n    if __name__ == '__main__':\n        test_set()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/58.png)\n\n  - 并集 `set1 | set2`\n\n    ```python\n    def test_set():\n        set1 = {1, 2, 3}\n        set2 = {2, 3, 4}\n        print(set1 | set2)\n    \n    \n    if __name__ == '__main__':\n        test_set()\n    ```\n\n    - 输出\n\n    ![](./images/python/data-type/59.png)\n\n  - 差集 `set1 - set2`\n\n    ```python\n    def test_set():\n        set1 = {1, 2, 3}\n        set2 = {2, 3, 4}\n        print(set1 - set2)\n    \n    if __name__ == '__main__':\n        test_set()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/60.png)\n\n  - `discard(value)` 删除集合中 value 元素，找不到不会抛出异常\n\n    ```python\n    def test_set():\n        set_test = {1, 2, 3}\n        set_test.discard(1)\n        print(set_test)\n        set_test.discard(1)\n    \n    if __name__ == '__main__':\n        test_set()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/61.png)\n\n  - `remove(values)` 删除 value 。找不到则报错\n\n    ```python\n    def test_set():\n        set_test = {1, 2, 3}\n        set_test.remove(2)\n        print(set_test)\n        try:\n            set_test.remove(2)\n        except KeyError as k:\n            print(k)\n    \n    \n    if __name__ == '__main__':\n        test_set()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/62.png)\n\n  - `update(obj)` 遍历序列 obj 更新集合 。序列一定是可哈希的，否则报错。\n\n    ```python\n    def test_set():\n        set_test = {1, 2, 3}\n        set_test.update([1, 2, 4])\n        print(set_test)\n        try:\n            set_test.update([2, 3, [1, 2]])\n        except TypeError as t:\n            print(t)\n    \n    \n    if __name__ == '__main__':\n        test_set()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/63.png)\n\n  - `pop()` 随机删除一个元素。通常是展现出的删除第一个元素\n\n    ```python\n    def test_set():\n        set_test1 = {1, 2, 3}\n        set_test1.pop()\n        print(set_test1)\n    \n    \n    if __name__ == '__main__':\n        test_set()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/64.png)\n\n  - `add(value)` 往集合中增加一个元素\n\n    ```python\n    def test_set():\n        set_test1 = {1, 2, 3}\n        set_test1.add(4)\n        print(set_test1)\n        try:\n            set_test1.add([])\n        except TypeError as t:\n            print(t)\n    \n    \n    if __name__ == '__main__':\n        test_set()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/65.png)\n\n  - `clear()` 清空集合\n\n    ```python\n    def test_set():\n        set_test = {\"\", 1, ()}\n        set_test.clear()\n        print(set_test)\n    \n    \n    if __name__ == '__main__':\n        test_set()\n    ```\n\n    - 返回\n\n      ![](./images/python/data-type/66.png)\n","tags":["python"],"categories":["python"]},{"title":"python 运算符","url":"/2022/12/05/python/python 运算符/","content":"\n* python 运算符分为 算术运算符、赋值运算符、布尔运算符、比较运算符、位运算符\n  \n    * 算术运算符分为 标准运算符、取余运算符、幂运算符\n        * 算术运算符满足以下规则\n            * ![](./images/python/operator/1.png)\n            \n        * 标准运算符\n            * > \\+ -  *  \\/  \\/\\/\n            \n            * <!-- more -->\n              \n            * 其中为整除运算符，若两者异号，则向下取整\n              \n                ```python\n                def test():\n                    value1 = 20/-3\n                    value2 = 20//-3\n                    print(value1)\n                    print(value2)\n                \n                if __name__ == '__main__':\n                    test()\n                ```\n                \n                * 返回\n                    * ![](./images/python/operator/2.png)\n                \n            * % 为取余运算符。规则是同号则直接取余数。异号余数 = 被除数 - 除数*商\n                * 其中以上的 商 为两者整除而来 如  -20%3的商为 -20//3\n                \n                    ```python\n                    def test():\n                        value1 = -20%-3\n                        value2 = -20%3\n                        value3 = 20%-3\n                        print(value1)\n                        print(value2)\n                        print(value3)\n                    \n                    if __name__ == '__main__':\n                        test()\n                    ```\n                \n                * 返回\n                    * ![](./images/python/operator/3.png)\n                \n            * **为幂运算符，a**b 表示 a 的 b 次 幂\n            \n                ```python\n                def test():\n                    value1 = -2**3\n                    value2 = -2**-2\n                    print(value1)\n                    print(value2)\n                \n                if __name__ == '__main__':\n                    test()\n                ```\n            \n                *  返回\n                    * ![](./images/python/operator/4.png)\n        \n    * 赋值运算符\n        * = 即为赋值运算符。\n            * 执行顺序为 从右往左 a=b=c=1\n            \n            * 支持参数赋值 a += b，a //= b .....\n            \n            * 支持系列解包赋值 a，b = b， a，常用于交换两者的值\n            \n                ```python\n                def test():\n                    value1 = 1\n                    value2 = 2\n                    value1, value2 = value2, value1\n                    print(value1)\n                    print(value2)\n                    \n                    \n                if __name__ == '__main__':\n                    test()\n                ```\n            \n                * 返回\n                    * ![](./images/python/operator/5.png)\n        \n    * 比较运算符\n        * > \\>，<， >=，<=，!=，==\n          \n            * 返回值为 bool 类型，比较的是两者的 _value 值\n          \n        * is ，is not。is 代表 是 id 相等，is not 代表 id 不相等\n            * 返回值为 bool 类型，比较的是两者的 id 值\n            \n                ```python\n                def test():\n                    value1 = 1\n                    value2 = 2\n                    print(value1 == value2)\n                    print(\"-----------------------\")\n                    value3 = [1, [1, 2]]\n                    value4 = [1, [1, 2]]\n                    value5 = value3\n                    print(id(value3), id(value4), id(value5))\n                    print(\"-----------------------\")\n                    print(value3 is value4)\n                    print(value3 is not value5)\n                    print(value4 is not value5)\n                \n                if __name__ == '__main__':\n                    test()\n                ```\n            \n            * 返回\n                * ![](./images/python/operator/6.png)\n        \n    * bool 运算符\n        * python 一切对象都有对应的 bool 值\n            * ![](./images/python/operator/7.png)\n            \n        * and ，or，not，in，not in （其中 in， not in 表示是否在序列中）\n            * 其中 and 和 or 拥有短路性。即 a and b a为false，b不再进行。同理 a or b，a为真 b不再进行\n            \n                ```python\n                m = [1, 2, 3]\n                \n                def test1():\n                    m.clear()\n                    print(m)\n                    return True\n                \n                def test2():\n                    m.append(1)\n                    print(m)\n                    return False\n                \n                def test_bool():\n                    a = True\n                    b = False\n                    print(b and test1())\n                    print(a or test2())\n                \n                \n                if __name__ == '__main__':\n                    test_bool()\n                ```\n            \n            * 返回\n                * ![](./images/python/operator/8.png)\n                \n            * 注意 a and b 其中 a，b不一定是bool 类型。a and b 返回值也不一定是 bool 类型\n                ```python\n                def test():\n                    print(None and 5)\n                    print(1 and 'hello')\n                    print(None or None)\n                    print(\"hello\" or None)\n                \n                \n                if __name__ == '__main__':\n                    test()\n                ```\n                \n                * 返回\n                    * ![](./images/python/operator/9.png)\n                * 实际中不确定 a，b 类型情况下想返回 bool 类型建议 bool(a) and bool(b) 这样能确定100%返回 bool 类型\n        \n    * 位运算符\n        * & 按位与。| 按位或。>> 按位右移。<<按位左移。^为异或。~为按位取反\n        \n        * 以下为运算规则\n            * ![](./images/python/operator/10.png)\n            \n            ```python\n            def test():\n                print(3 & 6)\n                print(3 | 6)\n                print(3 >> 2)\n                print(3 << 1)\n            \n            \n            if __name__ == '__main__':\n                test()\n            ```\n            \n        * 返回\n            * ![](./images/python/operator/11.png)\n            \n        * 注意，参与运算要按照补码进行计算\n            * 原码，反码，补码规则如下\n                * 正数\n                    * 原码，反码，补码相同。符号位都为0\n                * 负数\n                    * 原码符号位为1.反码是符号位不变，其余按位取反。补码是反码 + 1\n            \n        * 根据以上规则我们可以计算出负数的 按位与 和 按位或\n            ```python\n            def test():\n                print(-3 & -6)\n                print(-3 | -6)\n                print(-3 >> 1)\n                print(-3 << 1)\n            \n            \n            if __name__ == '__main__':\n                test()\n            ```\n            \n            * 返回\n                * ![](./images/python/operator/12.png)\n            * 验算\n                * ![](./images/python/operator/13.png)\n                * 同理可以算出其他值。\n                    * 注意移位运算符符号位补位为当前符号。即符号位永远保持同号\n            \n        * ~ 按位取反\n            * 值得注意的是按位取反符号位要参与\n            \n                ```python\n                def test():\n                    print(~-3)\n                    print(~5)\n                \n                \n                if __name__ == '__main__':\n                    test()\n                ```\n            \n            * 返回\n                * ![](./images/python/operator/14.png)\n            \n        * ^异或\n            * 即A^B = （A and !B）or (!A and B)\n            \n                ```python\n                def test():\n                    print(5 ^ -2)\n                \n                \n                if __name__ == '__main__':\n                    test()\n                ```\n            \n            \n            ​    \n            \n            * 返回\n                * ![](./images/python/operator/15.png)\n                \n            * 异或可以不借助第三方参数进行交换值\n                ```python\n                def exchange(a, b):\n                    print(a, b)\n                    print(\"-----------------\")\n                    a = a ^ b\n                    b = a ^ b\n                    a = a ^ b\n                    print(a, b)\n                \n                \n                if __name__ == '__main__':\n                    exchange(6, 5)\n                ```\n                \n                \n                \n                \n                * 返回\n                    * ![](./images/python/operator/16.png)\n                    * ![](./images/python/operator/17.png)\n                * 证明\n            \n        * 运算符优先级参考如下：\n            * ![](./images/python/operator/18.png)\n            * python3 官方参考\n                * ![](./images/python/operator/19.png)\n","tags":["python"],"categories":["python"]},{"title":"Python pytest 模块单元测试","url":"/2022/12/05/python/pytest/","content":"# 一、简单入门：\n\n* 准备 requirements.txt 写入以下插件和包\n    ```\n    `pytest`\n    `pytest-html`\n    `pytest-xdist`\n    `pytest-ordering`\n    `pytest-rerunfailures`\n    `allure-pytest`\n    ```\n    \n    \n\n* 安装插件\n    * `pip install -r requirements.txt`\n\n* <!-- more -->\n  \n* 编写一个简单的测试脚本 test.py\n  \n    ```python\n    import pytest\n    \n    \n    class TestCase:\n    \n        def test_number(self):\n            assert True is False\n    ```\n\n* 运行 pytest \n    * `pytest -vs test.py`\n\n* 运行结果如下\n    * ![](./images/python/pytest/1.png)\n\n\n\n# 二、详细讲解\n\n* 运行\n    * python test.py 脚本下 写入 main 方法调用 pytest.main() 去执行\n      \n        ```python\n        if __name__ == '__main__':\n            pytest.main(['-s', './test_number.py'])\n        ```\n        \n    * 终端模式下也可以通过 pytest 命令执行\n      \n        * `pytest -vs test.py`\n    \n* 参数解析\n    * 默认不加参数即运行\n      \n        ```python\n        if __name__ == '__main__':\n            pytest.main()\n        ```\n        \n        * `pytest test.py`\n        \n    * 以上默认运行以下测试用例\n            * 名字带有 test 开头或 test 结尾的 python 模块\n            * 名字以 Test 开头且不能含有 __init__ 方法的类\n            * 名字以 test 开头的方法\n        \n    * 常用的参数解释\n        * -s\n            * 打印输出调试信息\n        * -v\n            * 输出更详细的信息\n        * -n number (输入几个线程)\n            * 多线程或分布式运行\n        * --reruns number (输入重跑次数)\n            * 运行用例失败重跑\n        * -x\n            * 只要一个用例失败那么停止测试\n        * --maxfail=number\n            * 出现 number 次用例失败就停止测试\n        * -k string\n            * 根据测试用例的部分字符串(string)指定\n        * -rA\n            * 测试结果的简单统计\n        * -m\n            * 指定被 `pytest.mark` 标记过的方法\n    \n* 编辑 pytest.ini 配置文件达到命令行运行的效果。配置好后 只需要 pytest 即可一键运行\n    * 系统根目录下创建 pytest.ini 配置文件\n        * `touch pytest.ini`\n    * 修改该文件编码格式为 ANSI 格式，创建好需要更改编码格式\n    * 作用\n        * 改变 pytest 的默认行为，无需命令行输出冗余命令\n    * 运行规则\n        * pytest 自动读取 pytest.ini 配置文件并按照配置文件规则执行\n    * 一些具体参数如下 pytest.ini\n        ```\n        `[pytest]`\n        `#encoding = ANSI`\n        \n        `#命令行参数，用空格分隔`\n        `addopts = -vs` \n        `#测试用例的文件路径`\n        `testpaths = .`\n        `#配置测试搜素的 python 文件名称`\n        `python_files = test*.py\n        #配置测试搜索的测试类名\n        python_classes = Test*`\n        `#配置测试搜索的测试函数名`\n        `python_functions = test*`\n        ```\n    \n* pytest 装饰器解释\n    * 有时候我们希望某个方法有专门的作用和不同的作用那么就可以采用 pytest装饰器修饰\n        * `@pytest.mark.yourname`\n          \n            * 用该装饰器装饰的方法可以用 `pytest -m \"yourname\"`进行操作\n            * 多个被 mark 过的方法 可以使用逻辑运算符and or not进行连接\n                * 如 `pytest -m \"first or second\"`\n                    * 表示 first 方法 和 second 方法都被执行\n        * `@pytest.mark.skip(reason=yourreasons)`\n          \n            * 用该装饰器装饰的方法会被 pytest 无条件跳过\n        * `@pytest.mark.skipif(condition=yourcondition, reason=yourreasons)`\n          \n            * 用该装饰器装饰的方法会被 pytest 判定:如果 condition 表达式为 True，则跳过该测试，反之则不跳过\n        * `@pytest.mark.run(order=number)`\n          \n            * 用该装饰器装饰的方法会被 pytest 识别并依照 number 的值的顺序跑测试用例\n        * `@pytest.fixture(scope=scope, params=params, autouse=bool, ids=ids, name=name)`\n          \n            * 用fixtrue标记的方法一般用于前置和后置处理，类似 setup & teardown 的功能\n            * 其中 scope 参数有以下四个值:\n                * \"function\"\n                    * 代表着作用于 方法\n                * \"class\"\n                    * 代表着作用于 类\n                * \"modules\"\n                    * 代表着作用于一个 python 文件\n                * \"sessions\"\n                    * 代表着作用于整个 pytest 测试流程\n            * 其中 autouse 参数有 True 和 False 两个 bool 值\n              \n                * 如果 autouse=True，那么默认测试用例方法都会执行fixture，前提是在自己的scope里\n                \n                ```python\n                @pytest.fixture(scope=\"function\", autouse=True, params=[(\"这是\", \"first\"), (\"这是\", \"second\")])\n                def sayhello(request):\n                \n                    print(\"测试开始\")\n                    yield request.param\n                    print(\"测试结束\")\n                \n                \n                class TestCase:\n                \n                    @pytest.mark.run(order=3)\n                    # @pytest.mark.first\n                    def test_number(self):\n                        pass\n                ```\n                \n                * 如果 autouse=Flase，那么测试用例方法参数需要添加 fixture 修饰的方法名字\n                \n                    ```python\n                    @pytest.fixture(scope=\"function\", autouse=False, params=[(\"这是\", \"first\"), (\"这是\", \"second\")])\n                    def sayhello(request):\n                    \n                    ​    print(\"测试开始\")\n                    ​    yield request.param\n                    ​    print(\"测试结束\")\n                    \n                    \n                    \n                    class TestCase:\n                    \n                    ​    @pytest.mark.run(order=3)\n                    ​    \\# @pytest.mark.first\n                    ​    def test_number(self, sayhello):\n                    ​        pass\n                    ```\n                \n            * 其中 params 参数控制着传参\n                * `params=[(\"这是\", \"first\"), (\"这是\", \"second\")]`\n                * 其中 params 可以等于一个 列表或字典，或者 字典列表与元祖列表\n                * 如果要获得 params 的参数，则fxiture修饰的方法需要添加固定的 request 参数，且返回request.param 用于测试方法接受\n                * 如果测试方法要接收 params 参数，即时autouse=True，也要在测试方法参数上添加需要的fixture方法名\n                    * 未加方法名结果\n                        * ![](./images/python/pytest/2.png)\n                    * 添加方法名结果\n                        * ![](./images/python/pytest/3.png)\n            * 使用方法\n                * 借助python yeild 生成器控制前置和后置输出\n                  \n                    ```python\n                    @pytest.fixture(scope=\"function\", autouse=True, params=[(\"这是\", \"first\"), (\"这是\", \"second\")])\n                    def sayhello(request):\n                    \n                    ​    print(\"测试开始\")\n                    ​    yield request.param\n                    ​    print(\"测试结束\")\n                    ```\n            * 实际使用\n                * 一般情况下 pytest 有一个机制:即把 fixture 集中放入一个名叫 conftest.py 的文件下，pytest会自动识别该文件并作出相应的响应\n                * 作用域\n                    * 该文件可以存放在任何目录下\n                    * 只对当前目录及当前路径以下的目录下起作用\n                        * ![](./images/python/pytest/4.png)\n        * `@pytest.mark.parametrize(argsname，argsvalues)`\n          \n            * 用该装饰器修饰的方法可以进行参数化\n            * argsname 代表着参数名，argsvalues代表参数值\n                ```python\n                import pytest\n                \n                \n                class TestCase2:\n                \n                ​    @pytest.mark.parametrize(argnames=\"a\", argvalues=[\"FIRST\", \"SECOND\"])\n                ​    def test_number(self, a: list):\n                ​        print(a)\n                ```\n                \n                \n                \n            * 结果\n                * ![](./images/python/pytest/5.png)\n\n","tags":["python"],"categories":["python"]},{"title":"docker","url":"/2022/12/05/linux/docker/","content":"# docker详解","categories":["linux"]},{"title":"测试用例设计方法","url":"/2022/12/05/测试理论/测试用例设计方法/","content":"测试用例设计方法\n\n* 测试用例该如何设计呢\n* 测试上可以分为黑盒测试和白盒测试两种\n* <!-- more -->\n    * 黑盒测试\n        * ![](./images/test-theory/Testcase-Designer/1.png)\n\n    * 白盒测试\n        * ![](./images/test-theory/Testcase-Designer/1.png)\n* 等价类划分法（简称等价类）\n    * 定义\n        * 将输入（输出）域划分成若干个子集合中，从划分的子集合中选取代表数据进行测试，如果选取的数据测试没有问题，就认为其他数据测试的效果是等价的\n    * 分为 \n        * 有效等价类\n        * 无效等价类\n    * 等价类划分原则\n        * 如果输入（输出）是一个取值范围或者某个值的个数时，则划分成一个有效等价类和两个无效等价类\n            * 举例\n                * 某个大厦招聘保安，年龄要求18~60周岁（包括18和60）\n                    * 一个有效等价类：18~60\n                    * 两个无效等价类：<18；>60\n                * 并且从以上区间选取带有标志性的数据测试\n                    * 如有效等价类区间里选取 18 60 50.....，无效等价类里选取 10 70 80 .....\n        * 如果输入（输出）是一个有限集合或者必须如何的条件，则划分成一个有效等价类和一个无效等价类\n            * 举例\n                * 一个集合：以下城市进入上海需要提供核酸检测报告（沈阳；大连；深圳；广州；合肥；六安；营口；瑞丽）\n                    * 一个有效等价类：集合内；\n                    * 一个无效等价类：集合外（菏泽）\n                * 并且从以上区间选取带有标志性的数据测试\n                    * 如有效等价类选取大连......，无效等价类选取 菏泽......\n        * 如果输入（输出）是一个布尔量，则划分成一个有效等价类和一个无效等价类\n            * 举例\n                * 某个问卷调查 App 如果性别选项选择男请转到第五题：\n                    * 一个有效：男\n                    * 一个无效：女\n                * 如果性别选项选择女请转到第二题：\n                    * 一个有效：女\n                    * 一个无效：男\n            * 很明显布尔类型是第二种等价类的特殊情况\n        * 如果输入（输出）已经划分出有效和无效等价类，针对有效等价类部分不同的取值处理方式不一样，细分成多个有效等价类和一个无效等价类\n            * 举例\n                * 某个认证考试百分制；60分及格可以获得认证证书\n                    * 一个有效等价类：>=60分\n                        * 细化等价类：   60~69分—合格；70~79分—中等；80~89分—良好；90~99分—优秀；100分—完美\n                    * 一个无效等价类：<60分\n        * 如果输入（输出）要同时满足多个条件，则划分成一个有效等价类和多个无效等价类\n            * 举例\n                * 学习系统登录密码修改：6~12位；\n                    * 一个有效等价类：大小写字母与数字的组合满足所有要求\n                    * 多个无效等价类：少于6位；大于12位；缺少数字；缺少小写字母；缺少大写字母；含有其他字母\n            * 很明显从以上看出当有限集合数量过于庞大时，我们不采用第二种等价类划分法，采用当前的划分方法\n    * 使用步骤\n        * 分析需求\n            * 将软件需求规格说明书划分成需求子片段\n            * 分析需求子片段，找出输入条件\n        * 分析输入条件，判定是否需要结合等价类划分原则划分等价，需要则继续\n        * 为了防止测试遗漏，为划分的等价类进行编号\n        * 从划分的等价类中选取代表数据进行测试，直到所有的等价类全部被覆盖\n        * 将选取的数据结合测试用例写作格式完成最终测试用例的编写\n        * 值得注意的是\n            * 一条测试用例尽量覆盖多个有效等价类；\n            *   一条测试用例只覆盖一个无效等价类；\n            * 这符合之前等价类设计方法的最后一条，因为实际输入要么是庞大的集合，要么是无穷的区间。总之应该以有效等价类覆盖越多越好\n* 边界值\n    * 对于等价类划分法的问题是等价类划分法追求有效等价类覆盖率和数量，然而拥有无穷数的区间却使用一个等价类设计思路，这显然和宗旨相悖。基于以上问题，那么边界值设计方法可以对以上问题进行补充\n    * 边界值有三个重要的参数\n        * 上点：区间边界的点\n        * 离点：离区间边界点最近的点\n            * 如果是开区间离点落在区间内，如果是闭区间离点落在区间外\n                * 即离点不能落在区间里\n        * 内点：落在区间内任意的点\n        * 举例\n            * 某个大厦招聘保安，年龄要求[18，60]周岁\n                * 上点：18；60\n                * 离点：17；61\n                * 内点：30\n    * 通过以上三个重要参数介绍基于边界值的选取原则\n        * 如果输入（输出）是一个取值范围时，则以边界和边界附近的值作为测试用例数据优先选取\n            * 这就是对等价类不足的设计手段，因为等价类不能精确地锁定哪些数据需要拿来测试。\n        * 如果输入（输出）是一个有序的集合，则以第一个元素和最后一个元素作为测试用例\n            * 这个是基于对第二种等价类划分原则进行补充。\n        * 如果输入（输出）的值的个数是个取值范围，则以最大个数、最大个数+1、最小个数、最小个数-1作为测试用例数据优先选取；\n            * 这个是对以上两条内容的补充\n    * 使用步骤\n        * 分析需求\n            * 将软件需求规格说明书划分成需求子片段\n            * 分析需求子片段，找出输入条件\n        * 分析输入条件，判定是否需要边界值法，如果需要结合等价类划分原则划分等价类\n            * 很明显，边界值划分法是基于等价类划分法的补充，一定要优先择取等价类划分，根据划分情况选择合适的数据\n        * 判断是否需要边界值和需要哪种边界值方法\n            * 分析等价类，是否需要边界值补充\n            * 结合边界值数据选取原则确定边界值的选取\n        * 将选取的数据结合测试用例写作格式完成最终测试用例的编写\n    * 等价类和边界值适用范围\n        * 特点：不测试各种组合。测试效率比较高，效果一般。比较容易理解和易于使用的一种方法\n        * 适用范围：功能测试；性能测试；界面测试（GUI测试）；兼容测试\n        * 注意接口测试一般不选取等价类划分法去测试，一般功能测试可以使用等价类划分法\n* 判定表\n    * 分析和表达多种输入条件下完成不同动作的一种工具，这种方法能够将具有复杂逻辑关系和多种条件组合的情况表达清晰。\n    * 很显然，判定表是针对有限布尔集合或者输入是处于多个有限集合而言的。而一般功能的输出的集合一般只有一两个元素，然后由于有 switch-case 这种情况的出现，我们就可以考虑由判定表方法完成\n    * 判定表一样有三个重要的参数\n        * 条件桩：输入条件\n            * 表示输入取值的集合\n        * 条件项：输入条件的取值\n            * 表示具体输入的集合元素\n        * 动作桩：输出结果\n            * 表示输出的取值集合\n        * 动作项：输出结果的取值\n            * 表示具体输出的集合元素\n    * 使用步骤\n        * 分析需求\n            * 将软件需求规格说明书划分成需求子片段；\n        * 分析输入条件，判定是否需要判定表设计方法，如果需要则继续\n        * 找出条件桩、条件项、动作桩、动作项；\n        * 将条件项进行组合，确定测试组合数量（条件项的个数相乘），得出测试规则；\n        * 分析生成的规则，对相似规则进行合并化简（合并有风险，化简需谨慎—对软件系统内部的逻辑结构非常了解；资源有限）；\n        * 分析每条生成的规则，必要时结合等价类边界值生成最终的测试用例。\n    * 判定表适用范围\n        * 从以上分析我们不难发现，判定表只使用输入输出为一个少元素或者布尔值的集合，因为如果输入输出量太大，那么根据组合数原理，测试用例量将会特别多影响测试效率。\n        * 所以适合功能测试，如修改密码成功与否，登录成功与否，下单成功与否。\n    * 判定表特点\n        * 条件桩的顺序对生成规则没有影响\n        * 动作桩的顺序对生成的规则没有影响\n        * 每条规则都是独立的相互之间没有影响\n    * 判定表写法\n        * ![](./images/test-theory/Testcase-Designer/3.png)\n        * 以上不难分析出理论上有 2**条件项的测试用例产生。\n* 因果图\n    * 因果图属于对判定表的一种补充。如果边界值法是对等价类划分法无穷转化为有穷的补充，那么因果图就是对判定表复杂的逻辑输入输出到简化的逻辑输入输出的补充\n    * 因果图顾名思义为 因---果 键值对，那么它有三个重要参数\n        * 原因 : C（course）\n        * 结果:  R（result）\n        * 中间项：当多个原因之间不是单纯的与和或的关系，可以利用中间节点存取中间结果，使得因果图更加清晰\n    * 因果有了，因果关系如下\n        * 逻辑关系\n            * 恒等\n                * 图标\n                    * ![](./images/test-theory/Testcase-Designer/4.png)\n            * 与\n                * 图标\n                    * ![](./images/test-theory/Testcase-Designer/5.png)\n            * 或\n                * 图标\n                    * ![](./images/test-theory/Testcase-Designer/6.png)\n            * 非\n                * 图标\n                    * ![](./images/test-theory/Testcase-Designer/7.png)\n        * 制约关系\n            * 互斥\n                * Exclusive\n                * 有多个输入(原因)，至多只能有一个为真，不可以同时都为真，可以同时都为假\n            * 包容\n                * Inclusive\n                * 有多个输入(原因)，至少有一个为真，可以同时都为真，不可以同时都为假\n            * 唯一\n                * Only\n                * 有多个输入(原因)，有且只能有一个为真，不可以同时都为真，不可以同时都为假\n            * 要求\n                * Require\n                * 有两个输入(原因)，A为真，B为真；A为假，B不做要求\n            * 强制\n                * Mandatory\n                * 有两个输入(原因)，A为真，B为假；A为假，B不做要求\n    * 使用步骤\n        * 分析需求\n            * 将软件需求规格说明书划分成需求子片段；\n        * 分析输入输出，判定是否需要判定表设计方法，如果需要则是否需要借助因果图，如果需要则继续\n        * 分析原因和结果之间的关系，画出因果图\n        * 分析原因之间是否存在制约关系，做出标识\n        * 根据有因果图生成判定表\n        * 分析判定表，进行合并和化简\n        * 必要时结合等价类、边界值生成最终的测试用例\n    * 因果图画法\n        * ![](./images/test-theory/Testcase-Designer/8.png)\n* 正交表\n    * 正交表起源于伽罗瓦的数学理论。因为输入的是一组有限集合，那么多组输入可以简化。所以正交表是对判定表和因果测试用例数的简化\n    * 使用步骤\n        * 需求分析\n            * 将软件需求规格说明书划分成需求子片段\n        * 分析输入输出，看是否需要用到判定表和因果图，如果需要：找出因子和状态，构造一张因子状态表\n        * 使用正交表工具 allpairs 进行输出测试用例\n            * 正交表工具使用方法参考\n                * {% post_link  \"测试理论/正交表工具使用方法\" \"正交表工具使用方法\" %}\n        * 必要时可以结合等价类边界值生成最终的测试用例\n    * 特点和适用范围\n        * 很明显正交表极大地简化了判定表的测试用例量，所以基本判定表都会使用正交表\n        * 特别适合做兼容性测试，表单，配置测试等\n* 状态迁移图\n    * 定义\n        * 在给定的条件下状态能够正确的跳转以及是否有非法转移和未可达的状态\n    * 相关关键词如下\n        * 有限状态机\n            * 拥有有限个数量的状态，每个状态可以迁移到零个或多个状态\n        * 状态\n            * 某一时刻的表现\n        * 跳转条件\n            * 输入（使得状态发生变化的操作）\n        * 迁移\n            * 状态变化的过程\n    * 使用步骤\n        * 将软件需求规格说明书划分成需求子片段\n        * 分析需求子片段，找出状态和条状条件\n        * 假定一个初始状态，以圆圈（代表状态）为节点以箭线（输入）为跳转条件画出状态迁移图\n        * 根据状态迁移图得出状态事件转换表（第一列代表上一状态；第二列代表跳转条件；第三列代表下一状态；第四列代表输出结果）\n        * 通过状态转换事件表得出状态转换树（矩形框代表状态）\n        * 通过状态转换树找出测试路径\n        * 添加一些非法测试\n        * 必要时可以结合等价类和边界值进行测试\n* 场景测试法\n\n","categories":["测试理论"]},{"title":"正交表工具使用方法","url":"/2022/12/05/测试理论/正交表工具使用方法/","content":"正交表工具使用方法\n\n* 参考链接\n    * https://blog.csdn.net/qq_54444533/article/details/124828947\n* 官方网站\n    * https://www.satisfice.com/download/allpairs\n* <!-- more -->\n* 下载后解压\n    * ![](./images/test-theory/Orthogonal-tool/1.png)\n* 将该目录添加至环境变量 PATH\n    * ![](./images/test-theory/Orthogonal-tool/2.png)\n    * 输入 `allpairs` 命令显示以上则安装成功\n* 使用方法\n    * 第一步\n        * 对需要正交表的条件项目依次填入 csv 中，格式如下\n        * ![](./images/test-theory/Orthogonal-tool/3.png)\n    * 第二步\n        * 复制全部内容到 txt 文档\n        * ![](./images/test-theory/Orthogonal-tool/4.png)\n        * 注意不要在意 txt 文档格式混乱，allpairs 会自动识别。并且最后一行不能有换行符。否则会报错\n            * ![](./images/test-theory/Orthogonal-tool/5.png)\n    * 第三步\n        * 用如下命令\n            * `allpiars 测试数据.txt > 你需要生成的testcase.xlsx 表格中`\n            * ![](./images/test-theory/Orthogonal-tool/6.png)\n    * 最后查看结果\n        * ![](./images/test-theory/Orthogonal-tool/7.png)\n    * 值得注意的是，表格下方是所有笛卡尔积结果。上方才是需要测试的数据\n        * 其中前缀为~的项表示无关数据，可以任意取值\n\n","categories":["测试理论"]},{"title":"软件质量模型","url":"/2022/12/05/测试理论/软件质量模型/","content":"软件质量模型\n\n* 参考链接\n    * https://cloud.tencent.com/developer/article/1457805\n\n* 软件质量模型是现 ISO\\/IEC25015 或 ISO\\/IEC9126 发布的软件质量保证的模型\n    * 它可以用官方的解释来判断一个软件质量的好坏与否\n* 质量模型涉及6大特性和27个子特性\n* <!-- more -->\n    * ![](./images/test-theory/QA-modules/1.png)\n    * *功能性*\n        * *软件产品提供明确、隐含要求的能力*\n        * *适合性* 软件产品为指定的任务和用户提供一组合适的功能的能力（投入运行后，功能是否合适、正确、完整等）\n        * *准确性* 软件产品提供具有所需精度的正确或相符的结果或效果的能力（实际与预期的差别）\n        * *互操作性* 软件产品与一个或更多的规定系统进行交互的能力（如果与其它软件有定义接口，数据传输的正确程度）\n        * *安全保密性* 软件产品保护信息和数据的能力，使未授权的人不能阅读或修改这些信息和数据，而不拒绝授权人员阅读或修改这些信息和数据(访问的可审核性（正常、病毒）、可控制性）\n        * *功能性的依从性* 软件产品遵循与功能性相关的标准、约定或法规及类似规定的能力（非法）\n    * *可靠性*\n        * *在指定条件下使用时，软件产品维持规定的性能级别的能力*\n        * *成熟性* 软件产品为避免由软件内部的故障而导致失效的能力（潜在的故障密度、失效的测试用例数量、故障排除）\n        * *容错性* 在软件出现故障或者违反其指定接口的情况下，软件产品维持规定的性能级别的能力\n        * *易恢复性* 在失效发生的情况下，软件产品重建规定的性能级别并恢复受直接影响的数据的能力（重启能力、重启时间）\n        * *可靠性的依从性* 软件产品遵循与可靠性相关的标准、约定或法规的能力（非法）\n    * *易用性*\n        * *在指定条件下使用时，软件产品被理解、学习、使用和在指定条件下使用时，软件产品被理解、学习、使用和吸引用户的能力*\n        * *易理解性* 软件产品使用户能理解软件是否合适以及如何能将软件用于特定的任务和使用条件的能力（文档、功能的初始印象）\n        * *易学性* 软件产品使用户能学会其应用的能力（使用者学习满足需求的能力）\n        * *易操作性* 软件产品使用户能操作和控制它的能力\n        * *吸引性* 软件产品吸引用户的能力\n        * *易用性的依从性* 软件产品遵循与易用性相关的标准、约定、风格指南或法规的能力（非法）\n    * *效率*\n        * *在规定条件下，相对于所用资源的数量，软件产品可提在规定条件下，相对于所用资源的数量，软件产品可提供适当性能的能力*\n        * *时间特性* 在规定条件下，软件产品执行其功能时，提供适当的响应和处理时间以及吞吐率的能力（如响应时间）\n        * *资源利用性* 在规定条件下，软件产品执行其功能时，使用合适数量和类别的资源的能力（如内存占用）\n        * *效率依从性* 软件产品遵循与效率相关的标准或约定的能力（非法）\n    * *可维护性*\n        * *软件产品可被修改的能力。修改可能包括修正、改进或软件对环境、需求和功能规格说明变化的适应*\n        * *易分析性* 软件产品诊断软件中的缺陷或失效原因或识别待修改部分的能力。\n        * *易改变性* 软件产品使指定的修改可以被实现的能力（变更难易的程度）\n        * *稳定性* 软件产品避免由于软件修改而造成意外结果的能力（由于软件修改而造成的意外）\n        * *易测试性* 软件产品修改能被确认的能力\n        * *维护性的依从性* 软件产品遵循与维护性相关的标准或约定的能力（非法）\n    * *可移植性*\n        * *软件产品从一种环境迁移到另一种环境的能力*\n        * *适应性* 软件产品毋需采用额外的活动或手段就可适应不同指定环境的能力（屏幕大小）\n        * *易安装性* 软件产品在指定环境中被安装的能力（用户在指定环境中被安装的能力，与易操作性互相影响）\n        * *共存性* 软件产品在公共环境中同与其分享公共资源的其他独立软件共存的能力（共享资源的其它软件）\n        * *易替换性* 软件产品在同样环境下，替代另一个相同用途的软件产品的能力（版本迭代、新旧兼容）\n        * *可移植性的依从性* 软件产品遵循与可移植性相关的标准或约定的能力（非法）\n* 软件的使用质量模型\n    * 基于用户观点的软件产品用于指定的环境和使用周境时的质量。它测量用户在特定环境中能达到其目标的程度，而不是测量软件自身的属性。\n    * 基本的软件使用质量模型包括4大特性\n        * ![](./images/test-theory/QA-modules/2.png)\n\n","categories":["测试理论"]},{"title":"软件开发模型（SDLC)","url":"/2022/12/05/测试理论/软件开发模型（SDLC)/","content":"软件开发模型（SDLC）\n\n* 参考链接\n    * https://cloud.tencent.com/developer/article/1724043\n* 软件开发模型多种多样，下面讲解以下常用的开发模型\n    * 瀑布模型\n    * V型\n    * 迭代和增量模型\n    * 螺旋模型\n    * 大爆炸模型\n    * 敏捷模型\n    * 原型模型\n    * DevOps\n* <!-- more -->\n* 瀑布模型\n    * ![](./images/test-theory/SDLC-modules/1.png)\n    * 瀑布模型（Waterfall） 是最简单的软件开发历史上第一个 SDLC 模型。在瀑布模型中，开发过程是线性的。任务和阶段按严格顺序一个接一个地完成。进度平稳地向下流动，就像瀑布上的水一样。\n    * 瀑布模型的主要缺点是不灵活。瀑布易于理解且易于管理。但是过早的延迟会拖延整个项目的时间表。由于一旦完成阶段，几乎没有修改的余地，因此只有进入维护阶段才能解决问题。如果需要灵活性，或者项目是长期的且正在进行的，则此模型不能很好地工作\n* V 型\n    * ![](./images/test-theory/SDLC-modules/2.png)\n    * V 形模型也称为 V 模型或验证与验证模型，是瀑布方法的扩展。使用 V 模型时，进度并不会直线移动，而是在实施和开发后逐渐上升。\n    * 对于 V 型 SDLC 项目，早期测试介入是与 瀑布模型相比的主要区别。每个开发阶段都有一个并行测试阶段，这有助于在继续下一步之前验证和验证每个步骤。\n* 迭代和增量模型\n    * ![](./images/test-theory/SDLC-modules/3.png)\n    * 迭代和增量 SDLC 模型将迭代设计和工作流与增量构建模型结合在一起。在这种情况下，团队将按周期开发产品，并以渐进方式构建小零件。\n    * 开发过程从简单实施一组严格限制的小型产品需求开始。然后对该产品进行增强，并使其本身成为更完整的版本，直到完成并准备好进行部署为止。每次迭代都可能包含设计更新和新功能。\n    * 迭代和增量模型的一个有价值的特点是可以在不知道所有需求的情况下开始开发。该模型包含其他 SDLC 模型的步骤-需求收集，设计，实施和测试，但要经过多次构建。开发团队可以利用先前构建中取得的成就来改善下一构建。\n    * 迭代和增量 SDLC 模型可能看起来像一组微型瀑布模型或微型 V 形模型。\n* 4.螺旋模型\n    * ![](./images/test-theory/SDLC-modules/4.png)\n    * 螺旋 SDLC 模型是原型方法和瀑布方法的结合。螺旋模型被认为是最灵活的 SDLC 方法之一。它从迭代模型及其重复中获得启发。该项目以“螺旋式”的方式反复经历四个阶段，直到完成为止，从而可以进行多轮改进。\n        * 规划\n        * 风险分析\n        * 工程\n        * 评价\n    * 螺旋模型主要用于大型项目，它允许构建高度定制的产品，并且用户反馈可以在项目的早期就被纳入。但可能有项目会形成永无止境的螺旋式发展的风险。\n* 大爆炸模型\n    * ![](./images/test-theory/SDLC-modules/5.png)\n    * Big Bang 模型通常不遵循任何特定过程或说明。开发从当前可用的资源和工作开始，几乎没有计划或根本没有计划。结果，客户得到的产品甚至可能无法满足要求。功能是动态实现的。\n    * Big Bang SDLC 模型的主要思想是将所有可用资源分配给产品本身的开发，主要是在编码方面，而不用担心满足计划。这是仅用于一两个软件工程师的小型项目的 SDLC 方法之一。\n* 敏捷模型\n    * ![](./images/test-theory/SDLC-modules/6.png)\n    * 敏捷（Agile） SDLC 模型是迭代和增量方法的组合，致力于通过早期交付工作软件来适应灵活的需求并满足用户和客户的需求。敏捷项目中的需求和解决方案可能会在开发过程中发展。\n    * 通过敏捷开发，该产品被分为小的增量构建，并以迭代方式交付。将所有任务划分为较小的时间范围，以便为每个版本准备工作功能。最终产品版本包含所有必需的功能。敏捷仍然是技术行业中使用最广泛的SDLC。\n* DevOps模型\n    * ![](./images/test-theory/SDLC-modules/7.png)\n    * DevOps是新手模型。DevOps来自两个趋势：敏捷方法和精益方法的应用。通常，DevOps 是通过自动化基础架构和工作流程并持续跟踪应用程序性能来执行的。DevOps方法使您可以增加部署频率，编写代码并缩短部署新代码所需的时间。\n    * DevOps是工具，实践和方法的组合，鼓励开发人员，运维人员和 QA人员共同努力，以进行持续的开发，测试和部署活动，以加速创新并交付更高质量和更可靠的软件产品和功能。\n\n","categories":["测试理论"]},{"title":"Python 虚拟环境 venv 的创建","url":"/2022/12/05/python/python venv 虚拟环境/","content":"* python 项目为了类似 docker 一样隔离提供 venv 虚拟环境\n* 使用方法\n    * `python -m venv【params】venvpath`\n    * venv 参数如下\n    * ![](./images/python/venv/1.png)\n    * 一般来说只需要\n        * `python -m venv --upgrade-deps venvpath`\n        * 除非需要之前的一些 site-package 否则不加 `--system-site-package`\n        * 建议加上 `--upgrade-deps`\n            * 这样无需手动更新 pip 造成无权限问题而导致原来的 pip 被删除\n* <!-- more -->\n    * 安装好以后可以打开 Scripts/ 目录下的 `activate.bat` 批处理文件进入虚拟环境\n        * activate\n        *  ![](./images/python/venv/2.png)\n        * 也可以在 git-bash 里用 source 命令执行\n            * ![](./images/python/venv/3.png)\n        * 可以用 pip list 查看包情况判断是否进入 python 虚拟环境\n    * 如何退出\n        * 同样在虚环境里执行 deactivate.bat \n            * ![](./images/python/venv/4.png)\n    * pycharm 新建项目如何使用虚拟环境\n        * 只需新建项目里配置虚拟环境解释器路径","tags":["python"],"categories":["python"]}]