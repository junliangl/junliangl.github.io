{"pages":[{"title":"python 函数详解","url":"/2022/12/08/python/python 函数详解/","text":"参考以下有关变量的作用域和类相关的请参考 Python 变量的作用域 Python 内存详解 Python 类详解 函数命名规则小写开头，多个单词下划线 _ 隔开 hello()，test_()， _good_time() 12345678def test_(self): passdef hello(self): passdef _good_time(self): pass 对于类里的函数命名规则对于类里的方法命名有以下规则 python 预先自定义的__init__()，__str__()等收尾双下划线的方法名称为魔法函数。并且一般不建议自己这样命名方法如__public__()因为会被误解为魔法函数。 123456789class Test: def __init__(self, name): self.name = name def __str__(self): return &quot;Test类&quot; def __public__(self): pass __private()以双下划线开头但是不以双下划线结尾的称为私有函数，只能在类里面调用 1234567891011class Test: def __private(self): passif __name__ == &#x27;__main__&#x27;: test = Test() try: test.__private() except AttributeError as a: print(a) 返回 特殊情况然而可以通过_Test__private()强制访问 12345678910class Test: def __private(self): return 1if __name__ == &#x27;__main__&#x27;: test = Test() print(dir(test)) print(test._Test__private()) 返回 以上我们可以看到 test 属性有一个 _Test__private，这意味着可以用它取访问私有的属性。python 其实没有正在意义上的私有属性，只不过我们希望它不能被外界访问时，加入这样的标识符使得被 python 识别。python 不支持私有属性,但当属性命名为 __ 时,会将属性改名为_类名__属性名.这个方法其实是变量名压缩( mangling ,相当于扩张)的概念,只是通过这种方法变相地实现了属性访问控制的功能。但是呢这个方法也很有用,尤其在多重继承,或者大项目的情况下,各个类及实例可能出现属性冲突的情况,就可以通过这个功能来实现。 参考链接 https://blog.csdn.net/renyiforever/article/details/79921854 函数参数参考链接 https://www.bilibili.com/video/BV1k7411W78H?p=6&amp;vd_source=f9937d98d0a8cc08ef5248c3c127d588 参数类别总所周知，写在函数名括号后的叫形式参数，简称形参；实际传值的参数叫实际参数，简称实参 位置参数位置参数设定好以后位置传参不能随意发生改变。若随意改变，函数的功能会发生变化。并且传参参数量一定要匹配，多了或者少了会报错。 123456789101112131415161718192021def test(arg1, arg2, arg3): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;arg3&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test(1, 2, 3) print(&quot;**********************&quot;) test(3, 2, 1) print(&quot;**********************&quot;) try: test(1, 2) except TypeError as t: print(t) print(&quot;**********************&quot;) try: test(1, 2, 3, 4) except TypeError as t: print(t) 返回 参数位置发生改变，方法功能性发生了改变。第一个输出的是 1，2，3；第二个输出的是 3，2，1 参数数量出现问题会抛出错误提示缺少一个位置参数和给多给了位置参数 关键字参数位置参数固然稳定，但是 python 对于方法参数的数量没有做定量要求(java 一般要求参数数量不多于6个)，那么对于多位置参数这种方式会容易位置混乱容易照成方法功能性不符合预期 对于以上问题 python 给出解决方案为 关键字参数 使用方法是：针对形参名在传实参时可以指定想要传入给哪个形参，受指定的参数不受位置问题从而影响方法的功能性 但是一样要满足参数数量的严格吻合，否则还是会报错。并且不能对相同的关键字参数多次传值 1234567891011def test(arg1, arg2, arg3): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;arg3&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test(1, 2, 3) print(&quot;**********************&quot;) test(arg3=3, arg2=2, arg1=1) 返回 以上不难看出关键字参数的使用具有指定性功能。这样即时位置混乱只要符合以上要求都能保持方法功能的正常使用 位置参数和关键字参数混搭混搭规则是一定是实参传递时位置参数在前，关键字参数在后，否则会报错（铁律） 123456789101112def test(arg1, arg2, arg3): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;arg3&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test(1, 2, arg3=3) print(&quot;**********************&quot;) test(1, arg2=2, arg3=3) 返回 若实参传递时关键字参数放在位置参数之前，则编译会报错 以上报错信息提示位置参数在关键字参数之后了。 即使满足位置参数在前，关键字参数在后依旧会报错，位置参数还应该对应本身位置 123456789101112131415def test(arg1, arg2, arg3): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;arg3&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test(1 , 2, 3) print(&quot;**********************&quot;) try: test(10, 30, arg2=20) except TypeError as t: print(t) 返回 以上不难看出，arg1，arg2 位置参数都已经给出了参数，但是随后的关键字参数再次给位置参数 arg2 传值，所以提示 test() 方法传给了 arg2 多个值的错误 强制关键字参数为了让位置参数不容易写混淆而照成方法功能性错误，从而引入强制关键字参数 用法是在需要使用强制关键字参数之前写入 * 号，代表 * 后的参数强制只能使用关键字参数 123456789101112131415def test(*, arg1, arg2, arg3): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;arg3&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test(arg1=1, arg2=2, arg3=3) print(&quot;**********************&quot;) try: test(1, 2, arg3=3) except TypeError as t: print(t) 返回 以上不难看出 * 后实参的传递必须是关键字参数形式，如果没有按这样的方式，就会报 TypeError—test() 方法是0个位置参数，但是传递了2个位置参数 值得注意的是 * 号前依旧可以使用位置参数和关键字参数混搭，但是这建立在形参的 * 号位置 123456789101112131415def test(arg1, arg2, *, arg3): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;arg3&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test(1, arg2=2, arg3=3) print(&quot;**********************&quot;) try: test(1, 2, 3) except TypeError as t: print(t) 返回 以上不难看出可以通过改变 * 号位置灵活使用强制关键字参数，但是依旧要遵守相关的混搭规则。 默认参数在定义形参的时候，我们可以默认给其中的参数传递初始值(默认值)，这样依旧可以正常的定义参数 关键字参数的用法是：在传递实参的时候你可以给默认参数传递一个新的值，也可以不传递 1234567891011def test(arg1=1, arg2=2, arg3=3): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;arg3&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test() print(&quot;**********************&quot;) test(10, arg2=20) 返回 以上不难看出可以不用给默认参数传值，也可以给其中的默认参数传值。传值可以使用位置参数和关键字参数混搭的模式，但是依旧要遵守混搭规则。 默认参数的混搭默认参数依旧可以和之前的位置参数和关键字参数以及强制关键字参数混搭 123456789101112def test(arg1, arg2, arg3, arg4=4): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;arg3&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第四个参数是:&#123;arg4&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test(1, arg2=2, arg3=3, arg4=40) print(&quot;**********************&quot;) 返回 以上不难看出默认参数混搭时依旧要遵守之前的混搭规则 还有一点值得注意的是定义默认参数形参的时候一定要把所有的非默认参数在默认参数之前定义，否则编译不通过（除非形参包含强制关键字参数或可变参数，请参考下面可变位置参数） 这很好理解，因为如果定义在非默认参数之前，当传递实参的时候，编译器不知道你是否给默认参数传递了值，这样为了避免二义性直接编译阶段报错 当默认参数和强制关键字混搭时，由于默认参数的特性，当使用默认值时，我们可以不写 &#x3D; ，但是想给默认参数传值时，则一定要指明默认参数名 123456789101112131415def test(arg1, *, arg2=2, arg3=3): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;arg3&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test(1, arg2=20) print(&quot;**********************&quot;) try: test(1, 20, 30) except TypeError as t: print(t) 返回 以上不难看出如果定义在强制关键词参数后的默认参数想修改默认参数的值，必须要写 &#x3D;，否则就会报错 默认参数和强制关键字参数混搭可以打破默认参数位置限制，但 * 号前的参数依旧要满足默认参数位限制（默认参数位置限制参考上面） 12345678910def test(arg1, *, arg2=2, arg3): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;arg3&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test(1, arg2=20, arg3=3) 返回 以上不难看出默认参数可以写在位置参数之前了，打破了之前的限制，因为后面位置参数变为了强制关键字参数，因此不会引发二义性。但是后面的强制关键字参数依旧要使用等号，否则编译不通过。因为不满足实参传值时位置参数要在关键字参数之前 可变位置参数（又叫可变参数）有时候我们不确定具体传参时某些形参需要传多少个，那么我们就引入可变位置参数 使用方式：在定义形参的名字前写上 * def test(*args) 该可变位置参数通过把我们实际传递的实参用一个元组 args 来接受，这样完成可变确定的参数传值 1234567891011121314def test(*args): num = 1 if len(args) == 0: print(&quot;该可变位置参数没有传值&quot;) for i in args: print(f&quot;该可变位置参数参数的第&#123;num&#125;个元素是:&#123;i&#125;&quot;) num += 1 print(f&quot;args的值为:&#123;args&#125;, args的类型为:&#123;type(args)&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test() print(&quot;**********************&quot;) test(10, 20, 30, [40]) 返回 以上不难看出 args 类型为 tuple 元组类型；并且可以不传实参给他，那么 args 就为空元组 可变位置参数的混搭很明显，实际需要和可变位置参数的混搭完成函数的功能多样性 可变位置参数可以和之前的参数任何一种或几种进行混搭，前提是依旧要满足他们各自的规则。 12345678910111213def test(arg1, *args, arg3=3): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;args&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;arg3&#125;&quot;) print(&quot;---------------------&quot;)if __name__ == &#x27;__main__&#x27;: test(1, [], &#123;&#125;, &quot;&quot;, 30) print(&quot;**********************&quot;) test(1, [], &#123;&#125;, &quot;&quot;, arg3=30) 返回 以上不难看出可变位置参数本质上扮演者位置参数角色，如果要给之后的默认参数传值就得使用关键字参数进行传值，否则会默认把之后的参数都传入可变参数的元组里 可变参数混搭位置参数如果某些位置参数在可变参数之后，那么一定要以关键字参数形式进行传参 1234567891011121314def test(*args, arg2): print(f&quot;第一个参数是:&#123;args&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;)if __name__ == &#x27;__main__&#x27;: test(1, [], &#123;&#125;, arg2=20) print(&quot;**********************&quot;) try: test(1, [], &#123;&#125;, 20) except TypeError as t: print(t) 返回 以上不难看出如果不以关键字形式进行传参，那么就会报缺少关键字参数的错误 可变位置参数依旧可以打破默认参数在位置参数之后的限制，但可变参数前的参数依旧要满足默认参数位限制（参考上面介绍）但是 123456789101112def test(arg1, arg2=2, *args): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;args&#125;&quot;) print(&quot;---------------------&quot;)if __name__ == &#x27;__main__&#x27;: test(1, 20, [], &#123;&#125;) print(&quot;**********************&quot;) 返回 以上不难看出默认参数的默认值修改了。系统并没有把 20 传入元组作为 args。所以当出现打破默认参数位置限制的时，默认参数传值不能进行关键字参数进行传递，情况如下 第一种情况是关键字参数在前对默认参数进行赋值，很明显违背位置参数要在关键字参数之前的规则 1234567891011def test(arg1, arg2=2, *args): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;args&#125;&quot;) print(&quot;---------------------&quot;)if __name__ == &#x27;__main__&#x27;: test(1, arg2=20, [], &#123;&#125;) 报错信息 第二种情况是默认参数放在了后面，但是结合上面的分析，即时关键字参数放在最后，依旧要满足位置对应关系 12345678910111213def test(arg1, arg2=2, *args): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;args&#125;&quot;) print(&quot;---------------------&quot;)if __name__ == &#x27;__main__&#x27;: try: test(1, [], &#123;&#125;, arg2=20) except TypeError as t: print(t) 报错信息 很明显提示 arg2 之前已经赋值了[] ,，所以重复赋值 注意可变位置参数不能和强制关键字参数进行混搭，否则编译不通过 可变关键字参数实际中如果我们要传入一组参数名和参数值不确定的参数时，我们可以用可变关键字参数进行定义 使用方式：在定义形参的名字前写上 ** def test(**kwargs) 该可变关键字参数通过把我们实际传递的实参用一个字典 kwargs 来接受，这样完成可变确定的参数传值 1234567def test(**kwargs): print(f&quot;可变关键字参数是:&#123;kwargs&#125;, 类型是:&#123;type(kwargs)&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test() print(&quot;**********************&quot;) test(first=10, second=20) 返回 以上不难看出返回的是一个实参输入的参数名-参数值得字典键值对，kwargs 类型是 dict 类型 可变关键字参数的混搭可变关键字参数的混搭顺序，一定是在所有参数类型最后再定义，理由很简单：因为是用关键字参数进行传递，那么不能在默认参数和位置参数之前，这两者就包含了可变位置参数。特殊地依旧不能在强制关键字之前定义，因为不知道后面的关键字参数是否是传给 kwargs，还是本身 强制位置参数（3.8新特性）用法 &#x2F; 强制位置表示在 &#x2F; 之前一定要使用位置参数，不接受使用关键字参数 123456789101112131415def test(arg1, arg2=2, /, arg3=3): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;arg3&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test(10, 20, arg3=30) print(&quot;**********************&quot;) try: test(arg1=10, arg2=20, arg3=30) except TypeError as t: print(t) 返回 以上不难看出如果用关键字参数给 &#x2F; 之前的参数赋值，那么会报错 强制位置参数不能在可变位置参数之后定义 强制位置参数不能在可变关键字参数之后定义 强制位置参数很明显应该放在强制关键字参数之前定义，否则引发矛盾 解包（开包）python 可以通过 * 对列表或元组进行解包，通过 ** 对字典进行解包 1234567891011def test(): list1 = [1, 2, 3] tuple1 = (1, 2, 3) dict1 = &#123;&quot;first&quot;: 1, &quot;second&quot;: 2, &quot;third&quot;: 3&#125; print(*list1) print(*tuple1) print(*dict1)if __name__ == &#x27;__main__&#x27;: test() 返回 通过以上发现，解包无非是对序列进行进行遍历。注意 * 号对字典解包是取它的 keys 解包的应用此应用于传参中 1234567891011121314def test(arg1, arg2, arg3): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;arg3&#125;&quot;)if __name__ == &#x27;__main__&#x27;: args1 = [1, 2, 3] args2 = (1, 2, 3) test(*args1) print(&quot;**********************&quot;) test(*args2) 返回 这样传参可以瞬间传递自动遍历 通过解包可以使得可变位置参数和可变关键字参数传参变得灵活容易起来 可变位置参数 1234567891011def test(*args): print(f&quot;解包参数是:&#123;args&#125;&quot;) print(*args)if __name__ == &#x27;__main__&#x27;: args1 = [1, 2, 3, 4] args2 = (1, 2, 3) test(*args1) print(&quot;**********************&quot;) test(*args2) 返回 可变关键字参数 1234567def test(**kwargs): print(f&quot;解包参数是:&#123;kwargs&#125;&quot;)if __name__ == &#x27;__main__&#x27;: args = &#123;&quot;first&quot;: 1, &quot;second&quot;: 2&#125; test(**args) 返回 函数的返回值python 是弱类型语言，对返回值没有定性的要求，可以返回 None，可以不写 return 语句默认返回 None，可以有多个返回值，但是要在一个 return 语句中实现，并且这多个返回值以元组形式返回 123456789101112131415161718def test_not_return(): passdef test_return_None(): returndef test_return_single(): return 1def test_return_diff(): return 1, 2., &quot;&quot;, [], (), &#123;&#125;if __name__ == &#x27;__main__&#x27;: print(test_not_return()) print(test_return_None()) print(test_return_single()) print(test_return_diff()) 返回 以上可以看到 方法可以没有返回值，可以没有 return 语句，可以有多个不同类型返回值，多个返回值确实以元组形式返回 函数的类型普通函数普通函数属于自定义函数，满足函数规则即可 匿名函数python 支持匿名函数，即函数名未知地定义，使用 lambda 表达式来定义 匿名函数定义方式lambda [arg1 [,arg2, … argN]] : expression 以上可以看出 lambda 表达式参数可以多个，但是只能有一个返回表达式 一般 lambda 表达式用于简单的方法场合 1234test = lambda x, y: x ** yprint(test.__class__)print(test)print(test(3, 2)) 以上发现 lambda 表达式就是一个 function （python中具体为 types.FunctionType）类的对象 内部函数一般来说，函数内部也可以定义新的函数。那么我们称这个函数为内部函数或局部函数 内部函数的本质就是局部变量(函数就是一个变量)。在函数外部不可以直接调用（闭包机制可以打破）。内部函数在函数内部调用 12345678910111213141516171819def test1(): print(1) def test2(): print(2) def test3(): print(3) test3() def test3(): pass test2()if __name__ == &#x27;__main__&#x27;: test1() 返回 以上我们可以看出内部函数可以嵌套，因为本质是局部变量我们依旧可以在外部定义一个和内部重名的函数 高阶函数高阶函数本质也是普通函数，只不过 python 强调一切皆为对象，那么函数本身也是一个对象。怎么证明呢 12345def test(): passif __name__ == &#x27;__main__&#x27;: print(type(test)) 返回 这时会发现 test 为function类的实例对象。但是查阅资料知道 function 类引用被 del 了，只不过被一个类沿用，那就是 types 模块的 FunctionType 类 那根据参数传递的本质就是传递一个个对象，那么函数依旧可以作为对象传入方法中，其中接收函数参数的方法就被称为高阶函数 12345678910def test(x): if x &gt; 1: return True else: return Falseif __name__ == &#x27;__main__&#x27;: result = filter(test, [1, 2, 3]) print(list(result)) 返回 从上面可以分析出，filter()内置函数把 test 作为参数传入进了方法里 偏函数偏函数使用情形函数在执行时，要带上所有必要的参数进行调用。但是，有时参数可以在函数被调用之前提前获知。这种情况下，一个函数有一个或多个参数预先就能用上，以便函数能用更少的参数进行调用。 偏函数使用方法：要用到 functools 模块的 partial 方法 123456789101112from functools import partialdef test(x, y): if x &gt; y: return True else: return Falseif __name__ == &#x27;__main__&#x27;: result = partial(test, 5) print(result(100)) 返回 很明显看出，我们已知 x &#x3D; 5，的前提下，把偏函数作为一个新函数进行传参就可以得到结果。从上面看出偏函数本质也是高阶函数 回调函数由于讲了函数可以作为参数传入，那么回调函数的作用就是把自身作为参数传入到一个新函数中，利用新函数的其他参数作为自身的参数进行操作 12345678910def test1(a): print(a)def callback(function_name, b): function_name(b)if __name__ == &#x27;__main__&#x27;: callback(test1, &quot;我是回调函数&quot;) 返回 回调函数的异步处理pass 回调函数的本质原因回调函数之所以能这么使用是因为所有 函数都是 types.FunctionType 类的实例对象，而 python 提供了一个魔法方法 __call__()，这样可以使得他的对象都可以用对象名(args)进行使用。前提是一定要显示地写出来。 1234567class A: def __call__(self, name, **kwargs): print(name)if __name__ == &#x27;__main__&#x27;: test = A() test(&quot;这就是函数带括号的底层原理&quot;) 返回 以上不难看出我们的 test 对象竟然也可以写成 test()了，因为我们在 A 类里重写了 __call__() 方法，使得 test 对象可以作为函数名使用，同理这适用于回调函数语法。所以本质回调函数依旧是一种高阶函数 函数的闭包python 如果我们想对一个函数本身进行操作，那么那个操作本身也是函数。所以 python 提供函数内嵌套函数。通过这种方法我们能很好地处理不同函数的类似问题。通过闭包我们能在外部使用函数内的局部代码块了。 123456789101112131415def outer(a): a = a + 1 print(id(a)) def inner(b): print(id(a)) print(b + a) return innerinner1 = outer(a=7)inner1(b=5)inner2 = outer(a=8)inner2(b=5) 返回 由上面可以看到闭包机制一个特点是对每一次的局部变量的值可以保留在内层函数里。具体请参考Python 内存详解 装饰器python 提供的一种语法构造，由于之前分析的 闭包机制，那么我们想把一个函数对象当做参数传入到闭包机制中，那么 python 提供装饰器语法这样不用每次把原函数指向闭包后的新函数。这个闭包函数我们就称之为装饰器 装饰器的使用方法本质是将所装饰的函数对象作为参数传输到装饰器函数中去。 1234567891011121314151617181920212223import timedef calculate_runtime(method): start = time.time() method() end = time.time() print(end - start)def play_game(): for i in range(200000): pass print(&quot;游戏打完了&quot;)def shopping(): for i in range(80000): pass print(&quot;东西打完了&quot;)if __name__ == &#x27;__main__&#x27;: calculate_runtime(play_game) calculate_runtime(shopping) 返回 很明显这种方式处理函数会有局限性，因为我们只想对函数功能进行添加，当自己运行函数的时候就可以 1234567891011121314151617181920212223242526import timedef calculate_runtime(method): def run(): start = time.time() method() end = time.time() print(end - start) return rundef play_game(): for i in range(200000): pass print(&quot;游戏打完了&quot;)def shopping(): for i in range(80000): pass print(&quot;东西打完了&quot;)if __name__ == &#x27;__main__&#x27;:play_game = calculate_runtime(play_game)play_game()print(&quot;*&quot;*50)shopping = calculate_runtime(shopping)shopping() 返回 ​ 装饰器的语法糖这种方式比上一种好的是，我能直接运行原来的函数使得功能性不一样了，但是每次都用 method &#x3D; function(method) 太麻烦了。在定义函数体上方用 @装饰器名去装饰所定义的函数，我们称之为 语法糖。 1234567891011121314151617181920212223242526272829import timedef calculate_runtime(method): def run(): start = time.time() method() end = time.time() print(end - start) return run@calculate_runtimedef play_game(): for i in range(200000): pass print(&quot;游戏打完了&quot;)@calculate_runtimedef shopping(): for i in range(80000): pass print(&quot;东西打完了&quot;)if __name__ == &#x27;__main__&#x27;: play_game() print(&quot;*&quot;*50) shopping() 返回 装饰器内部的参数设置以上例子有大量的局限性：被装饰的方法没有参数。如果被装饰的方法有参数，并且参数不唯一且可变呢。那么我们直接使用我们的可变位置参数和可变强制参数来传值 12345678910111213141516171819202122import timedef calculate_runtime(method): def run(*args, **kwargs): start = time.time() method(*args, **kwargs) end = time.time() print(end - start) return run@calculate_runtimedef play_game(game, times=200000): for i in range(times): pass print(f&quot;游戏&#123;game&#125;打完了&quot;)if __name__ == &#x27;__main__&#x27;: play_game(&quot;csgo&quot;, 100000) 返回 有参装饰器我们发现装饰器虽好，但是我们需要的功能比较多的时候，需要用到外部其他变量的时候，其中内部 warpper() 和外部的 outer() 方法都不能添加其他额外的参数，因为写法已经固定了。所以我们可以通过外层嵌套另外一层函数来实现 1234567891011121314151617181920212223242526import timedef argument_(sleep_time): def calculate_runtime(method): def run(*args, **kwargs): start = time.time() method(*args, **kwargs) time.sleep(sleep_time) end = time.time() print(end - start) return run return calculate_runtime@argument_(2)def play_game(game, times=200000): for i in range(times): pass print(f&quot;游戏&#123;game&#125;打完了&quot;)if __name__ == &#x27;__main__&#x27;: play_game(&quot;csgo&quot;, 100000) 返回 以上我们不难看出通过这种方法成功实现了再次操控被装饰的函数 伪装原函数我们要想达到对原函数的完全装饰而让外部不察觉出来，我们可以通过伪装原函数进行实现。 第一个例子如下 123456789101112131415161718192021222324import timedef calculate_runtime(method): def run(*args, **kwargs): start = time.time() method(*args, **kwargs) end = time.time() print(end - start) return run@calculate_runtimedef play_game(game, times=200000): for i in range(times): pass print(f&quot;游戏&#123;game&#125;打完了&quot;) return &quot;该去吃饭了&quot;if __name__ == &#x27;__main__&#x27;: result = play_game(&quot;csgo&quot;, 100000) print(result) 返回 很明显，该函数没有返回值，这样没办法达到不改变其函数的内部性质 第二个例子 1234567891011121314151617181920212223import timedef calculate_runtime(method): def run(*args, **kwargs): start = time.time() method(*args, **kwargs) end = time.time() print(end - start) return run@calculate_runtimedef play_game(game, times=200000): for i in range(times): pass print(f&quot;游戏&#123;game&#125;打完了&quot;)if __name__ == &#x27;__main__&#x27;: print(play_game.__name__) print(play_game.__str__()) 返回 很明显，由于装饰器本质是闭包，那么使用装饰器后，函数的引用指向了内部的方法，所以很多函数的属性值会跟着变化。 以上例子说明了我们没有真正地实现不改变函数的内部属性来实现额外的功能。我们可以通过调用 functools 的 warps() 装饰器来装饰内部的函数使得原来函数的属性不改变，原理就是提前在内部拷贝一份原来函数的所有属性值。函数的返回值我们直接用一个变量来接收并返回 1234567891011121314151617181920212223242526272829import timeimport functoolsdef calculate_runtime(method): @functools.wraps(method) def run(*args, **kwargs): start = time.time() result = method(*args, **kwargs) end = time.time() print(end - start) return result return run@calculate_runtimedef play_game(game, times=200000): for i in range(times): pass print(f&quot;游戏&#123;game&#125;打完了&quot;) return &quot;该吃饭了&quot;if __name__ == &#x27;__main__&#x27;: result = play_game(&quot;cf&quot;, 30000) print(result) print(play_game.__name__) print(play_game.__str__()) 返回 装饰器模板我们发现装饰器有共同的结构，这样就形成了一个装饰器模板 1234567def outer_(*arg, **kwarg): def outer(functions): def warpper(*args, **kwargs): result = functions(*args, **kwargs) return result return warpper return outer 以上就构成了一个有参装饰器的模板了 多个装饰器装饰一个函数当多个装饰器装饰一个函数那么执行顺序是什么呢 12345678910111213141516171819202122232425262728293031323334def outer_1(*arg, **kwarg): def outer(functions): def warpper(*args, **kwargs): print(&quot;这是 outer_1 之前&quot;) result = functions(*args, **kwargs) print(&quot;这是 outer_1 之后&quot;) return result return warpper return outerdef outer_2(*arg, **kwarg): def outer(functions): def warpper(*args, **kwargs): print(&quot;这是 outer_2 之前&quot;) result = functions(*args, **kwargs) print(&quot;这是 outer_2 之后&quot;) return result return warpper return outer@outer_2()@outer_1()def test(): passif __name__ == &#x27;__main__&#x27;: test() 返回 以上我们不难看出装饰顺序是先用最靠近函数的 outer_1() 装饰器然后是 outer_2() 装饰器 通过栈的压栈和出栈可以解释以上返回值 调用 test() 本质是执行 outer_2.outer(outer_1.outer(test)) 压栈原理，程序执行到 outer_2.outer()后会先执行 print(&quot;这是 outer_2 之前&quot;) 然后碰到 funtions此时传入 outer_1.outer 进行执行 print(&quot;这是 outer_1 之前&quot;) 接着执行原函数 然后执行接着第 3 步骤的print(&quot;这是 outer_1 之后&quot;) 等 outer_1.outer()执行完毕就会得到 result 的返回值。注意这里的 result 并不是直观意义上的 outer_1.outer 这个引用，而是多重调用装饰器，内部优化成 outer_1.outer (test)()，这样 outer2.outer 里的接收的返回值其实本质就是 outer1.outer 里的 result 的值 最后再执行 outer_2 的print(&quot;这是 outer_2 之后&quot;) 装饰器的本质以上可以看到装饰器本质就是闭包，只不过参数变为了被装饰的函数。","tags":"python 函数 方法"},{"title":"python 驻留机制","url":"/2022/12/08/python/python 驻留机制/","text":"参考链接http://t.zoukankan.com/hiyong-p-14999364.html 引入原因在 Python 内存机制中，为了避免重复开辟新的内存空间造成的性能浪费，引入了一个机制叫驻留机制 内存机制有关参考 Python 内存详解 定义新建的变量中，仅保存一份副本，多个对象共享该副本，驻留只针对不可变数据类型，比如字符串，布尔值，数字，元组。在这些固定数据类型处理中，使用驻留可以有效节省时间和空间，当然在驻留池中创建或者插入新的内容会消耗一定的时间。 发生环境 交互模式下会发生驻留机制 pycharm 和 python python.py 文件模式运行解释器进行了优化，返回结果并不为发生了驻留机制 在交互模式下驻留机制的几种情况字符串长度为0或1时 交互模式下 pycharm模式下 12345678def test_intern(): a = &quot;$&quot; b = &quot;$&quot; print(a is b)if __name__ == &#x27;__main__&#x27;: test_intern() 返回 命令行模式下 符合标识符的字符串(字母，数字，下划线)这意味着不符合标识的字符串不会驻留 交互模式下 pycharm 模式下 1234567891011def test_intern(): a = &quot;_hello1&quot; b = &quot;_hello1&quot; print(a is b) a = &quot;$_hello1#&quot; b = &quot;$_hello1#&quot; print(a is b)if __name__ == &#x27;__main__&#x27;: test_intern() 返回 命令行模式下 编译时会发生驻留这意味着运行不会发生驻留 python 优化了类似 str1+str2，str1*int 等生成的字符串默认驻留。前提是字面量赋值。 交互模式下 pycharm 模式下 1234567891011121314def test_intern(): a = &quot;hello&quot; b = &quot;HELLO&quot; c = b.lower() d = &quot;hel&quot; + &quot;lo&quot; print(f&quot;c:&#123;c&#125;&quot;) print(f&quot;d:&#123;d&#125;&quot;) print(&quot;-----------------&quot;) print(a is c) print(a is d)if __name__ == &#x27;__main__&#x27;: test_intern() 返回 命令行模式下 值得注意的是这次 pycharm 和命令行不再对这种情况进行优化 如果换成是变量相加的话驻留机制不会产生 123456789101112def test_intern(): a = &quot;hello&quot; b = &quot;he&quot; c = &quot;llo&quot; d = b + c print(f&quot;a:&#123;a&#125;&quot;) print(f&quot;d:&#123;d&#125;&quot;) print(&quot;-----------------&quot;) print(a is d)if __name__ == &#x27;__main__&#x27;: test_intern() 返回 数字类型区间位于 -5~256 时会进行驻留这意味着在此区间外将不会驻留 交互模式 pycharm 模式下 1234567891011121314151617def test_intern(): a = -5 b = -5 print(a is b) a = -6 b = -6 print(a is b) a = 256 b = 256 print(a is b) a = 257 b = 257 print(a is b)if __name__ == &#x27;__main__&#x27;: test_intern() 返回 命令行模式 元组类型的驻留元组类型当元组为空，或者元组中只有一个元素且元素范围满足上述字符串和数字驻留规则会驻留 由于元组不可变不存在增加元素，则不存在 运行时不驻留的特点 交互模式下 pychram 模式下 1234567891011121314151617181920212223242526272829303132333435def test_intern(): a = () b = () print(a is b) a = (-5,) b = (-5,) print(a is b) a = (256,) b = (256,) print(a is b) a = (-6,) b = (-6,) print(a is b) a = (257,) b = (257,) print(a is b) a = (&quot;%&quot;,) b = (&quot;%&quot;,) print(a is b) a = (&quot;_hello&quot;,) b = (&quot;_hello&quot;,) print(a is b) a = (&quot;#hello&quot;,) b = (&quot;#hello&quot;,) print(a is b) a = ([]) b = ([]) print(a is b) a = (1, 2) b = (1, 2) print(a is b)if __name__ == &#x27;__main__&#x27;: test_intern() 返回 命令行模式下 强制驻留 使用 sys 模块 的 intern() 方法实现强制驻留 123456789101112import sysdef test_intern(): a = &quot;#hello&quot; b = &quot;&quot;.join(&quot;#hello&quot;) print(a is b) a = sys.intern(b) print(a is b)if __name__ == &#x27;__main__&#x27;: test_intern() 返回 注意情况避免频繁的创建和销毁，提升效率和节约内存，因此拼接和修改字符串是会比较影响性能的。因为是不可变的，所以字符串的操作都不是 replace，而是新建对象，这也是为什么拼接多字符串的时候不建议用+而用 join()，join() 是先计算出所有字符串的长度，然后再拷贝，只 new 一次对象。需要注意的是，并不是所有的字符串都会采用 intern机制，当且仅当只包含下划线、数字、字母的字符串才会被 intern","tags":"python 驻留机制"},{"title":"python 循环控制 break 和 continue","url":"/2022/12/08/python/python 循环控制 break 和 continue/","text":"一般来说 break 和 continute 控制的是本层循环，不影响外层循环，如若要退出则使用 return 语句进行 12345678910def test(): for i in range(2): for j in range(6): print(f&quot;j = &#123;j&#125;&quot;) if j &gt; 2: break print(f&quot;i = &#123;i&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test() 返回 由上看出，即时 break 了，依旧不会跳过外层循环","tags":"python 循环"},{"title":"python 字符串常用方法","url":"/2022/12/08/python/python 字符串常用方法/","text":"参考链接 https://www.bilibili.com/video/BV1wD4y1o7AS?p=78&amp;vd_source=f9937d98d0a8cc08ef5248c3c127d588 源码参考文档 Python 基本数据类型常用方法 查询操作 转换大小写 对齐字符串 字符串的拆分 字符串的判断 字符串的替换 比较字符串 其中 ord(str) 方法可以查看该字符的ASCII编码 12345def test(): print(ord(&quot;a&quot;)) if __name__ == &#x27;__main__&#x27;: test() 返回 格式化字符串和数字 字符串前缀r整个字符串都会被视为原生的字符串。其中的 \\ 转义将不再实现 123456789def test_str(): str_test = &quot;第一行\\n第二行&quot; print(str_test) str_test = r&quot;第一行\\n第二行&quot; print(str_test)if __name__ == &#x27;__main__&#x27;: test_str() 返回 b用来表示后面字符串是bytes 类型。网络编程中，服务器和浏览器只认bytes 类型数据 123456def test_str(): a = b&#x27;\\xe6\\xb5\\x8b\\xe8\\xaf\\x95&#x27; print(a.decode(encoding=&quot;UTF-8&quot;))if __name__ == &#x27;__main__&#x27;: test_str() 返回 u表示后面字符串采用的编码字符集为 unicode，现在内存中默认的编码格式为 unicode 在这个字符集里面所有的语言字符都可以通过特定的符号来表示。一般用在中文字符串前面，防止因为源码储存格式问题，导致再次使用时出现乱码。python3 中默认都是 unicode 编码格式 pass","tags":"python 常用方法 字符串"},{"title":"python 变量的作用域","url":"/2022/12/08/python/python 变量的作用域/","text":"参考链接 https://www.bilibili.com/video/BV1xv4y1S7ov/?spm_id_from=333.880.my_history.page.click&amp;vd_source=f9937d98d0a8cc08ef5248c3c127d588 https://www.bilibili.com/video/BV1vQ4y1D7Ct/?p=2&amp;spm_id_from=pageDriver&amp;vd_source=f9937d98d0a8cc08ef5248c3c127d588 https://www.runoob.com/python3/python3-namespace-scope.html https://blog.csdn.net/cadi2011/article/details/52457754 变量分为 内置变量，全局变量，类变量，实例变量，局部变量 python 使用变量作用域一般要遵循 LEGB（本地，上层嵌套，全局，内置） 内置变量概念和范围Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等 12345def test(): print(Exception)if __name__ == &#x27;__main__&#x27;: test() 返回 全局变量概念和范围模块内、所有方法外、所有类外。一般全局变量都不会在任何结构体内，一般位于 python 文件的最外层。可以被本模块的所有结构体给访问 12345678910111213141516171819202122global_arg = &quot;全局变量&quot;class A: @classmethod def test1(cls): print(f&quot;test1可以访问&#123;global_arg&#125;&quot;) def test2(): print(f&quot;test2可以访问&#123;global_arg&#125;&quot;) def test3(): print(f&quot;test3可以访问&#123;global_arg&#125;&quot;) test3() test2()if __name__ == &#x27;__main__&#x27;: A.test1() 返回 以上可以看出在一个类里的方法，和方法里的内部方法都可以访问最外层的 global_arg 全局变量 全局变量的声明如果是对局部变量 读 的操作，可以省去 global 关键字的声明，但是，为了区分局部变量和全局变量，建议使用全局变量都应该申明 global 123456789101112131415161718192021222324global_arg = &quot;全局变量&quot;class A: @classmethod def test1(cls): global_arg = &quot;局部变量1&quot; print(f&quot;test1可以访问&#123;global_arg&#125;&quot;) def test2(): global_arg = &quot;局部变量2&quot; print(f&quot;test2可以访问&#123;global_arg&#125;&quot;) def test3(): global_arg = &quot;局部变量3&quot; print(f&quot;test3可以访问&#123;global_arg&#125;&quot;) test3() test2()if __name__ == &#x27;__main__&#x27;: A.test1() 返回 从以上结果我们可以分析出当存在局部变量重名时优先使用的是局部变量 给全局变量声明 global 关键字 123456789101112131415161718192021222324global_arg = &quot;全局变量&quot;class A: @classmethod def test1(cls): global_arg = &quot;局部变量1&quot; print(f&quot;test1可以访问&#123;global_arg&#125;&quot;) def test2(): global global_arg print(f&quot;test2可以访问&#123;global_arg&#125;&quot;) def test3(): print(f&quot;test3可以访问&#123;global_arg&#125;&quot;) test3() test2()if __name__ == &#x27;__main__&#x27;: A.test1() 返回 通过以上信息发现，声明 global 关键字后该变量以后的所有局部作用域都会使用声明的全局变量 如果是对局部变量有操作，如赋值等的操作，一定不能 global 关键字的声明，否则会抛出 UnboundLocalError 错误 声明全局变量的好处声明全局变量的好处是避免未定义局部变量的异常，来看下面的例子 123456789101112global_arg = &quot;全局变量&quot;def test(): try: print(global_arg) global_arg = global_arg + &quot;局部变量&quot; except UnboundLocalError as u: print(u)if __name__ == &#x27;__main__&#x27;: test() 返回 global 正确使用方法即使 print(global_arg)在前，依旧无法打印出来，因为后面语句有赋值操作，解释器默认以为 global_arg 为局部变量，而又没有声明全局变量，则会抛出异常 以下为正确使用方法 1234567891011121314global_arg = &quot;全局变量&quot;def test(): global global_arg try: print(global_arg) global_arg = global_arg + &quot;局部变量&quot; except UnboundLocalError as u: print(u)if __name__ == &#x27;__main__&#x27;: test() print(global_arg) 返回 以上不难发现不会抛出异常了，并且全局变量的修改影响到了其他作用域 全局变量的其他性质全局全量还有一个性质，可以通过导包的方式给其他 python 模块使用，这使得自定义变量得以很好的跨模块使用 参考链接 https://www.byhy.net/tut/py/basic/14/ 建立两个文件一个 test_global1.py，一个为 test_global2.py 1234567891011121314151617181920212223242526272829303132# test_global1.pytest_int = 1test_list = [1, 2]def test(): global test_int, test_list test_int += 1 test_list.append(&quot;new&quot;) print(f&quot;test_global1.py中的test_int值:&#123;test_int&#125;&quot;) print(f&quot;test_global1.py中的test_int的id值:&#123;id(test_int)&#125;&quot;) print(&quot;===========================&quot;) print(f&quot;test_global1.py中的test_list值:&#123;test_list&#125;&quot;) print(f&quot;test_global1.py中的test_list的id值:&#123;id(test_list)&#125;&quot;)# test_global2.pyfrom test_global1 import test_int, test_list, testdef test_(): print(f&quot;test_global2.py的test_int值:&#123;test_int&#125;&quot;) print(f&quot;test_global2.py中的test_int的id值:&#123;id(test_int)&#125;&quot;) print(&quot;===========================&quot;) print(f&quot;test_global2.py中的test_list值:&#123;test_list&#125;&quot;) print(f&quot;test_global2.py中的test_list的id值:&#123;id(test_list)&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test() print(&quot;*&quot;*80) test_() 我们运行 test_global2.py 的后的结果 我们发现成功导包成功了，但是这并不是通常意义的全局共享，而是 python 新开辟了命名空间，但是可变对象类型并没有开启新的内存空间，于是列表可以跟随变化。 局部变量概念和范围局部变量其实是一个狭义的概念，是相对全局变量而言的。一般我们指函数内部新定义的变量为局部变量 12345678910arg = &quot;全局变量&quot;def test(): arg = &quot;局部变量&quot; print(arg)if __name__ == &#x27;__main__&#x27;: test() print(arg) 返回 以上不难发现，即使和全局变量重名，只要没有声明是 global，则它就是局部变量 由于是局部变量，那么外部无法访问内部的局部变量，但是我们可以通过 闭包 的方式来访问内部的局部变量。 参考Python 函数详解 关于函数闭包的详解 局部变量的声明局部变量本质如果想作为内部结构的全局变量而进行修改，但是又不能用 global 修饰符，因为那会声明一个全局变量，那我们就会用到另外一个关键字 nonlocal 12345678910111213141516171819202122232425262728293031arg = &quot;全局变量&quot;def test1(): arg = &quot;局部变量1&quot; def inner_test1(): arg = &quot;内部局部变量1&quot; print(arg) inner_test1() print(arg)def test2(): arg = &quot;局部变量2&quot; def inner_test(): nonlocal arg arg = &quot;内部局部变量2&quot; print(arg) inner_test() print(arg)if __name__ == &#x27;__main__&#x27;: test1() print(&quot;********************&quot;) test2() print(&quot;********************&quot;) print(arg) 返回 从以上返回信息我们不难看出如果不加 nonlocal 关键字，那么将不会对之前外部的局部变量进行修改。而添加了 nonlocal 关键字后可以对外层的局部变量进行修改了 值得注意的是：nonlocal 属于就近原则，默认声明上一层局部变量，所以函数嵌套不宜过多。 类变量概念和范围类变量本质是基于类的全局变量，但是它有独特的命名方式和访问权限 类变量作用于是在全类，通过 类名.变量名 访问或者 cls.变量名或者 self.变量名访问 1234567891011121314151617class A: class_arg = &quot;类变量&quot; def test1(self): print(A.class_arg) print(self.class_arg) @classmethod def test2(cls): print(A.class_arg) print(cls.class_arg)if __name__ == &#x27;__main__&#x27;: a = A() print(A.class_arg) a.test1() a.test2() 可以发现访问类变量的方式多种多样，单仅仅针对与该类或者它的子类或者外部用类名.变量名 的方式进行访问 类变量的命名特殊性类变量命名会影响其的作用域。 用 __ 双下划线开头，且不以 __ 双下划线结尾的变量命名方式那么我们称之为私有的类变量，然而由于 python 的机制，这种私有只是显式的私有，并不能真正的私有 参考Python 函数详解关于类方法的命名相关信息 123456789101112131415161718192021class A: __class_arg = &quot;私有类变量&quot; def test1(self): print(A.__class_arg) print(self.__class_arg) @classmethod def test2(cls): print(A.__class_arg) print(cls.__class_arg)if __name__ == &#x27;__main__&#x27;: a = A() a.test1() a.test2() try: print(A.__class_arg__) except AttributeError as a: print(a) 返回 ​ 以上不难看出通过私有化类变量后，外部对象 A 无法访问内部私有变量 __class_arg 实例变量概念和范围实例变量一般来说当且仅当针对类而言。 实例变量一般来说作用域也是整个类，但是实例变量的针对类的对象而言的，类变量是针对类而言的，虽然类的对象可以通过类指针的方式访问类变量，但是实例对象的访问必须是 self.，即对象本身去访问 1234567891011121314class A: def __init__(self, name): self.name = nameif __name__ == &#x27;__main__&#x27;: a = A(&quot;实例变量&quot;) print(a.name) try: print(A.name) except AttributeError as at: print(at) print(A(&quot;另一个实例变量&quot;).name) 返回 从上面我们可以看到实例变量一般由类的实例对象取访问，如果类本身去访问会报 AttributeError 实例变量的特殊性对于一个类来说，实例变量一般是在构造方法中定义，因为类的初始化过程中一般要主动调用构造方法 __init__()，但是也可以在其他类的方法里构造实例方法，但不建议这么使用，因为不一定会调用其他类的方法 1234567891011121314151617class A: def __init__(self, name): self.name = name def test(self): self.age = 10if __name__ == &#x27;__main__&#x27;: a = A(&quot;实例变量&quot;) try: print(a.age) except AttributeError as at: print(at) a.test() print(a.age) 返回 以上不难发现可以在其他函数里定义实例变量，但是一定要运行了该函数才能被对象调用 总结python 一切皆为对象，那么类和函数依旧是对象，也可以作为变量传值。但是依旧会遵守上面相关的规定 参考Python 函数详解关于高阶函数对于函数作为变量的解释 参考Python 类详解关于","tags":"python 变量"},{"title":"python 基本数据类型常用方法","url":"/2022/12/07/python/python 基本数据类型常用方法/","text":"参考链接以下数据类型有些内容会涉及内存驻留机制，请参考 Python 驻留机制 https://www.cnblogs.com/laizhenghua/articles/12875044.html 基本数据类型分类基本数据类型有 数字类型（int，float，complex），字符串类型（str），列表类型（list）元组（tuple），字典（dict），集合（set） 数字类型—&gt;不可变类型 pass 字符串类型—&gt;不可变类型 这代表着以下方法如若修改列表，str 的 id(str) 值会更改，与 list不同。 字符串具体操作方法请 Python 字符串常用方法介绍 字符串切片str[n] 表示正数获取字符串的元素，表示从左往右数第 n+1 个元素: 123456def test():` `test_str = &quot;junliangl&quot;` `print(test_str[3])``if __name__ == &#x27;__main__&#x27;:` `test()` 输出 str[-n] 表示负数获取字符串的元素，表示从右往左数第 n 个元素 123456def test(): test_str = &quot;junliangl&quot; print(test_str[-2])if __name__ == &#x27;__main__&#x27;: test() 输出 str[m:n] 表示从 m+1 取到第 n 的元素，不包含第 n 个元素（左闭右开原则）。如果截取不到，那么则返回空串 &quot;&quot; 12345678def test(): test_str = &quot;junliangl&quot; print(test_str[0:0]) print(test_str[0:1]) print(test_str[2:5])if __name__ == &#x27;__main__&#x27;: test() 输出 str[:n] 表示取第 1 个 到第 n 的元素，不包含第 n 个元素；str[n:] 表示取第 n+1 个 到最后一个元素 12345678def test(): test_str = &quot;junliangl&quot; print(test_str[:-2]) print(test_str[2:]) print(test_str[:-10])if __name__ == &#x27;__main__&#x27;: test() 输出 str[a : b : c] 如果 c 不写或者为正，则按照正方向截取。就代表着 a &lt; b，否则返回空串 1234567def test(): test_str = &quot;junliangl&quot; “print(test_str[2:6:]) print(test_str[6:2:3])if __name__ == &#x27;__main__&#x27;: test() 输出 如果 c 为负，则按照反方向截取。就代表着 a &gt; b ，否则返回空串 12345678def test(): test_str = &quot;junliangl&quot; print(test_str[8:4:-3]) print(test_str[-2:-7:-2]) print(test_str[-6 : -1 : -1])if __name__ == &#x27;__main__&#x27;: test() 输出 应用 str[::-1] 直接表示字符串反串 字符串其他常用方法 len() 方法求字符串长度 1234567def test(): test_str = &quot;junliangl&quot; print(len(test_str))if __name__ == &#x27;__main__&#x27;: test() 返回 lower() 与 upper() 表示字符串字母全变为小写和大写 12345678def test(): test_str = &quot;JUNliangL&quot; print(test_str.lower()) print(test_str.upper())if __name__ == &#x27;__main__&#x27;: test() 返回 startwith(str) 和 endwith(str) 表示是否以某一子串开始或结尾 1234567def test(): test_str = &quot;JUNliangL&quot; print(test_str.startswith(&quot;JUN&quot;)) print(test_str.endswith(&quot;GL&quot;))if __name__ == &#x27;__main__&#x27;: test() 输出 join(s) 方法表示以指定字符串结合 12345678def test(): test_str = &quot;----&quot; print(test_str.join(&quot;1234&quot;)) print(test_str.join([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;]))if __name__ == &#x27;__main__&#x27;: test() 输出 replace(old_str，new_str，count) 表示把 old_str 子串替换成 new_str ，count是替换数量，默认值是替换全部 1234567891011121314def test(): old_test_str = &quot;junliangl bad bad bad&quot; print(old_test_str) print(id(old_test_str)) print(&quot;----------------&quot;) new_test_str = old_test_str.replace(&quot;bad&quot;, &quot;good&quot;) print(new_test_str) print(id(new_test_str)) print(&quot;----------------&quot;) print(new_test_str.replace(&quot;good&quot;, &quot;bad&quot;, 2))if __name__ == &#x27;__main__&#x27;: test() 输出 很明显看出 replace() 方法不改变原来的字符串，创建了一个新的对象指向不同的字符串常量。 count(str，start，end) 表示计算 str 子串在原来字符串中出现的次数。start 和 end 控制返回，默认值则代表整个字符串范围 123456789def test(): test_str = &quot;junliangl bad bad bad good good&quot; print(test_str.count(&quot;bad&quot;, 9, 13)) print(test_str.count(&quot;good&quot;)) print(test_str.count(&quot;bad&quot;))if __name__ == &#x27;__main__&#x27;: test() 返回 split(str，count) 表示当前字符串以什么子串分隔，返回值为一个字符串列表 list。count 表示分隔几次，默认值是全部。没有子串则返回字符串列表 1234567891011def test(): test_str = &quot;junliangl bad bad bad good good&quot; print(test_str.split(&quot; &quot;)) test_str = &quot;junliangl,bad,bad,bad,good,good&quot; print(test_str.split(&quot;,&quot;, 2)) test_str = &quot;junliangl,bad,bad,bad,good,good&quot; print(test_str.split(&quot;.&quot;))if __name__ == &#x27;__main__&#x27;: test() 返回 strip(str) 表示当前字符串去除以 str 子串开头和结尾。默认参数则去除首尾的空白字符(空格、\\n、\\t) 1234567891011121314def test(): old_test_str = &quot;123 junliangl 123&quot; print(id(old_test_str)) print(old_test_str) print(&quot;-----------------&quot;) new_test_str = old_test_str.strip(&quot;123&quot;) print(old_test_str) print(id(new_test_str)) print(new_test_str) print(new_test_str.strip())if __name__ == &#x27;__main__&#x27;: test() 输出 很明显看出 strip() 方法不改变原来的字符串，创建了一个新的对象指向不同的字符串常量。 isdigit() 表示如果字符串只包含数字，是则返回 True，否则返回 False 123456789def test(): test1_str = &quot;junliangl 123&quot; test2_str = &quot;123&quot; print(test1_str.isdigit()) print(test2_str.isdigit())if __name__ == &#x27;__main__&#x27;: test() 返回 encode(encoding=)对字符串进行编码，encoding 填写编码格式。decode(encoding=)对字符串解码 1234567891011def test_str(): str_test = &quot;测试&quot; encode = str_test.encode(encoding=&quot;GBK&quot;) print(encode) new_str = encode.decode(encoding=&quot;GBK&quot;) print(new_str) print(b&#x27;\\xb2\\xe2\\xc6\\xd4&#x27;.decode(encoding=&quot;GBK&quot;))if __name__ == &#x27;__main__&#x27;: test_str() 返回 列表类型—&gt;可变类型 这代表着以下方法如若修改列表，列表的 id(list)值不变，与 str 类型不同 列表切片 list[n] 索引取值遵循字符串规则 12345678def test(): test_list = [&#x27;junliangl&#x27;, 1, [1, 2]] print(test_list[0]) print(test_list[-1])if __name__ == &#x27;__main__&#x27;: test() 返回 list[a:b:c] 切片类似 str 12345678910111213def test(): test_list = [&#x27;junliangl&#x27;, 1, [1, 2], &#x27;best&#x27;, &#x27;good&#x27;] print(test_list[:3]) print(test_list[3:]) print(test_list[:-3]) print(test_list[-3:]) print(test_list[1:-2]) print(test_list[1:4:1]) print(test_list[-2:-4:-1])if __name__ == &#x27;__main__&#x27;: test() 返回 len(list) 代表列表长度 1234567def test(): test_list = [&#x27;junliangl&#x27;, &#x27;best&#x27;, &#x27;good&#x27;] print(len(test_list))if __name__ == &#x27;__main__&#x27;: test() 返回 append(s) 代表往列表末尾追加一个元素 s。改变列表后，列表地址不变，以下的方法同理 12345678910def test(): test_list = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;] print(id(test_list)) test_list.append(&#x27;4&#x27;) print(id(test_list)) print(test_list)if __name__ == &#x27;__main__&#x27;: test() 返回 insert(index，obj) 表示往当前列表 index 处替换为 obj，其他元素后移。若 index &gt;&#x3D; len(list)，则在末尾处添加；若 index &lt;&#x3D; -len(list)，则在首部添加。 123456789101112131415def test(): test1_list = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;] test2_list = [1, 2, 3] test1_list.insert(-1, &#x27;4&#x27;) print(test1_list) test2_list.insert(2, 4) print(test2_list) test1_list.insert(100, &#x27;5&#x27;) print(test1_list) test2_list.insert(-100, 5) print(test2_list) if __name__ == &#x27;__main__&#x27;: test() 输出 extend(iterable) 表示往当前列表末尾添加一个序列而不是序列本身 123456789101112def test(): test1_list = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;] test2_list = [1, 2, 3] test1_list.append(test2_list) print(test1_list) test1_list = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;] test1_list.extend(test2_list) print(test1_list) if __name__ == &#x27;__main__&#x27;: test() 返回 del(list[a:b:c]) 表示删除列表选择的元素 12345678def test(): test_list = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;] del test_list[-1::-2] print(test_list)if __name__ == &#x27;__main__&#x27;: test() 返回 pop(index) 表示按照 index 删除，默认值为删除末尾的元素 12345678910def test(): test_list = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;] test_list.pop(-2) print(test_list) test_list.pop() print(test_list)if __name__ == &#x27;__main__&#x27;: test() 返回 remove(obj) 表示按照元素对象删除，默认删除寻找到的第一个元素 1234567def test(): test_list = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;1&#x27;] test_list.remove(&#x27;1&#x27;) print(test_list)if __name__ == &#x27;__main__&#x27;: test() 返回 count(obj, start, end) 统计某个元素在当前列表出现的次数 12345678def test(): test_list = [1, 2, 3, 2, 3, 3] print(test_list.count(2)) print(test_list.count(3))if __name__ == &#x27;__main__&#x27;: test() 返回 index(obj，start，end) 表示从 list[start] --- list[end] 之间的 obj 出现在 list 的第一个索引值， 找不到的话抛出 ValueError 1234567891011def test(): test_list = [1, 2, 3, 4, 5, 6] try: print(test_list.index(5, 1, 3)) except ValueError as v: print(v) print(test_list.index(4, 0, 5))if __name__ == &#x27;__main__&#x27;: test() 返回 clear() 表示清空列表中的元素 123456789def test(): test_list = [1, [1, 2], 3] test_list[1].clear() print(test_list) test_list.clear() print(test_list)if __name__ == &#x27;__main__&#x27;: test() 返回 reverse() 表示反转列表中的元素等价 list[::-1] 12345678910def test(): test_list = [1, [1, 2], 3] test_list[1].reverse() print(test_list) test_list.reverse() print(test_list)if __name__ == &#x27;__main__&#x27;: test() 返回 sort() 表示对列表进行排序，要保持类型一致，否则会报错 12345678910111213def test(): test1_list = [2, 3, 51, 10, 9] test2_list = [12, &#x27;&#x27;] test1_list.sort() print(test1_list) try: test2_list.sort() print(test2_list) except TypeError as t: print(t)if __name__ == &#x27;__main__&#x27;: test() 返回 关于 list 的拷贝参考链接 Python 内存详解关于python的列表的内存机制 赋值拷贝直接将对象(地址)赋值传递给新的对象。这样更改原来的元素都会影响赋值拷贝后的列表 123456789101112131415def test(): test1_list = [1, [1, 2], [3, 4]] test2_list = test1_list print(id(test1_list)) print(test1_list) print(&quot;---------------------&quot;) print(id(test2_list)) print(test2_list) print(&quot;---------------------&quot;) test1_list[1][0] = 10000 print(test1_list) print(test2_list)if __name__ == &#x27;__main__&#x27;: test() 返回 浅拷贝浅拷贝即未对所有层的内容进行拷贝，即其中包含赋值拷贝，即使他们的 id 值不一样。以下有几种使用方式 for循环依次赋值 123456789101112131415161718def test(): old = [1, [1, 2, 3], 3] new = [] for i in range(len(old)): new.append(old[i]) print(id(old)) print(old) print(&quot;---------------------&quot;) print(id(new)) print(new) new[0] = 3 new[1][0] = 3 print(&quot;---------------------&quot;) print(old) print(new)if __name__ == &#x27;__main__&#x27;: test() 返回 使用copy() 方法 12345678910111213141516def test(): old = [1, [1, 2, 3], 3] new = old.copy() print(id(old)) print(old) print(&quot;---------------------&quot;) print(id(new)) print(new) new[0] = 3 new[1][0] = 3 print(&quot;---------------------&quot;) print(old) print(new)if __name__ == &#x27;__main__&#x27;: test() 返回 使用切片 12345678910111213141516def test(): old = [1, [1, 2, 3], 3] new = old[:] print(id(old)) print(old) print(&quot;---------------------&quot;) print(id(new)) print(new) new[0] = 3 new[1][0] = 3 print(&quot;---------------------&quot;) print(old) print(new)if __name__ == &#x27;__main__&#x27;: test() 返回 等值传递 12345678910111213141516def test(): old = [1, [1, 2, 3], 3] new = [1, [1, 2, 3], 3] print(id(old)) print(old) print(&quot;---------------------&quot;) print(id(new)) print(new) new[0] = 3 new[1][0] = 3 print(&quot;---------------------&quot;) print(old) print(new) if __name__ == &#x27;__main__&#x27;: test() 返回 深拷贝即创建与原对象完全无关的对象。需导入 copy 模块 123456789101112131415161718import copy def test(): old = [1, [1, 2, 3], 3] new = copy.deepcopy(old) print(id(old)) print(old) print(&quot;---------------------&quot;) print(id(new)) print(new) new[0] = 3 new[1][0] = 3 print(&quot;---------------------&quot;) print(old) print(new) if __name__ == &#x27;__main__&#x27;: test() 返回 元组类型—&gt;不可变类型元组相当于不可变的列表(为 id 值 无法变，但是对于列表元组等，可以更改里面的值) 123456789101112131415def test(): test_tuple = (1, [1, 2]) print(test_tuple) try: test_tuple[0] = 2 except TypeError as t: print(t) try: test_tuple[1][1] = 10000 except TypeError as t: print(t) print(test_tuple)if __name__ == &#x27;__main__&#x27;: test() 返回 元组类型常用方法 tuple(obj) obj 只要为可迭代类型都能转换。对于 dict 类型转换只转换 key 值 12345678def test(): test1_tuple = tuple(&quot;junliangl&quot;) print(test1_tuple) test2_tuple = tuple(&#123;&quot;first&quot;: 1, &quot;second&quot;: 2&#125;) print(test2_tuple)if __name__ == &#x27;__main__&#x27;: test() 返回 tuple[a:b:c] 切片，索引。和 list 一致 pass len(tuple) 和 list 一致 pass index(obj, start, end) 和列表一致 pass count(obj, start, end)和列表一致 pass 字典类型—&gt;可变类型这代表着以下方法如若修改字典，字典的 id(dict)值不变，与 str 类型不同 参考链接 https://www.cnblogs.com/wakey/p/16246920.html https://blog.csdn.net/weixin_45228198/article/details/112771784 底层原理字典底层采用 hash表（散列表）的形式存储数据。内存形式如下 插入数据 d[“name”]&#x3D;”jack” 首先对键- -“name”计算哈希值，然后对当前C数组arr的长度求余 然后得到一个索引值，假如为5，则将当前的（哈希值，键，值）作为一个整体存入arr[5] 哈希碰撞 当插入的键，经过哈希计算，求余后若得到与之前一样的索引，比如5 因此索引处已经存有数据，无法再次存入，那么就将当前的索引+ 一个偏移量 重新计算索引位置，然后存入数据，这在python中为开放地址法 扩容（可变） 当存入的数据超过总长度的2&#x2F;3时，字典会成倍扩容，对旧数据根据新数组长度计算索引，重新存入 更新值 d[“name”]&#x3D;”tom” 首先计算键- “name”的哈希值，然后对当前数组总长度求余，得到索引，若索引对应位置的数据的键&#x3D;&#x3D;“name”，则更新它的值 删除 del d[“name”] 计算当前键- “name” 的哈希值，求余，找到索引，删除数据，仍保持探测链 标记此处有过数据 字典对比列表优缺点列表：遍历所有数据，一个一个的比较，数据量大时，时间复杂度高字典：对要查找的键，计算哈希值，求余运算得到索引，一步到位，查找效率高。内存消耗极大，属于空间换取时间 字典注意项遍历字典时添加新建可能导致字典底层数组扩容，导致散列链发生变化，因此一般不要对字典遍历的同时进行修改 具体过程如下： 键值的存储过程 首先要计算data[“name”]的散列值 得到hash值后，我们从hash值最右边3位数字作为偏离量，即0b1xxxx000111101 我们查看偏移量”101” 对应的bucket是否为空，如果为空，则将键值对放进去 如果不为空，则依次去右边3位作为偏离量，即0b1xxxx000111101 再看偏离量”111” 对应的bucket是否为空，直到找到为空的bucket将键值对放进去 字典查找值的过程 我们要计算data[“name”] 里面的”name”对象 确定偏离量，散列值的最右边3位数字作为偏离量 0b1xxxx000111101 查看偏离量”101”对应的bucket是否为空，如果为空，则返回None 如果不为空，则将这个bucket的键对象计算出对应的散列值和data[“name”]的”name”散列值进行比较，如果两个散列值相等，则将对应数组里的值对象返回，如果不相等，则再依次向前取3个【偏移量，如0b1xxxx000111101。依次取完，仍然没有找到，则返回None 字典的 key 必须是可散列的 数字类型，字符串类型，元组类型。如若是其他类型，则会报错 1234567891011def test_dict(): a = &#123;(1, 2): 1&#125; print(a) try: b = &#123;[1, 2]: 1&#125; print(b) except TypeError as t: print(t)if __name__ == &#x27;__main__&#x27;: test_dict() 返回 字典赋值dict[key] = value 123456789def test_dict(): dict_test = &#123;&#125; list_test = [[&quot;first&quot;, &quot;value1&quot;], [&quot;second&quot;, &quot;value2&quot;], [&quot;third&quot;, &quot;value3&quot;]] for i in list_test: dict_test[i[0]] = i[1] print(dict_test)if __name__ == &#x27;__main__&#x27;: test_dict() 返回 针对赋值操作，key 存在则修改，key 不存在则新增。所以字典里的 key 必须唯一 字典的常用方法 fromkeys(obj，value) 表示遍历序列 obj 作为新 dict 的 key，value 整体作为 value 12345678910def test_dict(): dict_test1 = &#123;&#125; dict_test2 = dict_test1.fromkeys((1, 2), 3) print(dict_test1) print(dict_test2) dict_test3 = dict_test1.fromkeys([&quot;first&quot;, &quot;second&quot;], [&quot;value1&quot;, &quot;value2&quot;]) print(dict_test3)if __name__ == &#x27;__main__&#x27;: test_dict() 返回 pop(key) 方法代表删除，返回被删除的 value 12345678def test_dict(): dict_test = &#123;&quot;key&quot;: &quot;value&quot;, 5: 3&#125; value = dict_test.pop(&quot;key&quot;) print(value) print(dict_test)if __name__ == &#x27;__main__&#x27;: test_dict() 返回 popitem() 后进先出原则删除字典最后添加的 key-value 对 1234567891011def test_dict(): dict_test1 = &#123;&quot;key&quot;: &quot;value&quot;, 5: 3&#125; print(dict_test1.popitem()) print(dict_test1) print(&quot;------------------&quot;) dict_test2 = &#123;5: 3, 6: 3, 2: 9&#125; print(dict_test2.popitem()) print(dict_test2)if __name__ == &#x27;__main__&#x27;: test_dict() 返回 clear() 清空字典 1234567def test_dict(): dict_test = &#123;&quot;key&quot;: &quot;value&quot;, 5: 3&#125; dict_test.clear() print(dict_test)if __name__ == &#x27;__main__&#x27;: test_dict() 返回 update(dict) 更新字典。key 重复则更新 value，没有则新增 12345678def test_dict(): dict_test = &#123;&quot;first&quot;: &quot;value1&quot;, &quot;second&quot;: &quot;value2&quot;&#125; print(dict_test) dict_test.update(&#123;&quot;first&quot;: &quot;update&quot;, &quot;third&quot;: &quot;value3&quot;&#125;) print(dict_test)if __name__ == &#x27;__main__&#x27;: test_dict() 返回 get(key，obj) 判断字典的 key 是否存在，若存在返回对应的 value，不存在则返回 obj 1234567def test_dict(): dict_test1 = &#123;&quot;first&quot;: &quot;value1&quot;, &quot;second&quot;: &quot;value2&quot;&#125; print(dict_test1.get(&quot;first&quot;, &quot;first 不存在&quot;)) print(dict_test1.get(&quot;third&quot;, &quot;third 不存在&quot;))if __name__ == &#x27;__main__&#x27;: test_dict() 返回 setdefault(key，value) 如果当前 dict 存在 key，那么返回它的 value；否则把 key-value 键值对添加进字典并返回 vaule 12345678def test_dict(): dict_test = &#123;&quot;first&quot;: &quot;value1&quot;, &quot;second&quot;: &quot;value2&quot;&#125; dict_test.setdefault(&quot;third&quot;, &quot;value3&quot;) print(dict_test.setdefault(&quot;third&quot;, &quot;setdefault&quot;)) print(dict_test)if __name__ == &#x27;__main__&#x27;: test_dict() 返回 keys() 获取 dict 的 keys。并返回该对象的生成器。这样节省了空间。如果要取值则可以自行强行转化成 list 123456789def test_dict(): dict_test1 = &#123;&quot;first&quot;: 1, &quot;second&quot;: 2&#125; keys = dict_test1.keys() print(keys) print(type(keys)) print(list(keys))if __name__ == &#x27;__main__&#x27;: test_dict() 返回 values() 获取 dict 的 values，其他同上 123456789def test_dict(): dict_test1 = &#123;&quot;first&quot;: 1, &quot;second&quot;: 2&#125; values = dict_test1.values() print(values) print(type(values)) print(list(values))if __name__ == &#x27;__main__&#x27;: test_dict() 返回 items()获取了dict 的 keys 和values 元组对，其他同上 123456789def test_dict(): dict_test = &#123;&quot;first&quot;: 1, &quot;second&quot;: 2&#125; items = dict_test.items() print(items) print(type(items)) print(list(items))if __name__ == &#x27;__main__&#x27;: test_dict() 返回 集合类型—&gt;可变类型这代表着以下方法如若修改字典，字典的 id(dict)值不变，与 str 类型不同 条件集合元素满足 必须是可散列的 数字，字符串，元组 底层原理依旧采用 hash 表进行存储 创建空集合 set() 不能采用 &#123;&#125;，系统默认为 dict 类型 1234567891011def test_set(): set_test = set() dict_test = &#123;&#125; print(set_test) print(type(set_test)) print(&quot;-----------------&quot;) print(dict_test) print(type(dict_test))if __name__ == &#x27;__main__&#x27;: test_set() 返回 如若不是空集合，则可以采用 &#123;values&#125; 方式创建 1234567def test_set(): set_test = &#123;1, 2&#125; print(set_test) print(type(set_test))if __name__ == &#x27;__main__&#x27;: test_set() 返回 由于集合内元素要参与 hash(values) 运算，所以得是不可变类型 123456789def test_set(): try: set_test = &#123;1, [1, 2]&#125; print(set_test) except TypeError as t: print(t)if __name__ == &#x27;__main__&#x27;: test_set() 返回 集合常用方法 交集 set1 &amp; set2 123456789def test_set(): set1 = &#123;1, 2, 3&#125; set2 = &#123;2, 3, 4&#125; set3 = &#123;6, 7, 8&#125; print(set1 &amp; set2) print(set2 &amp; set3)if __name__ == &#x27;__main__&#x27;: test_set() 返回 并集 set1 | set2 12345678def test_set(): set1 = &#123;1, 2, 3&#125; set2 = &#123;2, 3, 4&#125; print(set1 | set2)if __name__ == &#x27;__main__&#x27;: test_set() 返回 差集 set1 - set2 1234567def test_set(): set1 = &#123;1, 2, 3&#125; set2 = &#123;2, 3, 4&#125; print(set1 - set2)if __name__ == &#x27;__main__&#x27;: test_set() 返回 discard(value) 删除集合中 value 元素，找不到不会抛出异常 12345678def test_set(): set_test = &#123;1, 2, 3&#125; set_test.discard(1) print(set_test) set_test.discard(1)if __name__ == &#x27;__main__&#x27;: test_set() 返回 remove(values) 删除 value 。找不到则报错 123456789101112def test_set(): set_test = &#123;1, 2, 3&#125; set_test.remove(2) print(set_test) try: set_test.remove(2) except KeyError as k: print(k)if __name__ == &#x27;__main__&#x27;: test_set() 返回 update(obj) 遍历序列 obj 更新集合 。序列一定是可哈希的，否则报错。 123456789101112def test_set(): set_test = &#123;1, 2, 3&#125; set_test.update([1, 2, 4]) print(set_test) try: set_test.update([2, 3, [1, 2]]) except TypeError as t: print(t)if __name__ == &#x27;__main__&#x27;: test_set() 返回 pop() 随机删除一个元素。通常是展现出的删除第一个元素 12345678def test_set(): set_test1 = &#123;1, 2, 3&#125; set_test1.pop() print(set_test1)if __name__ == &#x27;__main__&#x27;: test_set() 返回 add(value) 往集合中增加一个元素 123456789101112def test_set(): set_test1 = &#123;1, 2, 3&#125; set_test1.add(4) print(set_test1) try: set_test1.add([]) except TypeError as t: print(t)if __name__ == &#x27;__main__&#x27;: test_set() 返回 clear() 清空集合 12345678def test_set(): set_test = &#123;&quot;&quot;, 1, ()&#125; set_test.clear() print(set_test)if __name__ == &#x27;__main__&#x27;: test_set() 返回","tags":"python 基本数据类型 常用方法"},{"title":"python 运算符","url":"/2022/12/05/python/python 运算符/","text":"运算符的分类python 运算符分为 算术运算符、赋值运算符、比较运算符、布尔运算符、位运算符 算术运算符算术运算符分为 标准运算符、取余运算符、幂运算符 算术运算符满足以下规则 标准运算符 + - * / // 整除运算符其中/为整除运算符，若两者异号，则向下取整 12345678def test(): value1 = 20/-3 value2 = 20//-3 print(value1) print(value2)if __name__ == &#x27;__main__&#x27;: test() 返回 取余运算符% 为取余运算符。规则是同号则直接取余数。异号余数 &#x3D; 被除数 - 除数*商 其中以上的 商 为两者整除而来 如 -20%3的商为 -20&#x2F;&#x2F;3 12345678910def test(): value1 = -20%-3 value2 = -20%3 value3 = 20%-3 print(value1) print(value2) print(value3)if __name__ == &#x27;__main__&#x27;: test() 返回 幂运算符**为幂运算符，a**b 表示 a 的 b 次 幂 12345678def test(): value1 = -2**3 value2 = -2**-2 print(value1) print(value2)if __name__ == &#x27;__main__&#x27;: test() 返回 赋值运算符&#x3D; 即为赋值运算符。 执行顺序为 从右往左 a&#x3D;b&#x3D;c&#x3D;1 支持参数赋值 a +&#x3D; b，a &#x2F;&#x2F;&#x3D; b ….. 支持系列解包赋值 a，b &#x3D; b， a，常用于交换两者的值 12345678910def test(): value1 = 1 value2 = 2 value1, value2 = value2, value1 print(value1) print(value2) if __name__ == &#x27;__main__&#x27;: test() 返回 比较运算符 &gt;，&lt;， &gt;&#x3D;，&lt;&#x3D;，!&#x3D;，&#x3D;&#x3D; 返回值为 bool 类型，比较的是两者的 _value 值 is ，is not。is 代表 是 id 相等，is not 代表 id 不相等 返回值为 bool 类型，比较的是两者的 id 值 12345678910111213141516def test(): value1 = 1 value2 = 2 print(value1 == value2) print(&quot;-----------------------&quot;) value3 = [1, [1, 2]] value4 = [1, [1, 2]] value5 = value3 print(id(value3), id(value4), id(value5)) print(&quot;-----------------------&quot;) print(value3 is value4) print(value3 is not value5) print(value4 is not value5)if __name__ == &#x27;__main__&#x27;: test() 返回 bool 运算符python 一切对象都有对应的 bool 值 and ，or，not，in，not in （其中 in， not in 表示是否在序列中） 其中 and 和 or 拥有短路性。即 a and b a为false，b不再进行。同理 a or b，a为真 b不再进行 123456789101112131415161718192021m = [1, 2, 3]def test1(): m.clear() print(m) return Truedef test2(): m.append(1) print(m) return Falsedef test_bool(): a = True b = False print(b and test1()) print(a or test2())if __name__ == &#x27;__main__&#x27;: test_bool() 返回 注意 a and b 其中 a，b不一定是bool 类型。a and b 返回值也不一定是 bool 类型 123456789def test(): print(None and 5) print(1 and &#x27;hello&#x27;) print(None or None) print(&quot;hello&quot; or None)if __name__ == &#x27;__main__&#x27;: test() 返回 实际中不确定 a，b 类型情况下想返回 bool 类型建议 bool(a) and bool(b) 这样能确定100%返回 bool 类型 位运算符&amp; 按位与。| 按位或。&gt;&gt; 按位右移。&lt;&lt;按位左移。^为异或。~为按位取反 以下为运算规则 123456789def test(): print(3 &amp; 6) print(3 | 6) print(3 &gt;&gt; 2) print(3 &lt;&lt; 1)if __name__ == &#x27;__main__&#x27;: test() 返回 注意，参与运算要按照补码进行计算 原码，反码，补码规则如下 正数 原码，反码，补码相同。符号位都为0 负数 原码符号位为1.反码是符号位不变，其余按位取反。补码是反码 + 1 根据以上规则我们可以计算出负数的 按位与 和 按位或 123456789def test(): print(-3 &amp; -6) print(-3 | -6) print(-3 &gt;&gt; 1) print(-3 &lt;&lt; 1)if __name__ == &#x27;__main__&#x27;: test() 返回 验算 同理可以算出其他值。 注意移位运算符符号位补位为当前符号。即符号位永远保持同号 ~ 按位取反值得注意的是按位取反符号位要参与 1234567def test(): print(~-3) print(~5)if __name__ == &#x27;__main__&#x27;: test() 返回 ^异或即A^B &#x3D; （A and !B）or (!A and B) 123456def test(): print(5 ^ -2)if __name__ == &#x27;__main__&#x27;: test() 返回 异或可以不借助第三方参数进行交换值 1234567891011def exchange(a, b): print(a, b) print(&quot;-----------------&quot;) a = a ^ b b = a ^ b a = a ^ b print(a, b)if __name__ == &#x27;__main__&#x27;: exchange(6, 5) 返回 证明 运算符优先级运算符优先级参考如下： python3 官方参考","tags":"python 运算符"},{"title":"Python pytest 模块单元测试","url":"/2022/12/05/python/pytest/","text":"pytest 准备工作准备 requirements.txt 写入以下插件和包， 123456`pytest``pytest-html``pytest-xdist``pytest-ordering``pytest-rerunfailures``allure-pytest` 安装插件 pip install -r requirements.txt 编写一个简单的测试脚本 test.py 1234567import pytestclass TestCase: def test_number(self): assert True is False 运行 pytest pytest -vs test.py 运行结果如下 pytest 使用方法运行python test.py 脚本下 写入 main 方法调用 pytest.main() 去执行 12if __name__ == &#x27;__main__&#x27;: pytest.main([&#x27;-s&#x27;, &#x27;./test_number.py&#x27;]) 终端模式下也可以通过 pytest 命令执行 pytest -vs test.py 参数默认不加参数即运行 12if __name__ == &#x27;__main__&#x27;: pytest.main() pytest test.py 以上默认运行以下测试用例 名字带有 test 开头或 test 结尾的 python 模块 名字以 Test 开头且不能含有 init 方法的类 名字以 test 开头的方法 常用的参数解释-s 打印输出调试信息 -v 输出更详细的信息 -n number (输入几个线程) 多线程或分布式运行 --reruns number (输入重跑次数) 运行用例失败重跑 -x 只要一个用例失败那么停止测试 --maxfail=number 出现 number 次用例失败就停止测试 -k string 根据测试用例的部分字符串(string)指定 -rA 测试结果的简单统计 -m 指定被 pytest.mark 标记过的方法 编辑配置文件编辑 pytest.ini 配置文件达到命令行运行的效果。配置好后 只需要 pytest 即可一键运行 系统根目录下创建 pytest.ini 配置文件 touch pytest.ini 修改该文件编码格式为 ANSI 格式，创建好需要更改编码格式 作用 改变 pytest 的默认行为，无需命令行输出冗余命令 运行规则 pytest 自动读取 pytest.ini 配置文件并按照配置文件规则执行 一些具体参数如下 pytest.ini 12345678910111213`[pytest]``#encoding = ANSI``#命令行参数，用空格分隔``addopts = -vs` `#测试用例的文件路径``testpaths = .``#配置测试搜素的 python 文件名称``python_files = test*.py#配置测试搜索的测试类名python_classes = Test*``#配置测试搜索的测试函数名``python_functions = test*` 常用的装饰器有时候我们希望某个方法有专门的作用和不同的作用那么就可以采用 pytest装饰器修饰 @pytest.mark.yourname 用该装饰器装饰的方法可以用 pytest -m &quot;yourname&quot;进行操作 多个被 mark 过的方法 可以使用逻辑运算符and or not进行连接 如 pytest -m &quot;first or second&quot; 表示 first 方法 和 second 方法都被执行 @pytest.mark.skip(reason=yourreasons) 用该装饰器装饰的方法会被 pytest 无条件跳过 @pytest.mark.skipif(condition=yourcondition, reason=yourreasons) 用该装饰器装饰的方法会被 pytest 判定:如果 condition 表达式为 True，则跳过该测试，反之则不跳过 @pytest.mark.run(order=number) 用该装饰器装饰的方法会被 pytest 识别并依照 number 的值的顺序跑测试用例 @pytest.fixture(scope=scope, params=params, autouse=bool, ids=ids, name=name) 用fixtrue标记的方法一般用于前置和后置处理，类似 setup &amp; teardown 的功能 其中 scope 参数有以下四个值: “function” 代表着作用于 方法 “class” 代表着作用于 类 “modules” 代表着作用于一个 python 文件 “sessions” 代表着作用于整个 pytest 测试流程 其中 autouse 参数有 True 和 False 两个 bool 值 如果 autouse&#x3D;True，那么默认测试用例方法都会执行fixture，前提是在自己的scope里 1234567891011121314@pytest.fixture(scope=&quot;function&quot;, autouse=True, params=[(&quot;这是&quot;, &quot;first&quot;), (&quot;这是&quot;, &quot;second&quot;)])def sayhello(request): print(&quot;测试开始&quot;) yield request.param print(&quot;测试结束&quot;)class TestCase: @pytest.mark.run(order=3) # @pytest.mark.first def test_number(self): pass 如果 autouse&#x3D;Flase，那么测试用例方法参数需要添加 fixture 修饰的方法名字 123456789101112131415@pytest.fixture(scope=&quot;function&quot;, autouse=False, params=[(&quot;这是&quot;, &quot;first&quot;), (&quot;这是&quot;, &quot;second&quot;)])def sayhello(request): print(&quot;测试开始&quot;) yield request.param print(&quot;测试结束&quot;)class TestCase: @pytest.mark.run(order=3) # @pytest.mark.first def test_number(self, sayhello): pass params 参数控制着传参 params=[(&quot;这是&quot;, &quot;first&quot;), (&quot;这是&quot;, &quot;second&quot;)] 其中 params 可以等于一个 列表或字典，或者 字典列表与元祖列表 如果要获得 params 的参数，则fxiture修饰的方法需要添加固定的 request 参数，且返回request.param 用于测试方法接受 如果测试方法要接收 params 参数，即时autouse&#x3D;True，也要在测试方法参数上添加需要的fixture方法名 未加方法名结果 添加方法名结果 借助python yeild 生成器控制前置和后置输出 123456@pytest.fixture(scope=&quot;function&quot;, autouse=True, params=[(&quot;这是&quot;, &quot;first&quot;), (&quot;这是&quot;, &quot;second&quot;)])def sayhello(request): print(&quot;测试开始&quot;) yield request.param print(&quot;测试结束&quot;) 实际使用情况 一般情况下 pytest 有一个机制:即把 fixture 集中放入一个名叫 conftest.py 的文件下，pytest会自动识别该文件并作出相应的响应作用域 该文件可以存放在任何目录下且只对当前目录及当前路径以下的目录下起作用 @pytest.mark.parametrize(argsname，argsvalues) 用该装饰器修饰的方法可以进行参数化 argsname 代表着参数名，argsvalues代表参数值 12345678import pytestclass TestCase2:​ @pytest.mark.parametrize(argnames=&quot;a&quot;, argvalues=[&quot;FIRST&quot;, &quot;SECOND&quot;])​ def test_number(self, a: list):​ print(a) 结果","tags":"python pytest 测试框架"},{"title":"docker","url":"/2022/12/05/linux/docker/","text":"docker详解","tags":"continer"},{"title":"测试用例设计方法","url":"/2022/12/05/测试/测试用例设计方法/","text":"测试用例的分类分为黑盒测试和白盒测试两种 黑盒测试 白盒测试 设计测试用例的方法等价类划分法（简称等价类）等价类划分法的定义将输入（输出）域划分成若干个子集合中，从划分的子集合中选取代表数据进行测试，如果选取的数据测试没有问题，就认为其他数据测试的效果是等价的 等价类划分法的分类有效等价类 无效等价类 等价类划分原则 如果输入（输出）是一个取值范围或者某个值的个数时，则划分成一个有效等价类和两个无效等价类 举例 某个大厦招聘保安，年龄要求18~60周岁（包括18和60） 一个有效等价类：18~60 两个无效等价类：&lt;18；&gt;60 并且从以上区间选取带有标志性的数据测试 如有效等价类区间里选取 18 60 50…..，无效等价类里选取 10 70 80 ….. 如果输入（输出）是一个有限集合或者必须如何的条件，则划分成一个有效等价类和一个无效等价类 举例 一个集合：以下城市进入上海需要提供核酸检测报告（沈阳；大连；深圳；广州；合肥；六安；营口；瑞丽） 一个有效等价类：集合内； 一个无效等价类：集合外（菏泽） 并且从以上区间选取带有标志性的数据测试 如有效等价类选取大连……，无效等价类选取 菏泽…… 如果输入（输出）是一个布尔量，则划分成一个有效等价类和一个无效等价类 举例 某个问卷调查 App 如果性别选项选择男请转到第五题： 一个有效：男 一个无效：女 如果性别选项选择女请转到第二题： 一个有效：女 一个无效：男 很明显布尔类型是第二种等价类的特殊情况 如果输入（输出）已经划分出有效和无效等价类，针对有效等价类部分不同的取值处理方式不一样，细分成多个有效等价类和一个无效等价类 举例 某个认证考试百分制；60分及格可以获得认证证书 一个有效等价类：&gt;&#x3D;60分 细化等价类： 6069分—合格；7079分—中等；8089分—良好；9099分—优秀；100分—完美 一个无效等价类：&lt;60分 如果输入（输出）要同时满足多个条件，则划分成一个有效等价类和多个无效等价类 举例 学习系统登录密码修改：6~12位； 一个有效等价类：大小写字母与数字的组合满足所有要求 多个无效等价类：少于6位；大于12位；缺少数字；缺少小写字母；缺少大写字母；含有其他字母 很明显从以上看出当有限集合数量过于庞大时，我们不采用第二种等价类划分法，采用当前的划分方法 等价类划分法使用步骤 分析需求 将软件需求规格说明书划分成需求子片段 分析需求子片段，找出输入条件 分析输入条件，判定是否需要结合等价类划分原则划分等价，需要则继续 为了防止测试遗漏，为划分的等价类进行编号 从划分的等价类中选取代表数据进行测试，直到所有的等价类全部被覆盖 将选取的数据结合测试用例写作格式完成最终测试用例的编写 等价类的注意事项 一条测试用例尽量覆盖多个有效等价类； 一条测试用例只覆盖一个无效等价类； 这符合之前等价类设计方法的最后一条，因为实际输入要么是庞大的集合，要么是无穷的区间。总之应该以有效等价类覆盖越多越好 边界值对于等价类划分法的问题是等价类划分法追求有效等价类覆盖率和数量，然而拥有无穷数的区间却使用一个等价类设计思路，这显然和宗旨相悖。基于以上问题，那么边界值设计方法可以对以上问题进行补充 边界值的三个重要的参数 上点：区间边界的点 离点：离区间边界点最近的点 如果是开区间离点落在区间内，如果是闭区间离点落在区间外 即离点不能落在区间里 内点：落在区间内任意的点 举例 某个大厦招聘保安，年龄要求[18，60]周岁 上点：18；60 离点：17；61 内点：30 边界值的选取原则 如果输入（输出）是一个取值范围时，则以边界和边界附近的值作为测试用例数据优先选取 这就是对等价类不足的设计手段，因为等价类不能精确地锁定哪些数据需要拿来测试。 如果输入（输出）是一个有序的集合，则以第一个元素和最后一个元素作为测试用例 这个是基于对第二种等价类划分原则进行补充。 如果输入（输出）的值的个数是个取值范围，则以最大个数、最大个数+1、最小个数、最小个数-1作为测试用例数据优先选取； 这个是对以上两条内容的补充 边界值的使用步骤 分析需求 将软件需求规格说明书划分成需求子片段 分析需求子片段，找出输入条件 分析输入条件，判定是否需要边界值法，如果需要结合等价类划分原则划分等价类 很明显，边界值划分法是基于等价类划分法的补充，一定要优先择取等价类划分，根据划分情况选择合适的数据 判断是否需要边界值和需要哪种边界值方法 分析等价类，是否需要边界值补充 结合边界值数据选取原则确定边界值的选取 将选取的数据结合测试用例写作格式完成最终测试用例的编写 等价类和边界值适用范围 特点：不测试各种组合。测试效率比较高，效果一般。比较容易理解和易于使用的一种方法 适用范围：功能测试；性能测试；界面测试（GUI测试）；兼容测试 注意接口测试一般不选取等价类划分法去测试，一般功能测试可以使用等价类划分法 判定表分析和表达多种输入条件下完成不同动作的一种工具，这种方法能够将具有复杂逻辑关系和多种条件组合的情况表达清晰。 很显然，判定表是针对有限布尔集合或者输入是处于多个有限集合而言的。而一般功能的输出的集合一般只有一两个元素，然后由于有 switch-case 这种情况的出现，我们就可以考虑由判定表方法完成 判定表的四个重要参数 条件桩：输入条件 表示输入取值的集合 条件项：输入条件的取值 表示具体输入的集合元素 动作桩：输出结果 表示输出的取值集合 动作项：输出结果的取值 表示具体输出的集合元素 判定表的使用步骤 分析需求 将软件需求规格说明书划分成需求子片段； 分析输入条件，判定是否需要判定表设计方法，如果需要则继续 找出条件桩、条件项、动作桩、动作项； 将条件项进行组合，确定测试组合数量（条件项的个数相乘），得出测试规则； 分析生成的规则，对相似规则进行合并化简（合并有风险，化简需谨慎—对软件系统内部的逻辑结构非常了解；资源有限）； 分析每条生成的规则，必要时结合等价类边界值生成最终的测试用例。 判定表的适用范围从以上分析我们不难发现，判定表只使用输入输出为一个少元素或者布尔值的集合，因为如果输入输出量太大，那么根据组合数原理，测试用例量将会特别多影响测试效率。 所以适合功能测试，如修改密码成功与否，登录成功与否，下单成功与否。 判定表的特点 条件桩的顺序对生成规则没有影响 动作桩的顺序对生成的规则没有影响 每条规则都是独立的相互之间没有影响 判定表的写法 以上不难分析出理论上有 2**条件项的测试用例产生。 因果图因果图属于对判定表的一种补充。如果边界值法是对等价类划分法无穷转化为有穷的补充，那么因果图就是对判定表复杂的逻辑输入输出到简化的逻辑输入输出的补充 因果图的三个重要参数因果图顾名思义为 因—果 键值对，那么它有三个重要参数 原因 : C（course） 结果: R（result） 中间项：当多个原因之间不是单纯的与和或的关系，可以利用中间节点存取中间结果，使得因果图更加清晰 因果图的因果关系 逻辑关系 恒等 与 或 非 制约关系 互斥 Exclusive 有多个输入(原因)，至多只能有一个为真，不可以同时都为真，可以同时都为假 包容 Inclusive 有多个输入(原因)，至少有一个为真，可以同时都为真，不可以同时都为假 唯一 Only 有多个输入(原因)，有且只能有一个为真，不可以同时都为真，不可以同时都为假 要求 Require 有两个输入(原因)，A为真，B为真；A为假，B不做要求 强制 Mandatory 有两个输入(原因)，A为真，B为假；A为假，B不做要求 因果图的使用步骤 分析需求 将软件需求规格说明书划分成需求子片段； 分析输入输出，判定是否需要判定表设计方法，如果需要则是否需要借助因果图，如果需要则继续 分析原因和结果之间的关系，画出因果图 分析原因之间是否存在制约关系，做出标识 根据有因果图生成判定表 分析判定表，进行合并和化简 必要时结合等价类、边界值生成最终的测试用例 因果图画法 正交表正交表起源于伽罗瓦的数学理论。因为输入的是一组有限集合，那么多组输入可以简化。所以正交表是对判定表和因果测试用例数的简化 正交表的使用步骤 需求分析 将软件需求规格说明书划分成需求子片段 分析输入输出，看是否需要用到判定表和因果图，如果需要：找出因子和状态，构造一张因子状态表 使用正交表工具 allpairs 进行输出测试用例 正交表工具使用方法参考 正交表工具使用方法 必要时可以结合等价类边界值生成最终的测试用例 正交表的特点和适用范围很明显正交表极大地简化了判定表的测试用例量，所以基本判定表都会使用正交表。特别适合做兼容性测试，表单，配置测试等 状态迁移图在给定的条件下状态能够正确的跳转以及是否有非法转移和未可达的状态 状态迁移图的关键词 有限状态机 拥有有限个数量的状态，每个状态可以迁移到零个或多个状态 状态 某一时刻的表现 跳转条件 输入（使得状态发生变化的操作） 迁移 状态变化的过程 状态迁移图的使用步骤 将软件需求规格说明书划分成需求子片段 分析需求子片段，找出状态和条状条件 假定一个初始状态，以圆圈（代表状态）为节点以箭线（输入）为跳转条件画出状态迁移图 根据状态迁移图得出状态事件转换表（第一列代表上一状态；第二列代表跳转条件；第三列代表下一状态；第四列代表输出结果） 通过状态转换事件表得出状态转换树（矩形框代表状态） 通过状态转换树找出测试路径 添加一些非法测试 必要时可以结合等价类和边界值进行测试 场景测试法 pass","tags":"测试用例 测试用例设计"},{"title":"正交表工具使用方法","url":"/2022/12/05/测试/正交表工具使用方法/","text":"参考链接 https://blog.csdn.net/qq_54444533/article/details/124828947 官方网站 https://www.satisfice.com/download/allpairs 使用步骤 下载后解压 将该目录添加至环境变量 PATH 输入 allpairs 命令显示以上则安装成功 使用方法 第一步 对需要正交表的条件项目依次填入 csv 中，格式如下 第二步 复制全部内容到 txt 文档 注意不要在意 txt 文档格式混乱，allpairs 会自动识别。并且最后一行不能有换行符。否则会报错 第三步 用如下命令 allpiars 测试数据.txt &gt; 你需要生成的testcase.xlsx 表格中 最后查看结果 注意点 表格下方是所有笛卡尔积结果。上方才是需要测试的数据 其中前缀为~的项表示无关数据，可以任意取值","tags":"测试工具"},{"title":"软件质量模型","url":"/2022/12/05/测试/软件质量模型/","text":"参考链接 https://cloud.tencent.com/developer/article/1457805 官方软件质量模型是现 ISO/IEC25015 或 ISO/IEC9126 发布的软件质量保证的模型 它可以用官方的解释来判断一个软件质量的好坏与否 质量模型质量模型涉及6大特性和27个子特性 功能性定义 软件产品提供明确、隐含要求的能力 2.适合性 软件产品为指定的任务和用户提供一组合适的功能的能力（投入运行后，功能是否合适、正确、完整等） 3.准确性 软件产品提供具有所需精度的正确或相符的结果或效果的能力（实际与预期的差别） 4.互操作性 软件产品与一个或更多的规定系统进行交互的能力（如果与其它软件有定义接口，数据传输的正确程度） 安全保密性 软件产品保护信息和数据的能力，使未授权的人不能阅读或修改这些信息和数据，而不拒绝授权人员阅读或修改这些信息和数据(访问的可审核性（正常、病毒）、可控制性） 6.功能性的依从性 软件产品遵循与功能性相关的标准、约定或法规及类似规定的能力（非法） 可靠性 在指定条件下使用时，软件产品维持规定的性能级别的能力 成熟性 软件产品为避免由软件内部的故障而导致失效的能力（潜在的故障密度、失效的测试用例数量、故障排除） 容错性 在软件出现故障或者违反其指定接口的情况下，软件产品维持规定的性能级别的能力 易恢复性 在失效发生的情况下，软件产品重建规定的性能级别并恢复受直接影响的数据的能力（重启能力、重启时间） 可靠性的依从性 软件产品遵循与可靠性相关的标准、约定或法规的能力（非法） 易用性 在指定条件下使用时，软件产品被理解、学习、使用和在指定条件下使用时，软件产品被理解、学习、使用和吸引用户的能力 易理解性 软件产品使用户能理解软件是否合适以及如何能将软件用于特定的任务和使用条件的能力（文档、功能的初始印象） 易学性 软件产品使用户能学会其应用的能力（使用者学习满足需求的能力） 易操作性 软件产品使用户能操作和控制它的能力 吸引性 软件产品吸引用户的能力 易用性的依从性 软件产品遵循与易用性相关的标准、约定、风格指南或法规的能力（非法） 效率 在规定条件下，相对于所用资源的数量，软件产品可提在规定条件下，相对于所用资源的数量，软件产品可提供适当性能的能力 时间特性 在规定条件下，软件产品执行其功能时，提供适当的响应和处理时间以及吞吐率的能力（如响应时间） 资源利用性 在规定条件下，软件产品执行其功能时，使用合适数量和类别的资源的能力（如内存占用） 效率依从性 软件产品遵循与效率相关的标准或约定的能力（非法） 可维护性 软件产品可被修改的能力。修改可能包括修正、改进或软件对环境、需求和功能规格说明变化的适应 易分析性 软件产品诊断软件中的缺陷或失效原因或识别待修改部分的能力。 易改变性 软件产品使指定的修改可以被实现的能力（变更难易的程度） 稳定性 软件产品避免由于软件修改而造成意外结果的能力（由于软件修改而造成的意外） 易测试性 软件产品修改能被确认的能力 维护性的依从性 软件产品遵循与维护性相关的标准或约定的能力（非法） 可移植性 软件产品从一种环境迁移到另一种环境的能力 适应性 软件产品毋需采用额外的活动或手段就可适应不同指定环境的能力（屏幕大小） 易安装性 软件产品在指定环境中被安装的能力（用户在指定环境中被安装的能力，与易操作性互相影响） 共存性 软件产品在公共环境中同与其分享公共资源的其他独立软件共存的能力（共享资源的其它软件） 易替换性 软件产品在同样环境下，替代另一个相同用途的软件产品的能力（版本迭代、新旧兼容） 可移植性的依从性 软件产品遵循与可移植性相关的标准或约定的能力（非法） 软件的使用质量模型基于用户观点的软件产品用于指定的环境和使用周境时的质量。它测量用户在特定环境中能达到其目标的程度，而不是测量软件自身的属性。 基本的软件使用质量模型包括4大特性","tags":"质量模型"},{"title":"软件开发模型（SDLC)","url":"/2022/12/05/测试/软件开发模型（SDLC)/","text":"参考链接 https://cloud.tencent.com/developer/article/1724043 常用的开发模型 瀑布模型 V型 迭代和增量模型 螺旋模型 大爆炸模型 敏捷模型 原型模型 DevOps 瀑布模型 瀑布模型的特点瀑布模型（Waterfall） 是最简单的软件开发历史上第一个 SDLC 模型。在瀑布模型中，开发过程是线性的。任务和阶段按严格顺序一个接一个地完成。进度平稳地向下流动，就像瀑布上的水一样。 瀑布模型的缺点瀑布模型的主要缺点是不灵活。瀑布易于理解且易于管理。但是过早的延迟会拖延整个项目的时间表。由于一旦完成阶段，几乎没有修改的余地，因此只有进入维护阶段才能解决问题。如果需要灵活性，或者项目是长期的且正在进行的，则此模型不能很好地工作 V 型 V 形模型也称为 V 模型或验证与验证模型，是瀑布方法的扩展。使用 V 模型时，进度并不会直线移动，而是在实施和开发后逐渐上升。 对于 V 型 SDLC 项目，早期测试介入是与 瀑布模型相比的主要区别。每个开发阶段都有一个并行测试阶段，这有助于在继续下一步之前验证和验证每个步骤。 迭代和增量模型 迭代和增量 SDLC 模型将迭代设计和工作流与增量构建模型结合在一起。在这种情况下，团队将按周期开发产品，并以渐进方式构建小零件。 开发过程从简单实施一组严格限制的小型产品需求开始。然后对该产品进行增强，并使其本身成为更完整的版本，直到完成并准备好进行部署为止。每次迭代都可能包含设计更新和新功能。 迭代和增量模型的一个有价值的特点是可以在不知道所有需求的情况下开始开发。该模型包含其他 SDLC 模型的步骤-需求收集，设计，实施和测试，但要经过多次构建。开发团队可以利用先前构建中取得的成就来改善下一构建。 迭代和增量 SDLC 模型可能看起来像一组微型瀑布模型或微型 V 形模型。 螺旋模型 螺旋 SDLC 模型是原型方法和瀑布方法的结合。螺旋模型被认为是最灵活的 SDLC 方法之一。它从迭代模型及其重复中获得启发。该项目以“螺旋式”的方式反复经历四个阶段，直到完成为止，从而可以进行多轮改进。 规划 风险分析 工程 评价 螺旋模型主要用于大型项目，它允许构建高度定制的产品，并且用户反馈可以在项目的早期就被纳入。但可能有项目会形成永无止境的螺旋式发展的风险。 大爆炸模型 Big Bang 模型通常不遵循任何特定过程或说明。开发从当前可用的资源和工作开始，几乎没有计划或根本没有计划。结果，客户得到的产品甚至可能无法满足要求。功能是动态实现的。 Big Bang SDLC 模型的主要思想是将所有可用资源分配给产品本身的开发，主要是在编码方面，而不用担心满足计划。这是仅用于一两个软件工程师的小型项目的 SDLC 方法之一。 敏捷模型 敏捷（Agile） SDLC 模型是迭代和增量方法的组合，致力于通过早期交付工作软件来适应灵活的需求并满足用户和客户的需求。敏捷项目中的需求和解决方案可能会在开发过程中发展。 通过敏捷开发，该产品被分为小的增量构建，并以迭代方式交付。将所有任务划分为较小的时间范围，以便为每个版本准备工作功能。最终产品版本包含所有必需的功能。敏捷仍然是技术行业中使用最广泛的SDLC。 DevOps模型 DevOps是新手模型。DevOps来自两个趋势：敏捷方法和精益方法的应用。通常，DevOps 是通过自动化基础架构和工作流程并持续跟踪应用程序性能来执行的。DevOps方法使您可以增加部署频率，编写代码并缩短部署新代码所需的时间。 DevOps是工具，实践和方法的组合，鼓励开发人员，运维人员和 QA人员共同努力，以进行持续的开发，测试和部署活动，以加速创新并交付更高质量和更可靠的软件产品和功能。","tags":"开发模型"},{"title":"Python 虚拟环境 venv 的创建","url":"/2022/12/05/python/python venv 虚拟环境/","text":"引入原因python 项目为了类似 docker 一样隔离提供 venv 虚拟环境 使用方法python -m venv【params】venvpath 参数 一般情况python -m venv --upgrade-deps venvpath 除非需要之前的一些 site-package 否则不加 --system-site-package 建议建议加上 --upgrade-deps 这样无需手动更新 pip 造成无权限问题而导致原来的 pip 被删除 进入虚拟环境安装好以后可以打开 Scripts&#x2F; 目录下的 activate.bat 批处理文件进入虚拟环境 activate 其他方式进入虚拟环境也可以在 git-bash 里用 source 命令执行 查看是否进入虚拟环境可以用 pip list 查看包情况判断是否进入 python 虚拟环境 退出虚拟环境同样在虚环境里执行 deactivate.bat pycharm 中使用虚拟环境只需新建项目里配置虚拟环境解释器路径","tags":"python 虚拟环境"},{"title":"About me","url":"/about/index.html","text":"一个工作一年的测试工程师 %- theme.author_text %","tags":""}]}