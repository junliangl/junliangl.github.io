{"pages":[{"title":"python 表达式和生成式","url":"/2022/12/12/python/python 表达式和生成式/","text":"参考链接 https://www.bilibili.com/video/BV19g41197ro/?spm_id_from=333.999.0.0&amp;vd_source=f9937d98d0a8cc08ef5248c3c127d588 解包（解压赋值）python 赋值语句一般用 &#x3D; 进行。常用的特殊赋值语句一般有交换赋值 —&gt; a，b = b，a这样就能快速地进行变量的交换，特殊的是解压赋值是针对与等号右边是一个 iterable 对象的时候进行的，前提是这个 iterable 一定返回的是一个迭代器对象 具体什么是 iterable 请参考 python 迭代器和生成器 一般的使用方法变量1，变量2，……，变量n &#x3D; iterable 123456789def test_generative(): first, second, third = (1, 2, 3) print(first) print(second) print(third)if __name__ == &#x27;__main__&#x27;: test_generative() 返回 我们看出了元组 (1，2，3) 被解压到了 first，second，third之中 如果变量超过序列数，则会抛出 ValueError 异常 123456789def test_generative(): try: first, second, third, fourth = (1, 2, 3) except ValueError as v: print(v)if __name__ == &#x27;__main__&#x27;: test_generative() 返回 对自定义的迭代器解包12345678910111213141516171819202122232425class Iterator: def __init__(self): self.count = -1 def __iter__(self): return self def __next__(self): if self.count &gt; 0: raise StopIteration self.count += 1 return self.countdef test_generative(iterable): first, second = iterable print(first) print(second)if __name__ == &#x27;__main__&#x27;: iterator = Iterator() test_generative(iterator) 返回 以上看出我们可以通过自定义的迭代器对象进行解包 对函数参数进行解包 参考链接 https://blog.csdn.net/S_o_l_o_n/article/details/102823490 一般来说，函数参数基本是以元组形式传入的，那么我们可以利用这一点进行解包操作。需要借助 *号来标记（字典为 **） 参考 python 函数详解 关于函数可变参数传参的细节 函数解包的特殊情况特别地，我们如果要对一个可迭代对象参数的传入进行解包，一样也可以用到 *号 1234567891011def test_unpack(one, two, three): print(one, two, three)if __name__ == &#x27;__main__&#x27;: test_unpack(1, 2, 3) test_unpack(*[1, 2, 3]) test_unpack(*&quot;123&quot;) test_unpack(*(1, 2, 3)) test_unpack(*&#123;1, 2, 3&#125;) test_unpack(*&#123;&quot;first&quot;: 1, &quot;second&quot;: 2, &quot;third&quot;: 3&#125;) 返回 对自定义的迭代器对象解包 12345678910111213141516171819202122class Iterator: def __init__(self): self.count = 0 def __iter__(self): return self def __next__(self): if self.count &gt; 2: raise StopIteration self.count += 1 return self.countdef test_unpack(one, two, three): print(one, two, three)if __name__ == &#x27;__main__&#x27;: iterator = Iterator() test_unpack(*iterator) 返回 *号其他用法python 3.5 更新后可以使用 *号在可迭代对象序列内部进行解压。而且只能在内部，由于只能在内部，所以只支持 python 的一些基本数据类型如 元组，列表，字典，集合 12345678910111213def test_unpack(iterable): a = *iterable, # 等价于 (*tuple,) b = *iterable, &quot;hello&quot; # 等价于 (*iterable, 2) c = [*iterable] d = &#123;*iterable&#125; print(a) print(b) print(c) print(d)if __name__ == &#x27;__main__&#x27;: test_unpack((2, 2)) 返回 你会发现 a，b，c，d 变成了对应的序列。这就是下面所要讲解的压包 压包因为有解包，所以 python 同样提供压包方法。通常的压宝方式 123456789def test_pack(): a = 1, b = 1, 2 print(a) print(b)if __name__ == &#x27;__main__&#x27;: test_pack() 返回 上面的压包方法把传入的值作为元组类型压入变量中。 可迭代对象的压包传入的值如果是一个可迭代对象那么需要对齐先用 *号解包再压包。类似于解包最后一个例子。 1234567891011121314151617181920212223class Iterator: def __init__(self): self.count = 0 def __iter__(self): return self def __next__(self): if self.count &gt; 2: raise StopIteration self.count += 1 return self.countdef pack(_iterator): a = *_iterator, print(a)if __name__ == &#x27;__main__&#x27;: iterator = Iterator() pack(iterator) 返回 zip() 方法的压包python 提供内置方法 zip(*iterables) 方法进行压包，并返回一个可迭代对象 123456789101112def test_pack(): a = *([1, 2], (3, 4)), for i in a: print(i) print(&quot;*&quot;*20) b = zip([1, 2], (3, 4)) for j in b: print(j)if __name__ == &#x27;__main__&#x27;: test_pack() 返回 以上我们可以看出 zip()方法能够实现分别对序列元素的单独压缩成一个个元组，并且返回一个可迭代对象 压包与解包的本质通过上面分析出 python 赋值方式本质就是解包与压包共存的方式，有解包一定有压包。 最简单的赋值 a&#x3D;b，实则就是把 b 解包后传给 a 压包，这样实现了赋值。因此，交换赋值不再那么特殊，它本质就是解包和压包的一个过程。所以，python 赋值语句的一般用法就是 a，b，\\*args1，d = e，*args2, *args3 ......。如果等号左边变量少，则把多余的变量传给 args1；如果右边的变量少，则解开包让右边的变量多于左边的变量数。如果全部解开还是达不到要求，那么一定会抛出 ValueError 异常。这就是 python 解包和压包的本质 值得注意的是，等号左边永远最多只有一个 *号符，因为多了一定会有歧义 1234567891011def test_pack_and_unpack(): a, *args, b = *[1, 2, 3], 4, *(5, 6), 7 print(a, args, b) try: a, *args1, b, c, d, e, f, g, h = *[1, 2, 3], 4, *(5, 6), 7 except ValueError as v: print(v)if __name__ == &#x27;__main__&#x27;: test_pack_and_unpack() 返回 以上我们可以看出当左边变量已经多出到即使全解压完毕后都容纳不下变量数后，就会抛出 ValueError 异常 解包压包的总结 对于作为参数传入的函数的 *号，它在函数内部一定是 tuple 类型的，无论传入的参数是什么类型。 123456def test_method(a, b, *args): print(type(args))if __name__ == &#x27;__main__&#x27;: test_method(*[1, 2, 3], 4, (5, 6), 7) 返回 以上翻译解包压包语言的含义是：a，b，*args = *[1, 2, 3], 4, (5, 6), 7 再以 tuple(args) 传入函数中 对于赋值语句中的 *号，它一定是以 list 类型传入进变量值得，无论给它赋值的是什么类型 12345678def test_given(): a, b, *args = *[1, 2, 3], 4, (5, 6), 7 print(args) print(type(args))if __name__ == &#x27;__main__&#x27;: test_given() 返回 以上翻译解包压包语言的含义一样是: a，b，*args = *[1, 2, 3], 4, (5, 6), 7 再用 list(args) 给 args 变为 list 类型 对 for 循环重新认识通过以上解包压包的本质，for 循环我们知道 in 后面一定是 iterable 的对象，那 for 后面的变量数对后面 iterable 对象的限制是什么呢 for 循环除了 for i in iterable，还能通过 for k，v in iterable ……如果这个 iterable 的每个元素本身也是 iterable 的，那么同样也是压包。因此对于 for k，v in iterable 循环，python 要求 后面的 iterable 每一个元素都是一个 iterable 类型的，并且该子 iterable 的元素数量要大于等于 k，v 等变量的数量 12345678910111213141516def test_for(): for k, v in &#123;(1, 2), (&quot;first&quot;, &quot;second&quot;)&#125;: print(k, v) print(&quot;*&quot;*20) for k, v in &#123;&quot;first&quot;: 1&#125;.items(): print(k, v) print(&quot;*&quot; * 20) for k, v in [[1, 2], [&quot;first&quot;, &quot;second&quot;]]: print(k, v) print(&quot;*&quot; * 20) for a, *args, in ([1, 2, 3, 4], &#123;&quot;first&quot;: 1, &quot;second&quot;: 2&#125;): print(args)if __name__ == &#x27;__main__&#x27;: test_for() 返回 以上我们明显看出每一个子元素都要求是 iterable的，并且每一个子元素的元素数一定要大于 for 给出的变量数 表达式python 的一条算术语句皆视为表达式 运算符参考 python 运算符 三元表达式产生背景python 的一种语法糖。由于 python 并不支持三目运算符，所以 python 简化了 if else 判断语句形成三元表达式 语法结构表达式1 if 条件 else 表达式2 其中 条件如果为 True，返回表达式1 的值；如果条件如 False，返回表达式2 的值 1234567def three_meta_expression(max_, min_): result = max_ if max_ &gt; min_ else min_ print(result)if __name__ == &#x27;__main__&#x27;: three_meta_expression(100, 99) 返回 以上是一个返回最大值的函数，利用三元表达式快速获得最大值的结果 lambda 表达式 参考 python 函数详解 有关匿名函数 lambda 表达式的有关信息 生成式生成式是 python 提供的另外的一种语法糖，它能很好的解决 for 循环的返回变量的问题 列表生成式列表生成式顾名思义是对列表 for 循环的一种简写 语法 new_list &#x3D; [表达式1 for 变量1，变量2 …. in iterable if 条件] 12345678910111213def test_generative(): _list = [1, 2, 3] _items = ([10, 5], [20, 10]) new_list = [i for i in _list if i &gt; 1] print(new_list) new_items = [[i, j] for i, j in _items if i + j &gt; 20] print(new_items)if __name__ == &#x27;__main__&#x27;: test_generative() 返回 以上列表生成式语法糖极大简化了复杂的步骤有效地返回了想要的值 集合生成式同列表生成式一样的格式 注意由于集合的每一个元素都是要 hashable，那么表达式的值一定是不可变类型。 123456789101112131415161718def test_generative(): _list = [1, 2, 3] _items = ([10, 5], [20, 10]) new_list = &#123;i for i in _list if i &gt; 1&#125; print(new_list) new_items = &#123;(i, j) for i, j in _items if i + j &gt; 20&#125; print(new_items) try: new_items = &#123;[i] for i in _list if i &gt; 1&#125; except TypeError as t: print(t)if __name__ == &#x27;__main__&#x27;: test_generative() 返回 字典生成式同列表生成式一样，但是注意 key 也是一定要是 hashable 12345678910111213141516def test_generative(): _items = ([10, 5], [20, 10]) new_items = &#123;i: j for i, j in _items if i + j &gt; 20&#125; print(new_items) print(&#123;k: v for k, v in &#123;2: 3&#125;.items()&#125;) try: new_items = &#123;i: 5 for i in _items&#125; except TypeError as t: print(t)if __name__ == &#x27;__main__&#x27;: test_generative() 返回 生成器生成式因为元组是不可变类型，那么 python 把以上类比出的元组生成式转为了生成器生成式 123456789101112def test_generative(): _items = ([10, 5], [20, 10]) new_items = ([i, j] for i, j in _items if i + j &gt; 20) return new_itemsif __name__ == &#x27;__main__&#x27;: a = test_generative() print(type(a)) for item in a: print(item) 返回 表达式和生成式的组合表达式就是会返回一个值，如果这个值是 iterable，那么就可以叠加进生成式中 123456789101112def test_generative(): a = [1, 2, 3] b = [10, 11, 12, 13] for item in [name for name in (a if len(a) &lt; len(b) else b) if name &gt; 2]: print(i) print(&quot;*&quot; * 20) for item in (name for name in (a if len(a) &gt; len(b) else b) if name &gt; 2): print(i)if __name__ == &#x27;__main__&#x27;: test_generative() 返回 以上不难看出 item 遍历的是我们生成出来的各种生成式，生成式里面的我们遍历的是我们定义好的表达式。这样就完成了组合","tags":"python 表达式 生成式"},{"title":"python 类详解","url":"/2022/12/10/python/python 类详解/","text":"参考链接 python 内存详解 python 作为贯彻一切皆为对象的法则，那么类的组成就很重要了 类的定义python 用 class 定义类 12345class HelloWorld: passif __name__ == &#x27;__main__&#x27;: print(HelloWorld) 返回 #类的命名法则 python 类名的法则遵循驼峰法则，如 HelloWorld，GetRequest …… 这点和 python 的函数名和变量名不同 参考 python 函数详解 类对象的初始化python 初始化类使用类名() 的方式进行初始化 1234567class HelloWorld: passif __name__ == &#x27;__main__&#x27;: helloworld = HelloWorld() print(helloworld.__class__) 返回 类结构的组成python 为类提供 类变量 类方法 实例方法 实例变量 静态方法 其中前三项称为类属性，都能通过对象取调用它们，也可以通过类名直接访问 静态方法python 类中最简单的一种方法，直接在类中写入方法，但是要在方法前添加 @staticmethod 装饰器来修饰。静态方法与类对象无关。 123456789101112131415import randomclass TestStaticMethod: @staticmethod def random(): a = random.randrange(10) print(a)if __name__ == &#x27;__main__&#x27;: test = TestStaticMethod() test.random() TestStaticMethod.random() 返回 从以上我们可以看出，静态方法可以通过对象调用也可以通过类名调用 值得注意的是，静态方法由于参数没有 self 这个对象，那么无法调用 实例变量和实例方法 类变量直接在类体里定义的变量我们称为类变量。因为这个变量属于类本身，因为类本身也是一个对象，但是这个类变量不属于类的对象，却可以通过类的对象调用。可以参考 python 内存详解 12345678class TestClassVariable: a = 5if __name__ == &#x27;__main__&#x27;: test = TestClassVariable() print(test.a) print(TestClassVariable.a) 返回 可以看到对象和类名都能直接访问类变量 python 类特点和 java 不同，python 动态语言特点初始化多个类实例后，类对象会跟着变化 12345678910class TestClassVariable: a = &quot;old&quot;if __name__ == &#x27;__main__&#x27;: test1 = TestClassVariable() TestClassVariable.a = &quot;new&quot; test2 = TestClassVariable() print(test1.a) print(test2.a) 返回 动态赋值python 为动态编程语言，可以动态地给类变量赋值，但是前提是一定要用类名调用，否则系统会认为这是动态给实例变量赋值，参考下文有关实例变量的解释 1234567891011class TestClassVariable: a = 100if __name__ == &#x27;__main__&#x27;: test1 = TestClassVariable() TestClassVariable.b = &quot;新添加&quot; test2 = TestClassVariable() print(TestClassVariable.b) print(test1.b) print(test2.b) 返回 如果我们用对象赋值会发生什么呢 12345678910111213141516class TestClassVariable: a = 100if __name__ == &#x27;__main__&#x27;: test1 = TestClassVariable() test1.b = &quot;新添加&quot; test2 = TestClassVariable() try: print(TestClassVariable.b) except AttributeError as a: print(a) print(test1.b) try: print(test2.b) except AttributeError as a: print(a) 返回 所以，类变量是属于类本身的，类的对象仅仅是通过类指针去访问而已，python 解释器相当于把 test.a 当做了 TestClassVariable.a 而已 类方法类方法是在类中定义的方式使用 @classmethod 装饰器修饰的方法，它也属于类属性","tags":"python 类"},{"title":"python 内存详解","url":"/2022/12/10/python/python 内存详解/","text":"参考链接 https://docs.python.org/zh-cn/3/c-api/memory.html#overview 本文可能会涉及 python 驻留机制，请参考 python 驻留机制 前置知识 https://www.bilibili.com/video/BV1VP4y1b7HJ/?spm_id_from=333.999.0.0&amp;vd_source=f9937d98d0a8cc08ef5248c3c127d588 内存管理参考链接 https://www.bilibili.com/video/BV1qV4y1J7gY/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f9937d98d0a8cc08ef5248c3c127d588 python 官方原文在 Python 中，内存管理涉及到一个包含所有 Python 对象和数据结构的私有堆（heap）。这个私有堆的管理由内部的 Python 内存管理器（Python memory manager） 保证。Python 内存管理器有不同的组件来处理各种动态存储管理方面的问题，如共享、分割、预分配或缓存。在最底层，一个原始内存分配器通过与操作系统的内存管理器交互，确保私有堆中有足够的空间来存储所有与 Python 相关的数据。在原始内存分配器的基础上，几个对象特定的分配器在同一堆上运行，并根据每种对象类型的特点实现不同的内存管理策略。例如，整数对象在堆内的管理方式不同于字符串、元组或字典，因为整数需要不同的存储需求和速度与空间的权衡。因此，Python 内存管理器将一些工作分配给对象特定分配器，但确保后者在私有堆的范围内运行。 实际组成上面的名词 “私有堆”属于官方说法，但是实际上：一般由以下组成 堆内存 常量区 方法区 说明了 python 内存架构是只要是对象都会存储在堆（heap）中。这不同于 java 中的 数字类型（int…）。java 是存储在不太稳定的栈（stack）中，这也很好的说明了为什么 python 是动态语言类型 具体有关动态类型机制请参考 python 类详解 中关于动态绑定机制相关内容 python 堆内存管理Python 堆内存的管理是由解释器来执行，用户对它没有控制权，即使他们经常操作指向堆内内存块的对象指针，理解这一点十分重要。Python 对象和其他内部缓冲区的堆空间分配是由 Python 内存管理器按需通过 Python&#x2F;C API 函数进行的。 这一点理解起来很容易，因为我们所能肉眼看见的都是对象的引用，只能操作对象的引用，即时使用 del 关键字，也是删除一个引用计数，并不能真正地释放该引用所指向的内存。因为真正释放内存是由 python 的解释器完成的，当某个对象被引用计数为0是，python 解释器会调用垃圾回收机制去释放它。 对象的引用和对象这两者是不同的概念。一般来说，我们人所设定且肉眼可见的变量，函数，类等都是属于对象的引用，而对象本身是存储在内存中的，并且有一个内存地址，我们通过对象的引用指向该内存地址来操作对象本身。 多数情况下在很多情况下，我们说的对象基本指的对象的引用。 python 和大多数语言一样，对象的引用（以下简称引用）是存放在 栈（stack）中的，而对象由上面内存管理机制得出，是存放在 堆内存（heap），常量池中。 内存图关系如下 通过以上不难发现，堆和常量区中的对象由三部分组成：id，type，value。那么栈中的引用就会指向它们对象的 id ，通过这种方式操作对象，所以我们并没有直接操作对象而是操作引用。以下我们会简化内存的框图。 python一切皆对象python 宗旨是一切都是对象，那么 python 的数据类型包括 数字类型 字符串类型 列表类型 元组类型 字典类型 集合类型 函数类型 类类型 数字类型整数类型的内存机制数字类型是不可变类型，是因为当变化数字类型的值时，实则是让引用指向了新的对象，这样它的内存地址就发生了变化。 1234567891011121314a: int = 1b: float = 2.c: complex = 3 + 4jprint(f&quot;变化前a的id:&#123;id(a)&#125;&quot;)print(f&quot;变化前b的id:&#123;id(b)&#125;&quot;)print(f&quot;变化前c的id:&#123;id(c)&#125;&quot;)a: int = 10b: float = 20.c: complex = 30 + 40jprint(&quot;-&quot;*50)print(f&quot;变化后a的id:&#123;id(a)&#125;&quot;)print(f&quot;变化后b的id:&#123;id(b)&#125;&quot;)print(f&quot;变化后c的id:&#123;id(c)&#125;&quot;) 返回 - 以上不难看出当 a，b，c 的值发生改变后，a，b，c 三个引用都分别指向了新的对象。 内存图如下 - 以上内存分析显示由于更改了值，那么引用指向了新的对象，所以内存地址发生了变化。 整数类型的特殊内存机制如果有两个不同的引用指向“相同”的对象，python 会判断是否启用驻留机制，但是 python 命令行和 pycharm会优化 更多驻留机制请参考 python 驻留机制 1234567891011def test(): a = 1 b = 1 print(id(a), id(b)) c = 2500 d = 2500 print(id(c), id(d))if __name__ == &#x27;__main__&#x27;: test() 内存图如下 以上分析不难看出，如果在交互模式下运行，解释器会单独给 d&gt;256 再开一个内存空间。通常我们也称 -5~256 整数区间为小常量区 整数类型的引用删除再次新增引用小常量区对于小常量区我们如果 del 之前的引用，之后再引用指向相同的对象，地址是一直不变的 - 此时系统并未给 c 开辟单独的一个 50 内存空间 很明显看出没有新的内存空间 50 大常量区对于大常量区 &lt;5，&gt;256 的区间整数，在删除后新增引用的情况是保持和最新开辟空间的那个地址相同 以上不难看出，开辟了新的三个 900 内存空间，但是删除前 3 个 引用时，第四个引用并没有再单独开辟新的空间，而是继续指向最新的也就是第三个引用的内存地址。这点很重要，因为后面很多机制就会类似。 以上机制对于 pycharm 或命令行来说默认优化了，因为运行不是一行一行解释，而是优化后节省内存空间的方法因此，a，b，c，都会指向同一个 900 float 类型由于 float 类型数字没有所谓的驻留机制，那么每单独定义一个引用，都会新开一个内存空间 内存图 可以看出就可以把 float 当做大常量区的数据处理就行 &#96; 类型的引用删除再次新增引用同大整数类型一般，不做过多赘述 值得注意的是，pycharm 和命令行模式依旧会对该机制进行优化，显示还是指向了同一对象 12345678def test(): a = 1000.0 b = 1000.0 print(a is b) if __name__ == &#x27;__main__&#x27;: test() 返回 complex 类型 对于 complex 类型的数字同 float，不做过多赘述 字符串字符串的普通内存机制python 字符串有类似数字类型的内存机制 1234a: str = &quot;hello&quot;print(f&quot;变化前a的id:&#123;id(a)&#125;&quot;)a: str = &quot;hello world&quot;print(&quot;-&quot;*50)print(f&quot;变化后a的id:&#123;id(a)&#125;&quot;) 返回 - 以上不难看出依旧是内存地址发生了改变 内存图如下 字符串的特殊内存机制由于字符串一样具有驻留机制，所以我们讨论没有驻留机制的情况 由于对于字符串我们有字面量相加 和引用相加，那么就有两种情况 字面量相加对于字面量相加的情况 python 会优先在常量区寻找有没有对应的内存，如果没有才开辟新的空间 内存图 注意这是针对满足驻留情况的，若不满足驻留情况则会单独开辟空间 对于以上的两种情况，pycharm 和命令行还是会进行优化 引用相加引用相加不同与整数类型，会产生一个新的对象，然而这新的对象并未在常量区，而是在堆内存里 添加多个的情况 通过以上我们基本可以确定如果是引用相加或者调用方法形式会在堆中新开辟一个内存空间并且不会共享 注意这个情况在 pycharm 中并没有被优化 1234567891011121314def test(): a = &quot;hello&quot; b = &quot;world&quot; c = &quot;helloworld&quot; d = a + b e = a + b print(c is d) print(c is e) print(d is e) if __name__ == &#x27;__main__&#x27;: test() 返回 字符串的引用删除再次新增引用和上述整数类型机制相同。即使是在堆内存中，删除引用后再次在堆内存开辟也一个空间，也是和最新的那一次相同 12345678910111213def test(): a = &quot;hello&quot; b = &quot;world&quot; c = &quot;helloworld&quot; d = a + b print(id(d)) del d f = a + b print(id(f)) if __name__ == &#x27;__main__&#x27;: test() 返回 元组元组类型同样为不可变类型，原因是元组类型的每一个元素的引用都不可变化 元组的特殊内存机制元组类型和以上不同的是，它的对象是存储在堆内存中的。并且元组对象的元素本身存储的不是值，而是一个个引用 内存图如下 原因元组之所以被称为不可变类型，是因为一旦定义好了，value1 和 value2 就不能更改指向的对象了，并且不能再新增新的 value 遵守规则对于元组每个元素的内存机制，都要遵守以上和以下包括列表所有类型的规则，包括驻留机制等。但是 pycharm等和上面一样同样会优化该内存地址 举个例子，若 arg 是数字类型或字符串类型时，该指向常量区还是指向常量区。这也就解释了为什么python 官方模糊了私有堆内存，统称为堆的概念 内存图如下 列表列表内存机制和元组大同小异，但唯一不同的是，列表它可以更改 value 指向的对象，而且还可以删除 value 和新增 value。 内存图如下 列表的三种拷贝机制参考链接 python 基本数据类型常用方法 关于列表有关的深浅拷贝问题 赋值拷贝赋值拷贝本质是不改变原来的 value 和 list 的指向，只是新增了一个 list_copy 新的引用指向了跟 list 指向相同的对象 12345678910def test(): list = [1, 2, [1, 2]] list_copy = list print(list) print(list_copy) print(id(list), id(list_copy))if __name__ == &#x27;__main__&#x27;: test() 返回 内存图如下 浅拷贝解析拷贝本质一样是不改变原来的 value 和 list 的指向，只是新增了一个 list_copy 新的引用指向了跟 list 新的 id 不同的对象，但是该对象的 value 指向依旧不变 1234567891011121314def test(): list = [[], [1, 2]] list_copy = list.copy() print(list) print(list_copy) print(id(list), id(list_copy)) print(id(list[1]), id(list_copy[1])) list[1].append(&quot;新加的数据&quot;) print(list) print(list_copy) if __name__ == &#x27;__main__&#x27;: test() 返回 内存图如下 深拷贝浅拷贝本质一样是不改变原来的 value 和 list 的指向，但是新拷贝的引用会递归指向不同的内存空间，直到每一个指向的都是不可变类型为止 12345678910111213141516import copydef test(): list = [[], [1, 2]] list_copy = copy.deepcopy(list) print(list) print(list_copy) print(id(list), id(list_copy)) print(id(list[1]), id(list_copy[1])) list[1].append(&quot;新加的数据&quot;) print(list) print(list_copy) if __name__ == &#x27;__main__&#x27;: test() 返回 内存图 这就是为什么 list_copy 为什么不会像浅拷贝一样会添加新的 value2 的原因 遵守规则对于列表每个元素的内存机制，都要遵守以上和以下包括字典等所有类型的规则，包括驻留机制等。但是 pycharm 等和上面一样同样会优化该内存地址 同样的列表元素如果是数字等类型，依旧会指向常量区 字典字典涉及哈希表存储机制，这里不过多追溯 集合pass 函数函数一样也是对象，那么函数名就是对象的引用 函数的内存机制函数的内存机制就是在栈中开辟一个引用空间，叫做 栈帧。该空间用于存放函数内的其他引用，而函数本身引用指向堆内存的对象。因为函数本身是 types.FunctionType 类的对象，所以函数本身是根据类指针指向该类。与其他类型不同的是函数会单独使用到方法区的内存。当调用函数时，先会根据调用的引用去方法区加载函数，然后生成函数对象，最后函数引用指向函数对象。当函数引用被 del 或 return 后，它其中的局部变量等也会被消亡 123456def test(): a = 1 print(a)if __name__ == &#x27;__main__&#x27;: test() 对于以上方法的运行加载内存图如下 以上看出 test 只不过是函数对象的引用，这里函数的具体是哪个对象参考 python 函数详解 解释函数闭包通过以上解释了为什么闭包机制引用的局部变量不随着上层函数一起消亡 123456789101112def test(): a = 50 def back(arg): print(arg + a) return backif __name__ == &#x27;__main__&#x27;: back_ = test() back_(10) 内存图如下 这也就解释了为什么函数闭包后能够直接引用了，因为不仅 copy 了一份对对象的引用，还 copy 了原来局部变量的引用。即使之前函数消亡了也能够正常返回值。但值得注意的是，全局变量并不会被 copy，所以暂存不了全局变量。 相当于每次初始化内层函数在它自己的栈帧里拷贝了一份和外层函数的局部变量的一个内存地址，所以能够所谓的“留住”。而全局变量是在栈中共享的，可以理解为每个栈帧里没有它的备份，每次碰到全局变量都会去栈帧外的栈去找全局变量指向的对象值。 函数参数传递的内存机制 通过以上图了解到。方法调用给 n1 引用的对象和 n2 引用的对象新开了一个命名空间 arg1，arg2。此时 arg1 ，arg2 分别再次指向 n1 指向的对象和 n2 指向的对象。这样根据 python 变量的内存机制可以推出很多如下的性质 不可变类型参数如果实际参数 args 是不可变类型，则方法修改不会影响它的内存地址(指向)。因为是新开的内存引用原对象 这经常会造成非元组类的不可变类型在方法中无法修改 123456789101112131415161718192021222324252627282930313233def test(arg1: str, arg2: int): print(&quot;形参arg1:&quot;, arg1) print(&quot;形参arg1的内存地址:&quot;, id(arg1)) print(&quot;---------------------------------&quot;) print(&quot;形参arg2:&quot;, arg2) print(&quot;形参arg2的内存地址:&quot;, id(arg2)) print(&quot;---------------------------------&quot;) arg1 = arg1.lower() arg2 = arg2 * 2 print(&quot;变化后的形参arg1:&quot;, arg1) print(&quot;变化后的形参arg1的内存地址:&quot;, id(arg1)) print(&quot;---------------------------------&quot;) print(&quot;变化后的形参arg2:&quot;, arg2) print(&quot;变化后的形参arg的内存地址:&quot;, id(arg2))if __name__ == &#x27;__main__&#x27;: n1 = &quot;HELLO WORLD!&quot; n2 = 20 print(&quot;--------------------&quot;) print(&quot;实参n1:&quot;, n1) print(&quot;实参n1的内存地址:&quot;, id(n1)) print(&quot;--------------------&quot;) print(&quot;实参n2:&quot;, n2) print(&quot;实参n2的内存地址:&quot;, id(n2)) print(&quot;--------------------&quot;) test(arg1=n1, arg2=n2) print(&quot;调用方法后实参n1:&quot;, n1) print(&quot;调用方法后实参n1的内存地址:&quot;, id(n1)) print(&quot;--------------------&quot;) print(&quot;调用方法后实参n2:&quot;, n2) print(&quot;调用方法后实参n2的内存地址:&quot;, id(n2)) print(&quot;--------------------&quot;) 返回 分析以上数据可以发现 n1，n2的内存地址不变，n1，n2的值不变 参数是元组的情况元组虽然也是不可变类型，但是方法修改不了它每个元素的内存地址，即时是这样，方法依旧可以修改元组列表元素或字典元素这种可变类型的值 1234567891011121314151617181920212223242526272829def test(arg1: tuple): print(&quot;形参arg1:&quot;, arg1) print(&quot;形参arg1的内存地址:&quot;, id(arg1)) print(&quot;---------------------------------&quot;) for element in arg1: print(f&quot;&#x27;&#123;element&#125;&#x27;的内存地址是:&#123;id(element)&#125;&quot;, end=&quot; &quot;) print() print(&quot;---------------------------------&quot;) arg1[2].append(2) arg1[3][2] = &quot;second&quot; print(&quot;变化后的形参arg1:&quot;, arg1) print(&quot;变化后的形参arg1的内存地址:&quot;, id(arg1)) print(&quot;---------------------------------&quot;) for element in arg1: print(f&quot;变化后&#x27;&#123;element&#125;&#x27;的内存地址是:&#123;id(element)&#125;&quot;, end=&quot; &quot;) print() print(&quot;---------------------------------&quot;)if __name__ == &#x27;__main__&#x27;: n1 = (1, &quot;hello world&quot;, [1], &#123;1: &quot;first&quot;&#125;) print(&quot;--------------------&quot;) print(&quot;实参n1:&quot;, n1) print(&quot;实参n1的内存地址:&quot;, id(n1)) print(&quot;--------------------&quot;) test(arg1=n1) print(&quot;调用方法后实参n1:&quot;, n1) print(&quot;调用方法后实参n1的内存地址:&quot;, id(n1)) print(&quot;--------------------&quot;) 返回 分析以上数据发现 n1 的内存地址不变，n1的元素内存地址也不变，但是 n1 的列表元素和字典元素的值发生了改变 可变类型参数如果实际参数 args 是可变类型，方法依旧无法修改它的内存地址。同样是因为新开的内存引用原对象，但是可以修改它的值，这必须建立在对它本身的增删改查等。 1234567891011121314151617181920212223242526272829def test(arg1: list): print(&quot;形参arg1:&quot;, arg1) print(&quot;形参arg1的内存地址:&quot;, id(arg1)) print(&quot;---------------------------------&quot;) for element in arg1: print(f&quot;&#x27;&#123;element&#125;&#x27;的内存地址是:&#123;id(element)&#125;&quot;, end=&quot; &quot;) print() print(&quot;---------------------------------&quot;) arg1[1] = arg1[1].lower() arg1.append([&quot;新添加的元素&quot;]) print(&quot;变化后的形参arg1:&quot;, arg1) print(&quot;变化后的形参arg1的内存地址:&quot;, id(arg1)) print(&quot;---------------------------------&quot;) for element in arg1: print(f&quot;变化后&#x27;&#123;element&#125;&#x27;的内存地址是:&#123;id(element)&#125;&quot;, end=&quot; &quot;) print() print(&quot;---------------------------------&quot;)if __name__ == &#x27;__main__&#x27;: n1 = [1, &quot;HELLO&quot;] print(&quot;--------------------&quot;) print(&quot;实参n1:&quot;, n1) print(&quot;实参n1的内存地址:&quot;, id(n1)) print(&quot;--------------------&quot;) test(arg1=n1) print(&quot;调用方法后实参n1:&quot;, n1) print(&quot;调用方法后实参n1的内存地址:&quot;, id(n1)) print(&quot;--------------------&quot;) 返回 分析以上数据发现 n1 的内存地址不变，n1 的元素&quot;HELLO&quot;的内存地址发生了改变，n1 的值同样发生了改变 类参考链接如下 https://juejin.cn/post/6975845305447104549 类特殊的内存机制类和其他不同的是，类对象的引用是保存在堆区的。这里和实例化后的类的对象的引用不同 本质原因类之所以是对象因为类是 type 类的对象 类其实不用声明 class 去创建，直接通过 type() 实例化一个类实例，只不过 class 声明更美观易懂","tags":"python 内存机制"},{"title":"python 迭代器和生成器","url":"/2022/12/10/python/python 迭代器和生成器/","text":"迭代器（iterator）python 独有的一种数据类型。要理清迭代器是什么，首先得弄懂什么要可迭代（iterable） 可迭代类与可迭代对象python 规定如果一个类定义了一个 __iter__() 的魔法方法的话，那么这个类就是 可迭代类，它的实例化对象就是一个 可迭代对象 我们可以导入 collections 包的 abc 模块查看某个对象是否是 Iterable 的 1234567891011from collections import abcclass TestIterable: def __iter__(self): return selfif __name__ == &#x27;__main__&#x27;: iterable = TestIterable() print(isinstance(iterable, abc.Iterable)) 返回 从上面我们可以看到，类 TestIterable 定义了一个 __iter__() 方法，并且要返回一个对象，这里是它本身，那么 TestIterable 类就被称为 可迭代类，它的对象 iterable 就被称为 可迭代对象 可迭代对象的 __iter()__方法由于 __iter__() 是可迭代对象的方法，那么它本身可以调用它 123456789class TestIterable: def __iter__(self): print(&quot;我是可迭代对象的 __iter__() 方法&quot;)if __name__ == &#x27;__main__&#x27;: iterable = TestIterable() iterable.__iter__() 返回 内置函数 iter()python 提供一个内置方法 iter() 方法可以直接调用对象的 __iter__() 方法 123456789101112class TestIterable: def __iter__(self): print(&quot;我是可迭代对象的 __iter__() 方法&quot;)if __name__ == &#x27;__main__&#x27;: iterable = TestIterable() try: iter(iterable) except TypeError as t: print(t) 返回 以上不难发现，iter() 方法确实是调用了 __iter__() 方法，但是本身抛出了一个异常，因为返回值不是一个 迭代器，而是一个无类型的 None 对 for 循环进行重新认识1234567891011121314def test_iterable(): test_list = [1, 2] test_tuple = (1, 2) test_dict = &#123;1:&quot;FIRST&quot;, 2:&quot;SECOND&quot;&#125; for i in test_list: print(i) for j in test_tuple: print(j) for k in test_dict: print(k)if __name__ == &#x27;__main__&#x27;: test_iterable() 是什么能让 list，tuple，dict 进行 for in 循环呢。答案是 list，tuple，dict 是可迭代类，理由如下 12345678910111213def test_iterable(): test_list = [1, 2] test_tuple = (1, 2) test_dict = &#123;1:&quot;FIRST&quot;, 2:&quot;SECOND&quot;&#125; print(dir(test_list)) print() print(dir(test_tuple)) print() print(dir(test_dict))if __name__ == &#x27;__main__&#x27;: test_iterable() 通过内置 dir() 找到三个不同对象所有的类属性 注意到这三个类都定义了 __iter__() 方法，所以他们的对象才都时可迭代的，因此才能被 for in 循环遍历 可迭代对象进行 for 循环12345678910111213class TestIterable: def __iter__(self): print(&quot;我是可迭代对象的 __iter__() 方法&quot;)if __name__ == &#x27;__main__&#x27;: iterable = TestIterable() try: for i in iterable: print(i) except TypeError as t: print(t) 返回 可以看到 for in 循环和 iter() 方法一样，同样调用了 __iter__() 方法，并且也会提示抛出了一个异常，因为返回值不是一个 迭代器，而是一个无类型的 None。以下讲解什么是迭代器 迭代类和迭代器了解完可迭代类和可迭代对象后，我们对迭代类和迭代器作出讲解 python 规定一个类如果同时定义了 __iter__() 和 __next__()方法时，那么我们就称这个类为迭代类或者叫迭代器类，同理它的对象被称为 迭代对象 或者叫 迭代器 12345678910111213141516from collections import abcclass TestIterator: def __iter__(self): return self def __next__(self): return selfif __name__ == &#x27;__main__&#x27;: iterator = TestIterator() print(isinstance(iterator, abc.Iterable)) print(isinstance(iterator, abc.Iterator)) 返回 发现迭代器依旧本身也是一个可迭代对象，因为它的类同样包含 __iter__() 方法，不同的是，它还是迭代器，因为其中包含 __next__() 方法 对迭代器对象的 iter()首先，我们对迭代器对象进行 iter()方法处理 12345678910111213class TestIterator: def __iter__(self): return self def __next__(self): return selfif __name__ == &#x27;__main__&#x27;: iterator = TestIterator() print(iter(iterator)) print(type(iter(iterator))) 返回 会发现这次和上面可迭代对象不同的是，迭代器由于返回的 self 本身是迭代器，所以，iter() 方法并没有报错 迭代器调用 __next__()方法123456789101112class TestIterator: def __iter__(self): return self def __next__(self): print(&quot;这是迭代器的 __next__() 方法&quot;)if __name__ == &#x27;__main__&#x27;: iterator = TestIterator() iterator.__next__() 返回 同理，__next__() 方法也有内置方法 next() 方法作为快速调用 1234567891011class TestIterator: def __iter__(self): return self def __next__(self): print(&quot;这是迭代器的 __next__() 方法&quot;)if __name__ == &#x27;__main__&#x27;: iterator = TestIterator() next(iterator) 返回 对迭代器的 for in 循环12345678910111213class TestIterator: def __iter__(self): return self def __next__(self): print(&quot;这是迭代器的 __next__() 方法&quot;)if __name__ == &#x27;__main__&#x27;: iterator = TestIterator() for i in iterator: print(i) 返回 你会发现陷入了死循环 原因如下： for i in iterable 内部先调用了 iter(iterable) 方法返回一个迭代器的对象 iterator，再循环调用 next(iterator) 方法，这也是为什么会陷入死循环的原因 解决 for in 死循环要想不陷入死循环，我们按照官方的定义，在 __next__() 方法 raise 一个 StopIteration 异常就可以 12345678910111213class TestIterator: def __iter__(self): return self def __next__(self): print(&quot;这是迭代器的 __next__() 方法&quot;) raise StopIteration(&quot;循环结束&quot;)if __name__ == &#x27;__main__&#x27;: iterator = TestIterator() for i in iterator: print(i) 返回 总结综上所诉，for in 循环后的对象一定要是可迭代对象，在 python 中，可迭代对象分为 纯可迭代对象和迭代器。所以，要想 for in 循环不报错，那么可迭代对象的 __iter__() 方法一定返回的是一个迭代器，而迭代器的 __iter__() 方法返回对的绝对多数情况是它本身 self，且 __next__() 配合 raise StopIteration 可以终止循环 自定义 range() 方法以下是基于可迭代对象和迭代器写的一个新的简单的 range() 方法 123456789101112131415161718192021222324252627282930class RangeIterator: def __init__(self, number: int): self.number = number self.__count = -1 def __iter__(self): return self def __next__(self): if self.__count &lt; self.number - 1: self.__count += 1 return self.__count else: raise StopIterationclass NewRange: def __init__(self, number: int): self.number = number def __iter__(self): return RangeIterator(self.number)if __name__ == &#x27;__main__&#x27;: for i in NewRange(0): print(i) print(&quot;*&quot;*30) for j in NewRange(5): print(j) 返回 迭代器实现 range()同理，因为迭代器本身也是可迭代对象，那么只用迭代器类也可以实现 range() 循环 12345678910111213141516171819202122class NewRange: def __init__(self, number: int): self.number = number self.__count = -1 def __iter__(self): return self def __next__(self): if self.__count &lt; self.number - 1: self.__count += 1 return self.__count else: raise StopIterationif __name__ == &#x27;__main__&#x27;: for i in NewRange(0): print(i) print(&quot;*&quot;*30) for j in NewRange(5): print(j) 返回 可迭代对象实现单向链表以下是基于迭代器实现单向链表 1234567891011121314151617181920212223242526272829303132333435363738class NodeIterator: def __init__(self, node_obj): self.node_obj = node_obj def __iter__(self): return self def __next__(self): if self.node_obj: name = self.node_obj.name self.node_obj = self.node_obj.next return name else: raise StopIterationclass NodeIterable: def __init__(self, name): self.name = name self.next = None def __iter__(self): return NodeIterator(self)if __name__ == &#x27;__main__&#x27;: node1 = NodeIterable(&quot;first&quot;) node2 = NodeIterable(&quot;second&quot;) node3 = NodeIterable(&quot;third&quot;) node1.next = node2 node2.next = node3 for node in node1: print(node) 返回 迭代器实现单向链表1234567891011121314151617181920212223242526272829class Node: def __init__(self, name): self.name = name self.next = None self.obj = self def __iter__(self): return self def __next__(self): if self.obj: nodes = self.obj.name self.obj = self.obj.next return nodes else: raise StopIterationif __name__ == &#x27;__main__&#x27;: node1 = Node(&quot;first&quot;) node2 = Node(&quot;second&quot;) node3 = Node(&quot;third&quot;) node1.next = node2 node2.next = node3 for node in node1: print(node) 返回 next 指针指向的始终是下一个对象，如果判定 self.obj.next 指向的下一个对象是 None，即没有下一个对象，那么遍历整个链表成功 通过迭代器解决环链问题class Node: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758def __init__(self, name): self.name = name self.next = None self.flag = 0 # 设置一个标志 self.fast = self # 设置两个从相同节点出发速度不同的指针 self.slow = selfdef __iter__(self): return selfdef __next__(self): # 如果遍历多次出现了快慢指针一样,说明必然有环 if self.flag == 1: raise StopIteration # 如果标志位为2直接跳出循环 if self.flag == 2: raise StopIteration try: self.fast = self.fast.next.next self.slow = self.slow.next # 如果有报错,说明必然无环,设置标志位为2 except AttributeError: self.flag = 2 return False if self.fast == self.slow: self.flag = 1 return Trueif __name__ == &#x27;__main__&#x27;: head = Node(&quot;first&quot;) node2 = Node(&quot;second&quot;) node3 = Node(&quot;third&quot;) # 设置无环链表 head.next = node2 node2.next = node3 for node in head: if node is True: print(&quot;该链表是环链&quot;) elif node is False: print(&quot;该链表不是环链&quot;) head = Node(&quot;first&quot;) node2 = Node(&quot;second&quot;) node3 = Node(&quot;third&quot;) # 设置一个有环链表 head.next = node2 node2.next = node3 node3.next = head for node in head: if node is True: print(&quot;该链表是环链&quot;) elif node is False: print(&quot;该链表不是环链&quot;) 返回 常用的内置迭代器zip() ，map()，filter()，文件对象。这意味着它们都能够被 for in 循环遍历 1234567def test_iterator(): with open(__file__, encoding=&quot;utf-8&quot;, mode=&quot;rt&quot;) as file: print(dir(file))if __name__ == &#x27;__main__&#x27;: test_iterator() 生成器（generator）如果一个方法中拥有关键字 yield，不管这个 yield 关键字位置在哪，那么这个方法就被称为生成器。因为方法加载需要在方法区，方法区识别有 yield 后，会在堆中创建一个生成器 （generator） 1234567def generator(): return yieldif __name__ == &#x27;__main__&#x27;: print(type(generator())) 返回 yield 关键字yield 关键字的作用是，当调用方法时，会创建一个生成器对象，并不会运行方法。如果调用 next() 方法时，会先执行方法直到碰到一个 yield，并将一个 yield 返回值作为第一返回值返回，如果再次调用 next() 方法时，依旧会执行接下的代码直到碰到下一个 yield，并返回值，如果没有碰到 yield，则会抛出 StopIteration 异常 123456789101112131415def generator(number): while number &lt; 3: print(&quot;begin&quot;) yield number print(&quot;end&quot;) print() number += 1if __name__ == &#x27;__main__&#x27;: generator = generator(0) print(next(generator)) print(next(generator)) print(next(generator)) print(next(generator)) 返回 生成器与迭代器关系生成器是一个特殊的迭代器，可以被 for in 循环遍历 12345678910111213def generator(number): while number &lt; 3: print(&quot;begin&quot;) yield number print(&quot;end&quot;) print() number += 1if __name__ == &#x27;__main__&#x27;: generator = generator(0) for i in generator: print(i) 返回 该 for in 循环相当于每次都对 generator 进行一次 next() 方法操作，只是最后一步不会抛出异常 yield 语句返回值yield 语句本身也有值，但是默认为 None 1234567891011def generator(number): while number &lt; 3: a = yield number number += 1 print(a)if __name__ == &#x27;__main__&#x27;: generator = generator(0) for i in generator: print(i) 返回 你会发现，a 的值永远是 None send() 方法通过 send() 方法修改 yield 返回值 123456789101112def generator(number): while number &lt; 3: a = yield number number += 1 print(f&quot;a的值是&#123;a&#125;&quot;)if __name__ == &#x27;__main__&#x27;: generator = generator(0) print(next(generator)) print() print(generator.send(3)) 返回 send() 方法本质 send() 方法本质就是 next() 方法，不过是让 yield 语句有值罢了。所以 next() 语句相当于 send(None)，但是不能初始时给生成器传值 12345678910def generator(number): while number &lt; 3: a = yield number number += 1 print(f&quot;a的值是&#123;a&#125;&quot;)if __name__ == &#x27;__main__&#x27;: generator = generator(0) print(generator.send(3)) 返回 生成器完定义range() 方法12345678910def range_generator(number): count = 0 while count &lt; number: yield count count += 1if __name__ == &#x27;__main__&#x27;: for i in range_generator(5): print(i) 返回 生成器完成单向链表1234567891011121314151617181920212223class Node: def __init__(self, name): self.name = name self.next = None self.obj = self def __iter__(self): while self.obj: yield self.obj.name self.obj = self.obj.nextif __name__ == &#x27;__main__&#x27;: node1 = Node(&quot;first&quot;) node2 = Node(&quot;second&quot;) node3 = Node(&quot;third&quot;) node1.next = node2 node2.next = node3 for i in node1: print(i) 返回 利用生成器判定是否是环链表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Node: def __init__(self, name): self.name = name self.next = None self.flag = 0 self.fast = self self.slow = self def __iter__(self): loop = True while loop: yield self.flag if self.flag == 1: loop = False continue elif self.flag == 2: loop = False continue try: self.fast = self.fast.next.next self.slow = self.slow.next except AttributeError: self.flag = 2 if self.fast == self.slow: self.flag = 1if __name__ == &#x27;__main__&#x27;: node1 = Node(&quot;first&quot;) node2 = Node(&quot;second&quot;) node3 = Node(&quot;third&quot;) node1.next = node2 node2.next = node3 for i in node1: if i == 0: pass elif i == 1: print(&quot;该链表是环链表&quot;) else: print(&quot;该链表不是环链表&quot;) node1 = Node(&quot;first&quot;) node2 = Node(&quot;second&quot;) node3 = Node(&quot;third&quot;) node1.next = node2 node2.next = node3 node3.next = node1 for i in node1: if i == 0: pass elif i == 1: print(&quot;该链表是环链表&quot;) else: print(&quot;该链表不是环链表&quot;) 返回","tags":"python 迭代器和生成器"},{"title":"python 函数详解","url":"/2022/12/08/python/python 函数详解/","text":"参考以下有关变量的作用域和类相关的请参考 python 变量的作用域 python 内存详解 python 类详解 函数命名规则小写开头，多个单词下划线 _ 隔开 hello()，test_()， _good_time() 12345678def test_(self): passdef hello(self): passdef _good_time(self): pass 对于类里的函数命名规则对于类里的方法命名有以下规则 python 预先自定义的__init__()，__str__()等收尾双下划线的方法名称为魔法函数。并且一般不建议自己这样命名方法如__public__()因为会被误解为魔法函数。 123456789class Test: def __init__(self, name): self.name = name def __str__(self): return &quot;Test类&quot; def __public__(self): pass __private()以双下划线开头但是不以双下划线结尾的称为私有函数，只能在类里面调用 1234567891011class Test: def __private(self): passif __name__ == &#x27;__main__&#x27;: test = Test() try: test.__private() except AttributeError as a: print(a) 返回 特殊情况然而可以通过_Test__private()强制访问 12345678910class Test: def __private(self): return 1if __name__ == &#x27;__main__&#x27;: test = Test() print(dir(test)) print(test._Test__private()) 返回 以上我们可以看到 test 属性有一个 _Test__private，这意味着可以用它取访问私有的属性。python 其实没有正在意义上的私有属性，只不过我们希望它不能被外界访问时，加入这样的标识符使得被 python 识别。python 不支持私有属性,但当属性命名为 __ 时,会将属性改名为_类名__属性名.这个方法其实是变量名压缩( mangling ,相当于扩张)的概念,只是通过这种方法变相地实现了属性访问控制的功能。但是呢这个方法也很有用,尤其在多重继承,或者大项目的情况下,各个类及实例可能出现属性冲突的情况,就可以通过这个功能来实现。 参考链接 https://blog.csdn.net/renyiforever/article/details/79921854 函数参数参考链接 https://www.bilibili.com/video/BV1k7411W78H?p=6&amp;vd_source=f9937d98d0a8cc08ef5248c3c127d588 参数类别总所周知，写在函数名括号后的叫形式参数，简称形参；实际传值的参数叫实际参数，简称实参 位置参数位置参数设定好以后位置传参不能随意发生改变。若随意改变，函数的功能会发生变化。并且传参参数量一定要匹配，多了或者少了会报错。 123456789101112131415161718192021def test(arg1, arg2, arg3): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;arg3&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test(1, 2, 3) print(&quot;**********************&quot;) test(3, 2, 1) print(&quot;**********************&quot;) try: test(1, 2) except TypeError as t: print(t) print(&quot;**********************&quot;) try: test(1, 2, 3, 4) except TypeError as t: print(t) 返回 参数位置发生改变，方法功能性发生了改变。第一个输出的是 1，2，3；第二个输出的是 3，2，1 参数数量出现问题会抛出错误提示缺少一个位置参数和给多给了位置参数 关键字参数位置参数固然稳定，但是 python 对于方法参数的数量没有做定量要求(java 一般要求参数数量不多于6个)，那么对于多位置参数这种方式会容易位置混乱容易照成方法功能性不符合预期 对于以上问题 python 给出解决方案为 关键字参数 使用方法是：针对形参名在传实参时可以指定想要传入给哪个形参，受指定的参数不受位置问题从而影响方法的功能性 但是一样要满足参数数量的严格吻合，否则还是会报错。并且不能对相同的关键字参数多次传值 1234567891011def test(arg1, arg2, arg3): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;arg3&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test(1, 2, 3) print(&quot;**********************&quot;) test(arg3=3, arg2=2, arg1=1) 返回 以上不难看出关键字参数的使用具有指定性功能。这样即时位置混乱只要符合以上要求都能保持方法功能的正常使用 位置参数和关键字参数混搭混搭规则是一定是实参传递时位置参数在前，关键字参数在后，否则会报错（铁律） 123456789101112def test(arg1, arg2, arg3): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;arg3&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test(1, 2, arg3=3) print(&quot;**********************&quot;) test(1, arg2=2, arg3=3) 返回 若实参传递时关键字参数放在位置参数之前，则编译会报错 以上报错信息提示位置参数在关键字参数之后了。 即使满足位置参数在前，关键字参数在后依旧会报错，位置参数还应该对应本身位置 123456789101112131415def test(arg1, arg2, arg3): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;arg3&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test(1 , 2, 3) print(&quot;**********************&quot;) try: test(10, 30, arg2=20) except TypeError as t: print(t) 返回 以上不难看出，arg1，arg2 位置参数都已经给出了参数，但是随后的关键字参数再次给位置参数 arg2 传值，所以提示 test() 方法传给了 arg2 多个值的错误 强制关键字参数为了让位置参数不容易写混淆而照成方法功能性错误，从而引入强制关键字参数 用法是在需要使用强制关键字参数之前写入 * 号，代表 * 后的参数强制只能使用关键字参数 123456789101112131415def test(*, arg1, arg2, arg3): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;arg3&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test(arg1=1, arg2=2, arg3=3) print(&quot;**********************&quot;) try: test(1, 2, arg3=3) except TypeError as t: print(t) 返回 以上不难看出 * 后实参的传递必须是关键字参数形式，如果没有按这样的方式，就会报 TypeError—test() 方法是0个位置参数，但是传递了2个位置参数 值得注意的是 * 号前依旧可以使用位置参数和关键字参数混搭，但是这建立在形参的 * 号位置 123456789101112131415def test(arg1, arg2, *, arg3): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;arg3&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test(1, arg2=2, arg3=3) print(&quot;**********************&quot;) try: test(1, 2, 3) except TypeError as t: print(t) 返回 以上不难看出可以通过改变 * 号位置灵活使用强制关键字参数，但是依旧要遵守相关的混搭规则。 默认参数在定义形参的时候，我们可以默认给其中的参数传递初始值(默认值)，这样依旧可以正常的定义参数 关键字参数的用法是：在传递实参的时候你可以给默认参数传递一个新的值，也可以不传递 1234567891011def test(arg1=1, arg2=2, arg3=3): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;arg3&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test() print(&quot;**********************&quot;) test(10, arg2=20) 返回 以上不难看出可以不用给默认参数传值，也可以给其中的默认参数传值。传值可以使用位置参数和关键字参数混搭的模式，但是依旧要遵守混搭规则。 默认参数的注意点默认参数由于是函数加载时就初始化默认参数值的，这点需要注意。这就导致如果默认参数是可变类型的（列表，字典等），那么初始化的时候默认参数会共享一个内存地址。这就导致后续改变默认参数的行为会影响到其他对象 12345678910111213class Default: def __init__(self, name = [&quot;Jack&quot;]): self.name = nameif __name__ == &#x27;__main__&#x27;: default1 = Default() default2 = Default() default3 = Default([&quot;Messi&quot;]) print(default1.name, default2.name, default3.name) default1.name.append(&quot;Nance&quot;) print(default1.name, default2.name, default3.name) 返回 以上我们看到如果不传入参数给默认参数的话，default1.name 和 default2.name 使用的同一个内存空间，这样当 default1.name 改变时会使得 default2.name 一起改变。但是如果给默认参数传值不会引用同一个内存空间，以上具体原因请参考 python 内存详解 中有关可变对象的内容。 所以尽量不要使用可变类型当做默认参数。其中 pycharm 也会人性化提示 解决办法如果我们实在想传一个默认参数为可变对象的时候，可以利用设计模式来实现 123456789101112def default(_default = None): if _default is None: _default = [] return _default, id(_default)if __name__ == &#x27;__main__&#x27;: default1 = default() default2 = default() print(default1) print(default2) 返回 这样就解决了默认参数的缺陷，但是前提是你要知道你默认参数要传什么值 默认参数的混搭默认参数依旧可以和之前的位置参数和关键字参数以及强制关键字参数混搭 123456789101112def test(arg1, arg2, arg3, arg4=4): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;arg3&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第四个参数是:&#123;arg4&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test(1, arg2=2, arg3=3, arg4=40) print(&quot;**********************&quot;) 返回 以上不难看出默认参数混搭时依旧要遵守之前的混搭规则 还有一点值得注意的是定义默认参数形参的时候一定要把所有的非默认参数在默认参数之前定义，否则编译不通过（除非形参包含强制关键字参数或可变参数，请参考下面可变位置参数） 这很好理解，因为如果定义在非默认参数之前，当传递实参的时候，编译器不知道你是否给默认参数传递了值，这样为了避免二义性直接编译阶段报错 当默认参数和强制关键字混搭时，由于默认参数的特性，当使用默认值时，我们可以不写 &#x3D; ，但是想给默认参数传值时，则一定要指明默认参数名 123456789101112131415def test(arg1, *, arg2=2, arg3=3): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;arg3&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test(1, arg2=20) print(&quot;**********************&quot;) try: test(1, 20, 30) except TypeError as t: print(t) 返回 以上不难看出如果定义在强制关键词参数后的默认参数想修改默认参数的值，必须要写 &#x3D;，否则就会报错 默认参数和强制关键字参数混搭可以打破默认参数位置限制，但 * 号前的参数依旧要满足默认参数位限制（默认参数位置限制参考上面） 12345678910def test(arg1, *, arg2=2, arg3): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;arg3&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test(1, arg2=20, arg3=3) 返回 以上不难看出默认参数可以写在位置参数之前了，打破了之前的限制，因为后面位置参数变为了强制关键字参数，因此不会引发二义性。但是后面的强制关键字参数依旧要使用等号，否则编译不通过。因为不满足实参传值时位置参数要在关键字参数之前 可变位置参数有时候我们不确定具体传参时某些形参需要传多少个，那么我们就引入可变位置参数（可变参数） 使用方式：在定义形参的名字前写上 * def test(*args) 该可变位置参数通过把我们实际传递的实参用一个元组 args 来接受，这样完成可变确定的参数传值。当然，args也可以是一个可迭代对象，具体参考 python 表达式和生成式 中关于 *号解包压包的有关内容 1234567891011121314def test(*args): num = 1 if len(args) == 0: print(&quot;该可变位置参数没有传值&quot;) for i in args: print(f&quot;该可变位置参数参数的第&#123;num&#125;个元素是:&#123;i&#125;&quot;) num += 1 print(f&quot;args的值为:&#123;args&#125;, args的类型为:&#123;type(args)&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test() print(&quot;**********************&quot;) test(10, 20, 30, [40]) 返回 以上不难看出 args 类型为 tuple 元组类型；并且可以不传实参给他，那么 args 就为空元组 可变位置参数的混搭很明显，实际需要和可变位置参数的混搭完成函数的功能多样性 可变位置参数可以和之前的参数任何一种或几种进行混搭，前提是依旧要满足他们各自的规则。 12345678910111213def test(arg1, *args, arg3=3): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;args&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;arg3&#125;&quot;) print(&quot;---------------------&quot;)if __name__ == &#x27;__main__&#x27;: test(1, [], &#123;&#125;, &quot;&quot;, 30) print(&quot;**********************&quot;) test(1, [], &#123;&#125;, &quot;&quot;, arg3=30) 返回 以上不难看出可变位置参数本质上扮演者位置参数角色，如果要给之后的默认参数传值就得使用关键字参数进行传值，否则会默认把之后的参数都传入可变参数的元组里 可变参数混搭位置参数如果某些位置参数在可变参数之后，那么一定要以关键字参数形式进行传参 1234567891011121314def test(*args, arg2): print(f&quot;第一个参数是:&#123;args&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;)if __name__ == &#x27;__main__&#x27;: test(1, [], &#123;&#125;, arg2=20) print(&quot;**********************&quot;) try: test(1, [], &#123;&#125;, 20) except TypeError as t: print(t) 返回 以上不难看出如果不以关键字形式进行传参，那么就会报缺少关键字参数的错误 可变位置参数依旧可以打破默认参数在位置参数之后的限制，但可变参数前的参数依旧要满足默认参数位限制（参考上面介绍）但是 123456789101112def test(arg1, arg2=2, *args): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;args&#125;&quot;) print(&quot;---------------------&quot;)if __name__ == &#x27;__main__&#x27;: test(1, 20, [], &#123;&#125;) print(&quot;**********************&quot;) 返回 以上不难看出默认参数的默认值修改了。系统并没有把 20 传入元组作为 args。所以当出现打破默认参数位置限制的时，默认参数传值不能进行关键字参数进行传递，情况如下 第一种情况是关键字参数在前对默认参数进行赋值，很明显违背位置参数要在关键字参数之前的规则 1234567891011def test(arg1, arg2=2, *args): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;args&#125;&quot;) print(&quot;---------------------&quot;)if __name__ == &#x27;__main__&#x27;: test(1, arg2=20, [], &#123;&#125;) 报错信息 第二种情况是默认参数放在了后面，但是结合上面的分析，即时关键字参数放在最后，依旧要满足位置对应关系 12345678910111213def test(arg1, arg2=2, *args): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;args&#125;&quot;) print(&quot;---------------------&quot;)if __name__ == &#x27;__main__&#x27;: try: test(1, [], &#123;&#125;, arg2=20) except TypeError as t: print(t) 报错信息 很明显提示 arg2 之前已经赋值了[] ,，所以重复赋值 注意可变位置参数不能和强制关键字参数进行混搭，否则编译不通过 可变关键字参数实际中如果我们要传入一组参数名和参数值不确定的参数时，我们可以用可变关键字参数进行定义 使用方式：在定义形参的名字前写上 ** def test(**kwargs) 该可变关键字参数通过把我们实际传递的实参用一个字典 kwargs 来接受，这样完成可变确定的参数传值 1234567def test(**kwargs): print(f&quot;可变关键字参数是:&#123;kwargs&#125;, 类型是:&#123;type(kwargs)&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test() print(&quot;**********************&quot;) test(first=10, second=20) 返回 以上不难看出返回的是一个实参输入的参数名-参数值得字典键值对，kwargs 类型是 dict 类型 可变关键字参数的混搭可变关键字参数的混搭顺序，一定是在所有参数类型最后再定义，理由很简单：因为是用关键字参数进行传递，那么不能在默认参数和位置参数之前，这两者就包含了可变位置参数。特殊地依旧不能在强制关键字之前定义，因为不知道后面的关键字参数是否是传给 kwargs，还是本身 强制位置参数用法 &#x2F; 这是 python 3.8 的新特性 强制位置表示在 &#x2F; 之前一定要使用位置参数，不接受使用关键字参数 123456789101112131415def test(arg1, arg2=2, /, arg3=3): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;arg3&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test(10, 20, arg3=30) print(&quot;**********************&quot;) try: test(arg1=10, arg2=20, arg3=30) except TypeError as t: print(t) 返回 以上不难看出如果用关键字参数给 &#x2F; 之前的参数赋值，那么会报错 强制位置参数不能在可变位置参数之后定义 强制位置参数不能在可变关键字参数之后定义 强制位置参数很明显应该放在强制关键字参数之前定义，否则引发矛盾 解包（开包）python 可以通过 * 对列表或元组进行解包，通过 ** 对字典进行解包 1234567891011def test(): list1 = [1, 2, 3] tuple1 = (1, 2, 3) dict1 = &#123;&quot;first&quot;: 1, &quot;second&quot;: 2, &quot;third&quot;: 3&#125; print(*list1) print(*tuple1) print(*dict1)if __name__ == &#x27;__main__&#x27;: test() 返回 通过以上发现，解包无非是对序列进行进行遍历。注意 * 号对字典解包是取它的 keys 解包的应用此应用于传参中 1234567891011121314def test(arg1, arg2, arg3): print(f&quot;第一个参数是:&#123;arg1&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第二个参数是:&#123;arg2&#125;&quot;) print(&quot;---------------------&quot;) print(f&quot;第三个参数是:&#123;arg3&#125;&quot;)if __name__ == &#x27;__main__&#x27;: args1 = [1, 2, 3] args2 = (1, 2, 3) test(*args1) print(&quot;**********************&quot;) test(*args2) 返回 这样传参可以瞬间传递自动遍历 通过解包可以使得可变位置参数和可变关键字参数传参变得灵活容易起来 可变位置参数 1234567891011def test(*args): print(f&quot;解包参数是:&#123;args&#125;&quot;) print(*args)if __name__ == &#x27;__main__&#x27;: args1 = [1, 2, 3, 4] args2 = (1, 2, 3) test(*args1) print(&quot;**********************&quot;) test(*args2) 返回 可变关键字参数 1234567def test(**kwargs): print(f&quot;解包参数是:&#123;kwargs&#125;&quot;)if __name__ == &#x27;__main__&#x27;: args = &#123;&quot;first&quot;: 1, &quot;second&quot;: 2&#125; test(**args) 返回 函数的返回值python 是弱类型语言，对返回值没有定性的要求，可以返回 None，可以不写 return 语句默认返回 None，可以有多个返回值，但是要在一个 return 语句中实现，并且这多个返回值以元组形式返回 123456789101112131415161718def test_not_return(): passdef test_return_None(): returndef test_return_single(): return 1def test_return_diff(): return 1, 2., &quot;&quot;, [], (), &#123;&#125;if __name__ == &#x27;__main__&#x27;: print(test_not_return()) print(test_return_None()) print(test_return_single()) print(test_return_diff()) 返回 以上可以看到 方法可以没有返回值，可以没有 return 语句，可以有多个不同类型返回值，多个返回值确实以元组形式返回 函数的类型普通函数普通函数属于自定义函数，满足函数规则即可。当然也可以用 types.Function 类去初始化一个函数 匿名函数python 支持匿名函数，即函数名未知地定义，使用 lambda 表达式来定义 参考链接 https://www.bilibili.com/video/BV17W4y1r7Ko/?spm_id_from=333.999.0.0&amp;vd_source=f9937d98d0a8cc08ef5248c3c127d588 匿名函数定义方式lambda [arg1 [,arg2, ... argN]] : expression 以上可以看出 lambda 表达式参数可以多个，但是只能有一个返回表达式 匿名函数的宗旨匿名函数一般用于临时使用的一种工具，它不希望被赋予一个引用。 12345678910def test_lambda(): info_ = &#123;&quot;first&quot;: 300, &quot;second&quot;: 200, &quot;third&quot;: 100&#125; print(max(info_)) print(max(info_, key=lambda x: info_[x]))if __name__ == &#x27;__main__&#x27;: test_lambda() 返回 max() 方法中的 key 需要传一个函数对象的引用，但是我们没必要额外再给引用新开一个内存空间，用临时的 lambda 表达式再好不过了 匿名函数的本质1234test = lambda x, y: x ** yprint(test.__class__)print(test)print(test(3, 2)) 返回 以上发现 lambda 表达式就是一个 function （python中具体为 types.FunctionType）类的对象 内部函数一般来说，函数内部也可以定义新的函数。那么我们称这个函数为内部函数或局部函数 内部函数的本质就是局部变量(函数就是一个变量)。在函数外部不可以直接调用（闭包机制可以打破）。内部函数在函数内部调用 12345678910111213141516171819def test1(): print(1) def test2(): print(2) def test3(): print(3) test3() def test3(): pass test2()if __name__ == &#x27;__main__&#x27;: test1() 返回 以上我们可以看出内部函数可以嵌套，因为本质是局部变量我们依旧可以在外部定义一个和内部重名的函数 高阶函数高阶函数本质也是普通函数，只不过 python 强调一切皆为对象，那么函数本身也是一个对象。怎么证明呢 12345def test(): passif __name__ == &#x27;__main__&#x27;: print(type(test)) 返回 这时会发现 test 为function类的实例对象。但是查阅资料知道 function 类引用被 del 了，只不过被一个类沿用，那就是 types 模块的 FunctionType 类 那根据参数传递的本质就是传递一个个对象，那么函数依旧可以作为对象传入方法中，其中接收函数参数的方法就被称为高阶函数 12345678910def test(x): if x &gt; 1: return True else: return Falseif __name__ == &#x27;__main__&#x27;: result = filter(test, [1, 2, 3]) print(list(result)) 返回 从上面可以分析出，filter()内置函数把 test 作为参数传入进了方法里 偏函数偏函数使用情形函数在执行时，要带上所有必要的参数进行调用。但是，有时参数可以在函数被调用之前提前获知。这种情况下，一个函数有一个或多个参数预先就能用上，以便函数能用更少的参数进行调用。 偏函数使用方法：要用到 functools 模块的 partial 方法 123456789101112from functools import partialdef test(x, y): if x &gt; y: return True else: return Falseif __name__ == &#x27;__main__&#x27;: result = partial(test, 5) print(result(100)) 返回 很明显看出，我们已知 x &#x3D; 5，的前提下，把偏函数作为一个新函数进行传参就可以得到结果。从上面看出偏函数本质也是高阶函数 回调函数由于讲了函数可以作为参数传入，那么回调函数的作用就是把自身作为参数传入到一个新函数中，利用新函数的其他参数作为自身的参数进行操作 12345678910def test1(a): print(a)def callback(function_name, b): function_name(b)if __name__ == &#x27;__main__&#x27;: callback(test1, &quot;我是回调函数&quot;) 返回 回调函数的异步处理pass 回调函数的本质原因回调函数之所以能这么使用是因为所有 函数都是 types.FunctionType 类的实例对象，而 python 提供了一个魔法方法 __call__()，这样可以使得他的对象都可以用对象名(args)进行使用。前提是一定要显示地写出来。 1234567class A: def __call__(self, name, **kwargs): print(name)if __name__ == &#x27;__main__&#x27;: test = A() test(&quot;这就是函数带括号的底层原理&quot;) 返回 以上不难看出我们的 test 对象竟然也可以写成 test()了，因为我们在 A 类里重写了 __call__() 方法，使得 test 对象可以作为函数名使用，同理这适用于回调函数语法。所以本质回调函数依旧是一种高阶函数 函数的闭包python 如果我们想对一个函数本身进行操作，那么那个操作本身也是函数。所以 python 提供函数内嵌套函数。通过这种方法我们能很好地处理不同函数的类似问题。通过闭包我们能在外部使用函数内的局部代码块了。 123456789101112131415def outer(a): a = a + 1 print(id(a)) def inner(b): print(id(a)) print(b + a) return innerinner1 = outer(a=7)inner1(b=5)inner2 = outer(a=8)inner2(b=5) 返回 由上面可以看到闭包机制一个特点是对每一次的局部变量的值可以保留在内层函数里。具体请参考 python 内存详解 装饰器python 提供的一种语法构造，由于之前分析的 闭包机制，那么我们想把一个函数对象当做参数传入到闭包机制中，那么 python 提供装饰器语法这样不用每次把原函数指向闭包后的新函数。这个闭包函数我们就称之为装饰器 装饰器的使用方法本质是将所装饰的函数对象作为参数传输到装饰器函数中去。 1234567891011121314151617181920212223import timedef calculate_runtime(method): start = time.time() method() end = time.time() print(end - start)def play_game(): for i in range(200000): pass print(&quot;游戏打完了&quot;)def shopping(): for i in range(80000): pass print(&quot;东西打完了&quot;)if __name__ == &#x27;__main__&#x27;: calculate_runtime(play_game) calculate_runtime(shopping) 返回 很明显这种方式处理函数会有局限性，因为我们只想对函数功能进行添加，当自己运行函数的时候就可以 1234567891011121314151617181920212223242526import timedef calculate_runtime(method): def run(): start = time.time() method() end = time.time() print(end - start) return rundef play_game(): for i in range(200000): pass print(&quot;游戏打完了&quot;)def shopping(): for i in range(80000): pass print(&quot;东西打完了&quot;)if __name__ == &#x27;__main__&#x27;:play_game = calculate_runtime(play_game)play_game()print(&quot;*&quot;*50)shopping = calculate_runtime(shopping)shopping() 返回 ​ 装饰器的语法糖这种方式比上一种好的是，我能直接运行原来的函数使得功能性不一样了，但是每次都用 method &#x3D; function(method) 太麻烦了。在定义函数体上方用 @装饰器名去装饰所定义的函数，我们称之为 语法糖。 1234567891011121314151617181920212223242526272829import timedef calculate_runtime(method): def run(): start = time.time() method() end = time.time() print(end - start) return run@calculate_runtimedef play_game(): for i in range(200000): pass print(&quot;游戏打完了&quot;)@calculate_runtimedef shopping(): for i in range(80000): pass print(&quot;东西打完了&quot;)if __name__ == &#x27;__main__&#x27;: play_game() print(&quot;*&quot;*50) shopping() 返回 装饰器内部的参数设置以上例子有大量的局限性：被装饰的方法没有参数。如果被装饰的方法有参数，并且参数不唯一且可变呢。那么我们直接使用我们的可变位置参数和可变强制参数来传值 12345678910111213141516171819202122import timedef calculate_runtime(method): def run(*args, **kwargs): start = time.time() method(*args, **kwargs) end = time.time() print(end - start) return run@calculate_runtimedef play_game(game, times=200000): for i in range(times): pass print(f&quot;游戏&#123;game&#125;打完了&quot;)if __name__ == &#x27;__main__&#x27;: play_game(&quot;csgo&quot;, 100000) 返回 有参装饰器我们发现装饰器虽好，但是我们需要的功能比较多的时候，需要用到外部其他变量的时候，其中内部 warpper() 和外部的 outer() 方法都不能添加其他额外的参数，因为写法已经固定了。所以我们可以通过外层嵌套另外一层函数来实现 1234567891011121314151617181920212223242526import timedef argument_(sleep_time): def calculate_runtime(method): def run(*args, **kwargs): start = time.time() method(*args, **kwargs) time.sleep(sleep_time) end = time.time() print(end - start) return run return calculate_runtime@argument_(2)def play_game(game, times=200000): for i in range(times): pass print(f&quot;游戏&#123;game&#125;打完了&quot;)if __name__ == &#x27;__main__&#x27;: play_game(&quot;csgo&quot;, 100000) 返回 以上我们不难看出通过这种方法成功实现了再次操控被装饰的函数 伪装原函数我们要想达到对原函数的完全装饰而让外部不察觉出来，我们可以通过伪装原函数进行实现。 第一个例子如下 123456789101112131415161718192021222324import timedef calculate_runtime(method): def run(*args, **kwargs): start = time.time() method(*args, **kwargs) end = time.time() print(end - start) return run@calculate_runtimedef play_game(game, times=200000): for i in range(times): pass print(f&quot;游戏&#123;game&#125;打完了&quot;) return &quot;该去吃饭了&quot;if __name__ == &#x27;__main__&#x27;: result = play_game(&quot;csgo&quot;, 100000) print(result) 返回 很明显，该函数没有返回值，这样没办法达到不改变其函数的内部性质 第二个例子 1234567891011121314151617181920212223import timedef calculate_runtime(method): def run(*args, **kwargs): start = time.time() method(*args, **kwargs) end = time.time() print(end - start) return run@calculate_runtimedef play_game(game, times=200000): for i in range(times): pass print(f&quot;游戏&#123;game&#125;打完了&quot;)if __name__ == &#x27;__main__&#x27;: print(play_game.__name__) print(play_game.__str__()) 返回 很明显，由于装饰器本质是闭包，那么使用装饰器后，函数的引用指向了内部的方法，所以很多函数的属性值会跟着变化。 以上例子说明了我们没有真正地实现不改变函数的内部属性来实现额外的功能。我们可以通过调用 functools 的 warps() 装饰器来装饰内部的函数使得原来函数的属性不改变，原理就是提前在内部拷贝一份原来函数的所有属性值。函数的返回值我们直接用一个变量来接收并返回 1234567891011121314151617181920212223242526272829import timeimport functoolsdef calculate_runtime(method): @functools.wraps(method) def run(*args, **kwargs): start = time.time() result = method(*args, **kwargs) end = time.time() print(end - start) return result return run@calculate_runtimedef play_game(game, times=200000): for i in range(times): pass print(f&quot;游戏&#123;game&#125;打完了&quot;) return &quot;该吃饭了&quot;if __name__ == &#x27;__main__&#x27;: result = play_game(&quot;cf&quot;, 30000) print(result) print(play_game.__name__) print(play_game.__str__()) 返回 装饰器模板我们发现装饰器有共同的结构，这样就形成了一个装饰器模板 1234567def outer_(*arg, **kwarg): def outer(functions): def warpper(*args, **kwargs): result = functions(*args, **kwargs) return result return warpper return outer 以上就构成了一个有参装饰器的模板了 多个装饰器装饰一个函数当多个装饰器装饰一个函数那么执行顺序是什么呢 12345678910111213141516171819202122232425262728293031323334def outer_1(*arg, **kwarg): def outer(functions): def warpper(*args, **kwargs): print(&quot;这是 outer_1 之前&quot;) result = functions(*args, **kwargs) print(&quot;这是 outer_1 之后&quot;) return result return warpper return outerdef outer_2(*arg, **kwarg): def outer(functions): def warpper(*args, **kwargs): print(&quot;这是 outer_2 之前&quot;) result = functions(*args, **kwargs) print(&quot;这是 outer_2 之后&quot;) return result return warpper return outer@outer_2()@outer_1()def test(): passif __name__ == &#x27;__main__&#x27;: test() 返回 以上我们不难看出装饰顺序是先用最靠近函数的 outer_1() 装饰器然后是 outer_2() 装饰器 通过栈的压栈和出栈可以解释以上返回值 调用 test() 本质是执行 outer_2.outer(outer_1.outer(test)) 压栈原理，程序执行到 outer_2.outer()后会先执行 print(&quot;这是 outer_2 之前&quot;) 然后碰到 funtions此时传入 outer_1.outer 进行执行 print(&quot;这是 outer_1 之前&quot;) 接着执行原函数 然后执行接着第 3 步骤的print(&quot;这是 outer_1 之后&quot;) 等 outer_1.outer()执行完毕就会得到 result 的返回值。注意这里的 result 并不是直观意义上的 outer_1.outer 这个引用，而是多重调用装饰器，内部优化成 outer_1.outer (test)()，这样 outer2.outer 里的接收的返回值其实本质就是 outer1.outer 里的 result 的值 最后再执行 outer_2 的print(&quot;这是 outer_2 之后&quot;) 装饰器的本质以上可以看到装饰器本质就是闭包，只不过参数变为了被装饰的函数。","tags":"python 函数 方法"},{"title":"python 驻留机制","url":"/2022/12/08/python/python 驻留机制/","text":"参考链接http://t.zoukankan.com/hiyong-p-14999364.html 引入原因在 Python 内存机制中，为了避免重复开辟新的内存空间造成的性能浪费，引入了一个机制叫驻留机制 内存机制有关参考 python 内存详解 定义新建的变量中，仅保存一份副本，多个对象共享该副本，驻留只针对不可变数据类型，比如字符串，布尔值，数字，元组。在这些固定数据类型处理中，使用驻留可以有效节省时间和空间，当然在驻留池中创建或者插入新的内容会消耗一定的时间。 发生环境 交互模式下会发生驻留机制 pycharm 和 python python.py 文件模式运行解释器进行了优化，返回结果并不为发生了驻留机制 在交互模式下驻留机制的几种情况字符串长度为0或1时 交互模式下 pycharm模式下 12345678def test_intern(): a = &quot;$&quot; b = &quot;$&quot; print(a is b)if __name__ == &#x27;__main__&#x27;: test_intern() 返回 命令行模式下 符合标识符的字符串(字母，数字，下划线)这意味着不符合标识的字符串不会驻留 交互模式下 pycharm 模式下 1234567891011def test_intern(): a = &quot;_hello1&quot; b = &quot;_hello1&quot; print(a is b) a = &quot;$_hello1#&quot; b = &quot;$_hello1#&quot; print(a is b)if __name__ == &#x27;__main__&#x27;: test_intern() 返回 命令行模式下 编译时会发生驻留这意味着运行不会发生驻留 python 优化了类似 str1+str2，str1*int 等生成的字符串默认驻留。前提是字面量赋值。 交互模式下 pycharm 模式下 1234567891011121314def test_intern(): a = &quot;hello&quot; b = &quot;HELLO&quot; c = b.lower() d = &quot;hel&quot; + &quot;lo&quot; print(f&quot;c:&#123;c&#125;&quot;) print(f&quot;d:&#123;d&#125;&quot;) print(&quot;-----------------&quot;) print(a is c) print(a is d)if __name__ == &#x27;__main__&#x27;: test_intern() 返回 命令行模式下 值得注意的是这次 pycharm 和命令行不再对这种情况进行优化 如果换成是变量相加的话驻留机制不会产生 123456789101112def test_intern(): a = &quot;hello&quot; b = &quot;he&quot; c = &quot;llo&quot; d = b + c print(f&quot;a:&#123;a&#125;&quot;) print(f&quot;d:&#123;d&#125;&quot;) print(&quot;-----------------&quot;) print(a is d)if __name__ == &#x27;__main__&#x27;: test_intern() 返回 数字类型区间位于 -5~256 时会进行驻留这意味着在此区间外将不会驻留 交互模式 pycharm 模式下 1234567891011121314151617def test_intern(): a = -5 b = -5 print(a is b) a = -6 b = -6 print(a is b) a = 256 b = 256 print(a is b) a = 257 b = 257 print(a is b)if __name__ == &#x27;__main__&#x27;: test_intern() 返回 命令行模式 元组类型的驻留元组类型当元组为空，或者元组中只有一个元素且元素范围满足上述字符串和数字驻留规则会驻留 由于元组不可变不存在增加元素，则不存在 运行时不驻留的特点 交互模式下 pychram 模式下 1234567891011121314151617181920212223242526272829303132333435def test_intern(): a = () b = () print(a is b) a = (-5,) b = (-5,) print(a is b) a = (256,) b = (256,) print(a is b) a = (-6,) b = (-6,) print(a is b) a = (257,) b = (257,) print(a is b) a = (&quot;%&quot;,) b = (&quot;%&quot;,) print(a is b) a = (&quot;_hello&quot;,) b = (&quot;_hello&quot;,) print(a is b) a = (&quot;#hello&quot;,) b = (&quot;#hello&quot;,) print(a is b) a = ([]) b = ([]) print(a is b) a = (1, 2) b = (1, 2) print(a is b)if __name__ == &#x27;__main__&#x27;: test_intern() 返回 命令行模式下 强制驻留 使用 sys 模块 的 intern() 方法实现强制驻留 123456789101112import sysdef test_intern(): a = &quot;#hello&quot; b = &quot;&quot;.join(&quot;#hello&quot;) print(a is b) a = sys.intern(b) print(a is b)if __name__ == &#x27;__main__&#x27;: test_intern() 返回 注意情况避免频繁的创建和销毁，提升效率和节约内存，因此拼接和修改字符串是会比较影响性能的。因为是不可变的，所以字符串的操作都不是 replace，而是新建对象，这也是为什么拼接多字符串的时候不建议用+而用 join()，join() 是先计算出所有字符串的长度，然后再拷贝，只 new 一次对象。需要注意的是，并不是所有的字符串都会采用 intern机制，当且仅当只包含下划线、数字、字母的字符串才会被 intern","tags":"python 驻留机制"},{"title":"python 循环控制 break 和 continue","url":"/2022/12/08/python/python 循环控制 break 和 continue/","text":"一般来说 break 和 continute 控制的是本层循环，不影响外层循环，如若要退出则使用 return 语句进行 12345678910def test(): for i in range(2): for j in range(6): print(f&quot;j = &#123;j&#125;&quot;) if j &gt; 2: break print(f&quot;i = &#123;i&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test() 返回 由上看出，即时 break 了，依旧不会跳过外层循环","tags":"python 循环"},{"title":"python 字符串常用方法","url":"/2022/12/08/python/python 字符串常用方法/","text":"参考链接 https://www.bilibili.com/video/BV1wD4y1o7AS?p=78&amp;vd_source=f9937d98d0a8cc08ef5248c3c127d588 其他类型常用方法具体可以参考以下文档 python 基本数据类型常用方法 查询操作 转换大小写 对齐字符串 字符串的拆分 字符串的判断 字符串的替换 比较字符串 其中 ord(str) 方法可以查看该字符的ASCII编码 12345def test(): print(ord(&quot;a&quot;)) if __name__ == &#x27;__main__&#x27;: test() 返回 格式化字符串和数字 字符串前缀r整个字符串都会被视为原生的字符串。其中的 \\ 转义将不再实现 123456789def test_str(): str_test = &quot;第一行\\n第二行&quot; print(str_test) str_test = r&quot;第一行\\n第二行&quot; print(str_test)if __name__ == &#x27;__main__&#x27;: test_str() 返回 b用来表示后面字符串是bytes 类型。网络编程中，服务器和浏览器只认bytes 类型数据 123456def test_str(): a = b&#x27;\\xe6\\xb5\\x8b\\xe8\\xaf\\x95&#x27; print(a.decode(encoding=&quot;UTF-8&quot;))if __name__ == &#x27;__main__&#x27;: test_str() 返回 u表示后面字符串采用的编码字符集为 unicode，现在内存中默认的编码格式为 unicode 在这个字符集里面所有的语言字符都可以通过特定的符号来表示。一般用在中文字符串前面，防止因为源码储存格式问题，导致再次使用时出现乱码。python3 中默认都是 unicode 编码格式 pass","tags":"python 字符串 常用方法"},{"title":"python 变量的作用域","url":"/2022/12/08/python/python 变量的作用域/","text":"参考链接 https://www.bilibili.com/video/BV1xv4y1S7ov/?spm_id_from=333.880.my_history.page.click&amp;vd_source=f9937d98d0a8cc08ef5248c3c127d588 https://www.bilibili.com/video/BV1vQ4y1D7Ct/?p=2&amp;spm_id_from=pageDriver&amp;vd_source=f9937d98d0a8cc08ef5248c3c127d588 https://www.runoob.com/python3/python3-namespace-scope.html https://blog.csdn.net/cadi2011/article/details/52457754 变量分为 内置变量，全局变量，类变量，实例变量，局部变量 python 使用变量作用域一般要遵循 LEGB（本地，上层嵌套，全局，内置） 内置变量概念和范围Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等 12345def test(): print(Exception)if __name__ == &#x27;__main__&#x27;: test() 返回 全局变量概念和范围模块内、所有方法外、所有类外。一般全局变量都不会在任何结构体内，一般位于 python 文件的最外层。可以被本模块的所有结构体给访问 12345678910111213141516171819202122global_arg = &quot;全局变量&quot;class A: @classmethod def test1(cls): print(f&quot;test1可以访问&#123;global_arg&#125;&quot;) def test2(): print(f&quot;test2可以访问&#123;global_arg&#125;&quot;) def test3(): print(f&quot;test3可以访问&#123;global_arg&#125;&quot;) test3() test2()if __name__ == &#x27;__main__&#x27;: A.test1() 返回 以上可以看出在一个类里的方法，和方法里的内部方法都可以访问最外层的 global_arg 全局变量 全局变量的声明如果是对局部变量 读 的操作，可以省去 global 关键字的声明，但是，为了区分局部变量和全局变量，建议使用全局变量都应该申明 global 123456789101112131415161718192021222324global_arg = &quot;全局变量&quot;class A: @classmethod def test1(cls): global_arg = &quot;局部变量1&quot; print(f&quot;test1可以访问&#123;global_arg&#125;&quot;) def test2(): global_arg = &quot;局部变量2&quot; print(f&quot;test2可以访问&#123;global_arg&#125;&quot;) def test3(): global_arg = &quot;局部变量3&quot; print(f&quot;test3可以访问&#123;global_arg&#125;&quot;) test3() test2()if __name__ == &#x27;__main__&#x27;: A.test1() 返回 从以上结果我们可以分析出当存在局部变量重名时优先使用的是局部变量 给全局变量声明 global 关键字 123456789101112131415161718192021222324global_arg = &quot;全局变量&quot;class A: @classmethod def test1(cls): global_arg = &quot;局部变量1&quot; print(f&quot;test1可以访问&#123;global_arg&#125;&quot;) def test2(): global global_arg print(f&quot;test2可以访问&#123;global_arg&#125;&quot;) def test3(): print(f&quot;test3可以访问&#123;global_arg&#125;&quot;) test3() test2()if __name__ == &#x27;__main__&#x27;: A.test1() 返回 通过以上信息发现，声明 global 关键字后该变量以后的所有局部作用域都会使用声明的全局变量 如果是对局部变量有操作，如赋值等的操作，一定不能 global 关键字的声明，否则会抛出 UnboundLocalError 错误 声明全局变量的好处声明全局变量的好处是避免未定义局部变量的异常，来看下面的例子 123456789101112global_arg = &quot;全局变量&quot;def test(): try: print(global_arg) global_arg = global_arg + &quot;局部变量&quot; except UnboundLocalError as u: print(u)if __name__ == &#x27;__main__&#x27;: test() 返回 global 正确使用方法即使 print(global_arg)在前，依旧无法打印出来，因为后面语句有赋值操作，解释器默认以为 global_arg 为局部变量，而又没有声明全局变量，则会抛出异常 以下为正确使用方法 1234567891011121314global_arg = &quot;全局变量&quot;def test(): global global_arg try: print(global_arg) global_arg = global_arg + &quot;局部变量&quot; except UnboundLocalError as u: print(u)if __name__ == &#x27;__main__&#x27;: test() print(global_arg) 返回 以上不难发现不会抛出异常了，并且全局变量的修改影响到了其他作用域 全局变量的其他性质全局全量还有一个性质，可以通过导包的方式给其他 python 模块使用，这使得自定义变量得以很好的跨模块使用 参考链接 https://www.byhy.net/tut/py/basic/14/ 建立两个文件一个 test_global1.py，一个为 test_global2.py 1234567891011121314# test_global1.pytest_int = 1test_list = [1, 2]def test(): global test_int, test_list test_int += 1 test_list.append(&quot;new&quot;) print(f&quot;test_global1.py中的test_int值:&#123;test_int&#125;&quot;) print(f&quot;test_global1.py中的test_int的id值:&#123;id(test_int)&#125;&quot;) print(&quot;===========================&quot;) print(f&quot;test_global1.py中的test_list值:&#123;test_list&#125;&quot;) print(f&quot;test_global1.py中的test_list的id值:&#123;id(test_list)&#125;&quot;) 1234567891011121314151617# test_global2.pyfrom test_global1 import test_int, test_list, testdef test_(): print(f&quot;test_global2.py的test_int值:&#123;test_int&#125;&quot;) print(f&quot;test_global2.py中的test_int的id值:&#123;id(test_int)&#125;&quot;) print(&quot;===========================&quot;) print(f&quot;test_global2.py中的test_list值:&#123;test_list&#125;&quot;) print(f&quot;test_global2.py中的test_list的id值:&#123;id(test_list)&#125;&quot;)if __name__ == &#x27;__main__&#x27;: test() print(&quot;*&quot;*80) test_() 我们运行 test_global2.py 的后的结果 我们发现成功导包成功了，但是这并不是通常意义的全局共享，而是 python 新开辟了命名空间，但是可变对象类型并没有开启新的内存空间，于是列表可以跟随变化。 局部变量概念和范围局部变量其实是一个狭义的概念，是相对全局变量而言的。一般我们指函数内部新定义的变量为局部变量 12345678910arg = &quot;全局变量&quot;def test(): arg = &quot;局部变量&quot; print(arg)if __name__ == &#x27;__main__&#x27;: test() print(arg) 返回 以上不难发现，即使和全局变量重名，只要没有声明是 global，则它就是局部变量 由于是局部变量，那么外部无法访问内部的局部变量，但是我们可以通过 闭包 的方式来访问内部的局部变量。 参考 python 函数详解 关于函数闭包的详解 局部变量的声明局部变量本质如果想作为内部结构的全局变量而进行修改，但是又不能用 global 修饰符，因为那会声明一个全局变量，那我们就会用到另外一个关键字 nonlocal 12345678910111213141516171819202122232425262728293031arg = &quot;全局变量&quot;def test1(): arg = &quot;局部变量1&quot; def inner_test1(): arg = &quot;内部局部变量1&quot; print(arg) inner_test1() print(arg)def test2(): arg = &quot;局部变量2&quot; def inner_test(): nonlocal arg arg = &quot;内部局部变量2&quot; print(arg) inner_test() print(arg)if __name__ == &#x27;__main__&#x27;: test1() print(&quot;********************&quot;) test2() print(&quot;********************&quot;) print(arg) 返回 从以上返回信息我们不难看出如果不加 nonlocal 关键字，那么将不会对之前外部的局部变量进行修改。而添加了 nonlocal 关键字后可以对外层的局部变量进行修改了 值得注意的是：nonlocal 属于就近原则，默认声明上一层局部变量，所以函数嵌套不宜过多。 变量字典的概念参考链接 http://c.biancheng.net/view/2259.html https://www.bilibili.com/video/BV1ia411s78e/?spm_id_from=333.999.0.0&amp;vd_source=f9937d98d0a8cc08ef5248c3c127d588 python 有两个概念 全局变量字典。该字典存储着全局变量的 key-value，这样通过字典查找快速获得全局变量。缺点是占用内存大 局部变量字典。该字典存储着局部变量的 key-value，本质是通过局部变量 list 来不断刷新着。由于这种机制，大量局部变量的查找速率会变慢，但是占用内存小 全局变量字典使用python 提供 globals() 方法可以查看全局变量字典 12345678910111213class Globals: passdef _globals(): pass_globals_ = [1]if __name__ == &#x27;__main__&#x27;: print(globals()) 以上看出，除了 __name__ 等模块的全局变量，还存在自定义的3个全局变量，分别是类 Globals，函数 _globals，变量 _globals_ 局部变量字典的使用该局部变量的本质是展示当前作用域。如果当前作用域是在全局，那么等价于全局作用域；如果在结构体中，那么一定是给出结构体中的变量字典 123456789101112131415161718192021class Globals: def __init__(self): self.number = 1 print(locals()) print(locals())def _globals(): name = &quot;Jack&quot; print(locals())_globals_ = [1]if __name__ == &#x27;__main__&#x27;: print(locals()) print(globals()) Globals() _globals() 返回 以上看出刚开始加载模块的时候，先加载类，那么加载类时会调用类里的 locals()，输出的是刚加载时的变量，其中就包括 Globals，__init__；随后加载变量完成调用全局代码块的 locals() 输出的是全局变量，接下来的 globals() 一样输出的全局代码块；再接着初始化类，构造方法只有一个局部变量那就是 self，self.number 由于是 self 的属性不属于 __init__的代码块所以只返回一个 self；最后就是调用函数返回函数里的局部变量 name 局部变量的注意事项局部变量 globals() 返回的字典一直是占用同一个内存空间，它会随着局部变量数组进行动态变化。 123456789101112def test_local(): a = 1 print(locals(), id(locals())) exec(&quot;a = 2;&quot; &quot;b = 3;&quot; &quot;print(locals(), id(locals()))&quot; ) print(a)if __name__ == &#x27;__main__&#x27;: test_local() 返回 借助 exec() 方法我们可以看到，exec() 单独开辟一个栈帧去执行代码块，那么里面的 locals() 返回的就是 exec() 开辟的代码块中的局部变量，但由于 id 相同，也说明了两者共享一个内存空间。 类变量参考类相关文档 python 类详解 概念和范围类变量本质是基于类的全局变量，但是它有独特的命名方式和访问权限 类变量作用于是在全类，通过 类名.变量名 访问或者 cls.变量名或者 self.变量名访问 1234567891011121314151617class A: class_arg = &quot;类变量&quot; def test1(self): print(A.class_arg) print(self.class_arg) @classmethod def test2(cls): print(A.class_arg) print(cls.class_arg)if __name__ == &#x27;__main__&#x27;: a = A() print(A.class_arg) a.test1() a.test2() 可以发现访问类变量的方式多种多样，单仅仅针对与该类或者它的子类或者外部用类名.变量名 的方式进行访问 类变量的命名特殊性类变量命名会影响其的作用域。 用 __ 双下划线开头，且不以 __ 双下划线结尾的变量命名方式那么我们称之为私有的类变量，然而由于 python 的机制，这种私有只是显式的私有，并不能真正的私有 参考 python 函数详解 关于类方法的命名相关信息 123456789101112131415161718192021class A: __class_arg = &quot;私有类变量&quot; def test1(self): print(A.__class_arg) print(self.__class_arg) @classmethod def test2(cls): print(A.__class_arg) print(cls.__class_arg)if __name__ == &#x27;__main__&#x27;: a = A() a.test1() a.test2() try: print(A.__class_arg__) except AttributeError as a: print(a) 返回 ​ 以上不难看出通过私有化类变量后，外部对象 A 无法访问内部私有变量 __class_arg 实例变量概念和范围实例变量一般来说当且仅当针对类而言。 实例变量一般来说作用域也是整个类，但是实例变量的针对类的对象而言的，类变量是针对类而言的，虽然类的对象可以通过类指针的方式访问类变量，但是实例对象的访问必须是 self.，即对象本身去访问 1234567891011121314class A: def __init__(self, name): self.name = nameif __name__ == &#x27;__main__&#x27;: a = A(&quot;实例变量&quot;) print(a.name) try: print(A.name) except AttributeError as at: print(at) print(A(&quot;另一个实例变量&quot;).name) 返回 从上面我们可以看到实例变量一般由类的实例对象取访问，如果类本身去访问会报 AttributeError 实例变量的特殊性对于一个类来说，实例变量一般是在构造方法中定义，因为类的初始化过程中一般要主动调用构造方法 __init__()，但是也可以在其他类的方法里构造实例方法，但不建议这么使用，因为不一定会调用其他类的方法 1234567891011121314151617class A: def __init__(self, name): self.name = name def test(self): self.age = 10if __name__ == &#x27;__main__&#x27;: a = A(&quot;实例变量&quot;) try: print(a.age) except AttributeError as at: print(at) a.test() print(a.age) 返回 以上不难发现可以在其他函数里定义实例变量，但是一定要运行了该函数才能被对象调用 总结python 一切皆为对象，那么类和函数依旧是对象，也可以作为变量传值。但是依旧会遵守上面相关的规定 参考 python 函数详解 关于高阶函数对于函数作为变量的解释 参考 python 类详解 关于类对象的解释","tags":"python 变量"},{"title":"python 基本数据类型常用方法","url":"/2022/12/07/python/python 基本数据类型常用方法/","text":"参考链接以下数据类型有些内容会涉及内存驻留机制，请参考 python 驻留机制 https://www.cnblogs.com/laizhenghua/articles/12875044.html 基本数据类型分类基本数据类型有 数字类型（int，float，complex），字符串类型（str），列表类型（list）元组（tuple），字典（dict），集合（set） 数字类型—&gt;不可变类型 pass 字符串类型—&gt;不可变类型 这代表着以下方法如若修改列表，str 的 id(str) 值会更改，与 list不同。 字符串具体操作方法请 python 字符串常用方法 字符串切片str[n] 表示正数获取字符串的元素，表示从左往右数第 n+1 个元素: 123456def test():` `test_str = &quot;junliangl&quot;` `print(test_str[3])``if __name__ == &#x27;__main__&#x27;:` `test()` 输出 str[-n] 表示负数获取字符串的元素，表示从右往左数第 n 个元素 123456def test(): test_str = &quot;junliangl&quot; print(test_str[-2])if __name__ == &#x27;__main__&#x27;: test() 输出 str[m:n] 表示从 m+1 取到第 n 的元素，不包含第 n 个元素（左闭右开原则）。如果截取不到，那么则返回空串 &quot;&quot; 12345678def test(): test_str = &quot;junliangl&quot; print(test_str[0:0]) print(test_str[0:1]) print(test_str[2:5])if __name__ == &#x27;__main__&#x27;: test() 输出 str[:n] 表示取第 1 个 到第 n 的元素，不包含第 n 个元素；str[n:] 表示取第 n+1 个 到最后一个元素 12345678def test(): test_str = &quot;junliangl&quot; print(test_str[:-2]) print(test_str[2:]) print(test_str[:-10])if __name__ == &#x27;__main__&#x27;: test() 输出 str[a : b : c] 如果 c 不写或者为正，则按照正方向截取。就代表着 a &lt; b，否则返回空串 1234567def test(): test_str = &quot;junliangl&quot; “print(test_str[2:6:]) print(test_str[6:2:3])if __name__ == &#x27;__main__&#x27;: test() 输出 如果 c 为负，则按照反方向截取。就代表着 a &gt; b ，否则返回空串 12345678def test(): test_str = &quot;junliangl&quot; print(test_str[8:4:-3]) print(test_str[-2:-7:-2]) print(test_str[-6 : -1 : -1])if __name__ == &#x27;__main__&#x27;: test() 输出 应用 str[::-1] 直接表示字符串反串 字符串其他常用方法 len() 方法求字符串长度 1234567def test(): test_str = &quot;junliangl&quot; print(len(test_str))if __name__ == &#x27;__main__&#x27;: test() 返回 lower() 与 upper() 表示字符串字母全变为小写和大写 12345678def test(): test_str = &quot;JUNliangL&quot; print(test_str.lower()) print(test_str.upper())if __name__ == &#x27;__main__&#x27;: test() 返回 startwith(str) 和 endwith(str) 表示是否以某一子串开始或结尾 1234567def test(): test_str = &quot;JUNliangL&quot; print(test_str.startswith(&quot;JUN&quot;)) print(test_str.endswith(&quot;GL&quot;))if __name__ == &#x27;__main__&#x27;: test() 输出 join(s) 方法表示以指定字符串结合 12345678def test(): test_str = &quot;----&quot; print(test_str.join(&quot;1234&quot;)) print(test_str.join([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;]))if __name__ == &#x27;__main__&#x27;: test() 输出 replace(old_str，new_str，count) 表示把 old_str 子串替换成 new_str ，count是替换数量，默认值是替换全部 1234567891011121314def test(): old_test_str = &quot;junliangl bad bad bad&quot; print(old_test_str) print(id(old_test_str)) print(&quot;----------------&quot;) new_test_str = old_test_str.replace(&quot;bad&quot;, &quot;good&quot;) print(new_test_str) print(id(new_test_str)) print(&quot;----------------&quot;) print(new_test_str.replace(&quot;good&quot;, &quot;bad&quot;, 2))if __name__ == &#x27;__main__&#x27;: test() 输出 很明显看出 replace() 方法不改变原来的字符串，创建了一个新的对象指向不同的字符串常量。 count(str，start，end) 表示计算 str 子串在原来字符串中出现的次数。start 和 end 控制返回，默认值则代表整个字符串范围 123456789def test(): test_str = &quot;junliangl bad bad bad good good&quot; print(test_str.count(&quot;bad&quot;, 9, 13)) print(test_str.count(&quot;good&quot;)) print(test_str.count(&quot;bad&quot;))if __name__ == &#x27;__main__&#x27;: test() 返回 split(str，count) 表示当前字符串以什么子串分隔，返回值为一个字符串列表 list。count 表示分隔几次，默认值是全部。没有子串则返回字符串列表 1234567891011def test(): test_str = &quot;junliangl bad bad bad good good&quot; print(test_str.split(&quot; &quot;)) test_str = &quot;junliangl,bad,bad,bad,good,good&quot; print(test_str.split(&quot;,&quot;, 2)) test_str = &quot;junliangl,bad,bad,bad,good,good&quot; print(test_str.split(&quot;.&quot;))if __name__ == &#x27;__main__&#x27;: test() 返回 strip(str) 表示当前字符串去除以 str 子串开头和结尾。默认参数则去除首尾的空白字符(空格、\\n、\\t) 1234567891011121314def test(): old_test_str = &quot;123 junliangl 123&quot; print(id(old_test_str)) print(old_test_str) print(&quot;-----------------&quot;) new_test_str = old_test_str.strip(&quot;123&quot;) print(old_test_str) print(id(new_test_str)) print(new_test_str) print(new_test_str.strip())if __name__ == &#x27;__main__&#x27;: test() 输出 很明显看出 strip() 方法不改变原来的字符串，创建了一个新的对象指向不同的字符串常量。 isdigit() 表示如果字符串只包含数字，是则返回 True，否则返回 False 123456789def test(): test1_str = &quot;junliangl 123&quot; test2_str = &quot;123&quot; print(test1_str.isdigit()) print(test2_str.isdigit())if __name__ == &#x27;__main__&#x27;: test() 返回 encode(encoding=)对字符串进行编码，encoding 填写编码格式。decode(encoding=)对字符串解码 1234567891011def test_str(): str_test = &quot;测试&quot; encode = str_test.encode(encoding=&quot;GBK&quot;) print(encode) new_str = encode.decode(encoding=&quot;GBK&quot;) print(new_str) print(b&#x27;\\xb2\\xe2\\xc6\\xd4&#x27;.decode(encoding=&quot;GBK&quot;))if __name__ == &#x27;__main__&#x27;: test_str() 返回 列表类型—&gt;可变类型 这代表着以下方法如若修改列表，列表的 id(list)值不变，与 str 类型不同 列表切片 list[n] 索引取值遵循字符串规则 12345678def test(): test_list = [&#x27;junliangl&#x27;, 1, [1, 2]] print(test_list[0]) print(test_list[-1])if __name__ == &#x27;__main__&#x27;: test() 返回 list[a:b:c] 切片类似 str 12345678910111213def test(): test_list = [&#x27;junliangl&#x27;, 1, [1, 2], &#x27;best&#x27;, &#x27;good&#x27;] print(test_list[:3]) print(test_list[3:]) print(test_list[:-3]) print(test_list[-3:]) print(test_list[1:-2]) print(test_list[1:4:1]) print(test_list[-2:-4:-1])if __name__ == &#x27;__main__&#x27;: test() 返回 len(list) 代表列表长度 1234567def test(): test_list = [&#x27;junliangl&#x27;, &#x27;best&#x27;, &#x27;good&#x27;] print(len(test_list))if __name__ == &#x27;__main__&#x27;: test() 返回 append(s) 代表往列表末尾追加一个元素 s。改变列表后，列表地址不变，以下的方法同理 12345678910def test(): test_list = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;] print(id(test_list)) test_list.append(&#x27;4&#x27;) print(id(test_list)) print(test_list)if __name__ == &#x27;__main__&#x27;: test() 返回 insert(index，obj) 表示往当前列表 index 处替换为 obj，其他元素后移。若 index &gt;&#x3D; len(list)，则在末尾处添加；若 index &lt;&#x3D; -len(list)，则在首部添加。 123456789101112131415def test(): test1_list = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;] test2_list = [1, 2, 3] test1_list.insert(-1, &#x27;4&#x27;) print(test1_list) test2_list.insert(2, 4) print(test2_list) test1_list.insert(100, &#x27;5&#x27;) print(test1_list) test2_list.insert(-100, 5) print(test2_list) if __name__ == &#x27;__main__&#x27;: test() 输出 extend(iterable) 表示往当前列表末尾添加一个序列而不是序列本身 123456789101112def test(): test1_list = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;] test2_list = [1, 2, 3] test1_list.append(test2_list) print(test1_list) test1_list = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;] test1_list.extend(test2_list) print(test1_list) if __name__ == &#x27;__main__&#x27;: test() 返回 del(list[a:b:c]) 表示删除列表选择的元素 12345678def test(): test_list = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;] del test_list[-1::-2] print(test_list)if __name__ == &#x27;__main__&#x27;: test() 返回 pop(index) 表示按照 index 删除，默认值为删除末尾的元素 12345678910def test(): test_list = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;] test_list.pop(-2) print(test_list) test_list.pop() print(test_list)if __name__ == &#x27;__main__&#x27;: test() 返回 remove(obj) 表示按照元素对象删除，默认删除寻找到的第一个元素 1234567def test(): test_list = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;1&#x27;] test_list.remove(&#x27;1&#x27;) print(test_list)if __name__ == &#x27;__main__&#x27;: test() 返回 count(obj, start, end) 统计某个元素在当前列表出现的次数 12345678def test(): test_list = [1, 2, 3, 2, 3, 3] print(test_list.count(2)) print(test_list.count(3))if __name__ == &#x27;__main__&#x27;: test() 返回 index(obj，start，end) 表示从 list[start] --- list[end] 之间的 obj 出现在 list 的第一个索引值， 找不到的话抛出 ValueError 1234567891011def test(): test_list = [1, 2, 3, 4, 5, 6] try: print(test_list.index(5, 1, 3)) except ValueError as v: print(v) print(test_list.index(4, 0, 5))if __name__ == &#x27;__main__&#x27;: test() 返回 clear() 表示清空列表中的元素 123456789def test(): test_list = [1, [1, 2], 3] test_list[1].clear() print(test_list) test_list.clear() print(test_list)if __name__ == &#x27;__main__&#x27;: test() 返回 reverse() 表示反转列表中的元素等价 list[::-1] 12345678910def test(): test_list = [1, [1, 2], 3] test_list[1].reverse() print(test_list) test_list.reverse() print(test_list)if __name__ == &#x27;__main__&#x27;: test() 返回 sort() 表示对列表进行排序，要保持类型一致，否则会报错 12345678910111213def test(): test1_list = [2, 3, 51, 10, 9] test2_list = [12, &#x27;&#x27;] test1_list.sort() print(test1_list) try: test2_list.sort() print(test2_list) except TypeError as t: print(t)if __name__ == &#x27;__main__&#x27;: test() 返回 关于 list 的拷贝参考链接 python 内存详解 关于python的列表的内存机制 赋值拷贝直接将对象(地址)赋值传递给新的对象。这样更改原来的元素都会影响赋值拷贝后的列表 123456789101112131415def test(): test1_list = [1, [1, 2], [3, 4]] test2_list = test1_list print(id(test1_list)) print(test1_list) print(&quot;---------------------&quot;) print(id(test2_list)) print(test2_list) print(&quot;---------------------&quot;) test1_list[1][0] = 10000 print(test1_list) print(test2_list)if __name__ == &#x27;__main__&#x27;: test() 返回 浅拷贝浅拷贝即未对所有层的内容进行拷贝，即其中包含赋值拷贝，即使他们的 id 值不一样。以下有几种使用方式 for循环依次赋值 123456789101112131415161718def test(): old = [1, [1, 2, 3], 3] new = [] for i in range(len(old)): new.append(old[i]) print(id(old)) print(old) print(&quot;---------------------&quot;) print(id(new)) print(new) new[0] = 3 new[1][0] = 3 print(&quot;---------------------&quot;) print(old) print(new)if __name__ == &#x27;__main__&#x27;: test() 返回 使用copy() 方法 12345678910111213141516def test(): old = [1, [1, 2, 3], 3] new = old.copy() print(id(old)) print(old) print(&quot;---------------------&quot;) print(id(new)) print(new) new[0] = 3 new[1][0] = 3 print(&quot;---------------------&quot;) print(old) print(new)if __name__ == &#x27;__main__&#x27;: test() 返回 使用切片 12345678910111213141516def test(): old = [1, [1, 2, 3], 3] new = old[:] print(id(old)) print(old) print(&quot;---------------------&quot;) print(id(new)) print(new) new[0] = 3 new[1][0] = 3 print(&quot;---------------------&quot;) print(old) print(new) if __name__ == &#x27;__main__&#x27;: test() 返回 等值传递 12345678910111213141516def test(): old = [1, [1, 2, 3], 3] new = [1, [1, 2, 3], 3] print(id(old)) print(old) print(&quot;---------------------&quot;) print(id(new)) print(new) new[0] = 3 new[1][0] = 3 print(&quot;---------------------&quot;) print(old) print(new) if __name__ == &#x27;__main__&#x27;: test() 返回 深拷贝即创建与原对象完全无关的对象。需导入 copy 模块 123456789101112131415161718import copy def test(): old = [1, [1, 2, 3], 3] new = copy.deepcopy(old) print(id(old)) print(old) print(&quot;---------------------&quot;) print(id(new)) print(new) new[0] = 3 new[1][0] = 3 print(&quot;---------------------&quot;) print(old) print(new) if __name__ == &#x27;__main__&#x27;: test() 返回 元组类型—&gt;不可变类型元组相当于不可变的列表(为 id 值 无法变，但是对于列表元组等，可以更改里面的值) 123456789101112131415def test(): test_tuple = (1, [1, 2]) print(test_tuple) try: test_tuple[0] = 2 except TypeError as t: print(t) try: test_tuple[1][1] = 10000 except TypeError as t: print(t) print(test_tuple)if __name__ == &#x27;__main__&#x27;: test() 返回 元组类型常用方法 tuple(obj) obj 只要为可迭代类型都能转换。对于 dict 类型转换只转换 key 值 12345678def test(): test1_tuple = tuple(&quot;junliangl&quot;) print(test1_tuple) test2_tuple = tuple(&#123;&quot;first&quot;: 1, &quot;second&quot;: 2&#125;) print(test2_tuple)if __name__ == &#x27;__main__&#x27;: test() 返回 tuple[a:b:c] 切片，索引。和 list 一致 pass len(tuple) 和 list 一致 pass index(obj, start, end) 和列表一致 pass count(obj, start, end)和列表一致 pass 字典类型—&gt;可变类型这代表着以下方法如若修改字典，字典的 id(dict)值不变，与 str 类型不同 参考链接 https://www.cnblogs.com/wakey/p/16246920.html https://blog.csdn.net/weixin_45228198/article/details/112771784 底层原理字典底层采用 hash表（散列表）的形式存储数据。内存形式如下 插入数据 d[“name”]&#x3D;”jack” 首先对键- -“name”计算哈希值，然后对当前C数组arr的长度求余 然后得到一个索引值，假如为5，则将当前的（哈希值，键，值）作为一个整体存入arr[5] 哈希碰撞 当插入的键，经过哈希计算，求余后若得到与之前一样的索引，比如5 因此索引处已经存有数据，无法再次存入，那么就将当前的索引+ 一个偏移量 重新计算索引位置，然后存入数据，这在python中为开放地址法 扩容（可变） 当存入的数据超过总长度的2&#x2F;3时，字典会成倍扩容，对旧数据根据新数组长度计算索引，重新存入 更新值 d[“name”]&#x3D;”tom” 首先计算键- “name”的哈希值，然后对当前数组总长度求余，得到索引，若索引对应位置的数据的键&#x3D;&#x3D;“name”，则更新它的值 删除 del d[“name”] 计算当前键- “name” 的哈希值，求余，找到索引，删除数据，仍保持探测链 标记此处有过数据 字典对比列表优缺点列表：遍历所有数据，一个一个的比较，数据量大时，时间复杂度高字典：对要查找的键，计算哈希值，求余运算得到索引，一步到位，查找效率高。内存消耗极大，属于空间换取时间 字典注意项遍历字典时添加新建可能导致字典底层数组扩容，导致散列链发生变化，因此一般不要对字典遍历的同时进行修改 具体过程如下： 键值的存储过程 首先要计算data[“name”]的散列值 得到hash值后，我们从hash值最右边3位数字作为偏离量，即0b1xxxx000111101 我们查看偏移量”101” 对应的bucket是否为空，如果为空，则将键值对放进去 如果不为空，则依次去右边3位作为偏离量，即0b1xxxx000111101 再看偏离量”111” 对应的bucket是否为空，直到找到为空的bucket将键值对放进去 字典查找值的过程 我们要计算data[“name”] 里面的”name”对象 确定偏离量，散列值的最右边3位数字作为偏离量 0b1xxxx000111101 查看偏离量”101”对应的bucket是否为空，如果为空，则返回None 如果不为空，则将这个bucket的键对象计算出对应的散列值和data[“name”]的”name”散列值进行比较，如果两个散列值相等，则将对应数组里的值对象返回，如果不相等，则再依次向前取3个【偏移量，如0b1xxxx000111101。依次取完，仍然没有找到，则返回None 字典的 key 必须是可散列的 数字类型，字符串类型，元组类型。如若是其他类型，则会报错 1234567891011def test_dict(): a = &#123;(1, 2): 1&#125; print(a) try: b = &#123;[1, 2]: 1&#125; print(b) except TypeError as t: print(t)if __name__ == &#x27;__main__&#x27;: test_dict() 返回 字典赋值dict[key] = value 123456789def test_dict(): dict_test = &#123;&#125; list_test = [[&quot;first&quot;, &quot;value1&quot;], [&quot;second&quot;, &quot;value2&quot;], [&quot;third&quot;, &quot;value3&quot;]] for i in list_test: dict_test[i[0]] = i[1] print(dict_test)if __name__ == &#x27;__main__&#x27;: test_dict() 返回 针对赋值操作，key 存在则修改，key 不存在则新增。所以字典里的 key 必须唯一 字典的常用方法 fromkeys(obj，value) 表示遍历序列 obj 作为新 dict 的 key，value 整体作为 value 12345678910def test_dict(): dict_test1 = &#123;&#125; dict_test2 = dict_test1.fromkeys((1, 2), 3) print(dict_test1) print(dict_test2) dict_test3 = dict_test1.fromkeys([&quot;first&quot;, &quot;second&quot;], [&quot;value1&quot;, &quot;value2&quot;]) print(dict_test3)if __name__ == &#x27;__main__&#x27;: test_dict() 返回 pop(key) 方法代表删除，返回被删除的 value 12345678def test_dict(): dict_test = &#123;&quot;key&quot;: &quot;value&quot;, 5: 3&#125; value = dict_test.pop(&quot;key&quot;) print(value) print(dict_test)if __name__ == &#x27;__main__&#x27;: test_dict() 返回 popitem() 后进先出原则删除字典最后添加的 key-value 对 1234567891011def test_dict(): dict_test1 = &#123;&quot;key&quot;: &quot;value&quot;, 5: 3&#125; print(dict_test1.popitem()) print(dict_test1) print(&quot;------------------&quot;) dict_test2 = &#123;5: 3, 6: 3, 2: 9&#125; print(dict_test2.popitem()) print(dict_test2)if __name__ == &#x27;__main__&#x27;: test_dict() 返回 clear() 清空字典 1234567def test_dict(): dict_test = &#123;&quot;key&quot;: &quot;value&quot;, 5: 3&#125; dict_test.clear() print(dict_test)if __name__ == &#x27;__main__&#x27;: test_dict() 返回 update(dict) 更新字典。key 重复则更新 value，没有则新增 12345678def test_dict(): dict_test = &#123;&quot;first&quot;: &quot;value1&quot;, &quot;second&quot;: &quot;value2&quot;&#125; print(dict_test) dict_test.update(&#123;&quot;first&quot;: &quot;update&quot;, &quot;third&quot;: &quot;value3&quot;&#125;) print(dict_test)if __name__ == &#x27;__main__&#x27;: test_dict() 返回 get(key，obj) 判断字典的 key 是否存在，若存在返回对应的 value，不存在则返回 obj 1234567def test_dict(): dict_test1 = &#123;&quot;first&quot;: &quot;value1&quot;, &quot;second&quot;: &quot;value2&quot;&#125; print(dict_test1.get(&quot;first&quot;, &quot;first 不存在&quot;)) print(dict_test1.get(&quot;third&quot;, &quot;third 不存在&quot;))if __name__ == &#x27;__main__&#x27;: test_dict() 返回 setdefault(key，value) 如果当前 dict 存在 key，那么返回它的 value；否则把 key-value 键值对添加进字典并返回 vaule 12345678def test_dict(): dict_test = &#123;&quot;first&quot;: &quot;value1&quot;, &quot;second&quot;: &quot;value2&quot;&#125; dict_test.setdefault(&quot;third&quot;, &quot;value3&quot;) print(dict_test.setdefault(&quot;third&quot;, &quot;setdefault&quot;)) print(dict_test)if __name__ == &#x27;__main__&#x27;: test_dict() 返回 keys() 获取 dict 的 keys。并返回该对象的生成器。这样节省了空间。如果要取值则可以自行强行转化成 list 123456789def test_dict(): dict_test1 = &#123;&quot;first&quot;: 1, &quot;second&quot;: 2&#125; keys = dict_test1.keys() print(keys) print(type(keys)) print(list(keys))if __name__ == &#x27;__main__&#x27;: test_dict() 返回 values() 获取 dict 的 values，其他同上 123456789def test_dict(): dict_test1 = &#123;&quot;first&quot;: 1, &quot;second&quot;: 2&#125; values = dict_test1.values() print(values) print(type(values)) print(list(values))if __name__ == &#x27;__main__&#x27;: test_dict() 返回 items()获取了dict 的 keys 和values 元组对，其他同上 123456789def test_dict(): dict_test = &#123;&quot;first&quot;: 1, &quot;second&quot;: 2&#125; items = dict_test.items() print(items) print(type(items)) print(list(items))if __name__ == &#x27;__main__&#x27;: test_dict() 返回 集合类型—&gt;可变类型这代表着以下方法如若修改字典，字典的 id(dict)值不变，与 str 类型不同 条件集合元素满足 必须是可散列的 数字，字符串，元组 底层原理依旧采用 hash 表进行存储 创建空集合 set() 不能采用 &#123;&#125;，系统默认为 dict 类型 1234567891011def test_set(): set_test = set() dict_test = &#123;&#125; print(set_test) print(type(set_test)) print(&quot;-----------------&quot;) print(dict_test) print(type(dict_test))if __name__ == &#x27;__main__&#x27;: test_set() 返回 如若不是空集合，则可以采用 &#123;values&#125; 方式创建 1234567def test_set(): set_test = &#123;1, 2&#125; print(set_test) print(type(set_test))if __name__ == &#x27;__main__&#x27;: test_set() 返回 由于集合内元素要参与 hash(values) 运算，所以得是不可变类型 123456789def test_set(): try: set_test = &#123;1, [1, 2]&#125; print(set_test) except TypeError as t: print(t)if __name__ == &#x27;__main__&#x27;: test_set() 返回 集合常用方法 交集 set1 &amp; set2 123456789def test_set(): set1 = &#123;1, 2, 3&#125; set2 = &#123;2, 3, 4&#125; set3 = &#123;6, 7, 8&#125; print(set1 &amp; set2) print(set2 &amp; set3)if __name__ == &#x27;__main__&#x27;: test_set() 返回 并集 set1 | set2 12345678def test_set(): set1 = &#123;1, 2, 3&#125; set2 = &#123;2, 3, 4&#125; print(set1 | set2)if __name__ == &#x27;__main__&#x27;: test_set() 返回 差集 set1 - set2 1234567def test_set(): set1 = &#123;1, 2, 3&#125; set2 = &#123;2, 3, 4&#125; print(set1 - set2)if __name__ == &#x27;__main__&#x27;: test_set() 返回 discard(value) 删除集合中 value 元素，找不到不会抛出异常 12345678def test_set(): set_test = &#123;1, 2, 3&#125; set_test.discard(1) print(set_test) set_test.discard(1)if __name__ == &#x27;__main__&#x27;: test_set() 返回 remove(values) 删除 value 。找不到则报错 123456789101112def test_set(): set_test = &#123;1, 2, 3&#125; set_test.remove(2) print(set_test) try: set_test.remove(2) except KeyError as k: print(k)if __name__ == &#x27;__main__&#x27;: test_set() 返回 update(obj) 遍历序列 obj 更新集合 。序列一定是可哈希的，否则报错。 123456789101112def test_set(): set_test = &#123;1, 2, 3&#125; set_test.update([1, 2, 4]) print(set_test) try: set_test.update([2, 3, [1, 2]]) except TypeError as t: print(t)if __name__ == &#x27;__main__&#x27;: test_set() 返回 pop() 随机删除一个元素。通常是展现出的删除第一个元素 12345678def test_set(): set_test1 = &#123;1, 2, 3&#125; set_test1.pop() print(set_test1)if __name__ == &#x27;__main__&#x27;: test_set() 返回 add(value) 往集合中增加一个元素 123456789101112def test_set(): set_test1 = &#123;1, 2, 3&#125; set_test1.add(4) print(set_test1) try: set_test1.add([]) except TypeError as t: print(t)if __name__ == &#x27;__main__&#x27;: test_set() 返回 clear() 清空集合 12345678def test_set(): set_test = &#123;&quot;&quot;, 1, ()&#125; set_test.clear() print(set_test)if __name__ == &#x27;__main__&#x27;: test_set() 返回","tags":"python 常用方法 基本数据类型"},{"title":"python 运算符","url":"/2022/12/05/python/python 运算符/","text":"运算符的分类python 运算符分为 算术运算符、赋值运算符、比较运算符、布尔运算符、位运算符 算术运算符算术运算符分为 标准运算符、取余运算符、幂运算符 算术运算符满足以下规则 标准运算符 + - * / // 整除运算符其中/为整除运算符，若两者异号，则向下取整 12345678def test(): value1 = 20/-3 value2 = 20//-3 print(value1) print(value2)if __name__ == &#x27;__main__&#x27;: test() 返回 取余运算符% 为取余运算符。规则是同号则直接取余数。异号余数 &#x3D; 被除数 - 除数*商 其中以上的 商 为两者整除而来 如 -20%3的商为 -20&#x2F;&#x2F;3 12345678910def test(): value1 = -20%-3 value2 = -20%3 value3 = 20%-3 print(value1) print(value2) print(value3)if __name__ == &#x27;__main__&#x27;: test() 返回 幂运算符**为幂运算符，a**b 表示 a 的 b 次 幂 12345678def test(): value1 = -2**3 value2 = -2**-2 print(value1) print(value2)if __name__ == &#x27;__main__&#x27;: test() 返回 赋值运算符&#x3D; 即为赋值运算符。 执行顺序为 从右往左 a&#x3D;b&#x3D;c&#x3D;1 支持参数赋值 a +&#x3D; b，a &#x2F;&#x2F;&#x3D; b ….. 支持系列解包赋值 a，b &#x3D; b， a，常用于交换两者的值 12345678910def test(): value1 = 1 value2 = 2 value1, value2 = value2, value1 print(value1) print(value2) if __name__ == &#x27;__main__&#x27;: test() 返回 比较运算符 &gt;，&lt;， &gt;&#x3D;，&lt;&#x3D;，!&#x3D;，&#x3D;&#x3D; 返回值为 bool 类型，比较的是两者的 _value 值 is ，is not。is 代表 是 id 相等，is not 代表 id 不相等 返回值为 bool 类型，比较的是两者的 id 值 12345678910111213141516def test(): value1 = 1 value2 = 2 print(value1 == value2) print(&quot;-----------------------&quot;) value3 = [1, [1, 2]] value4 = [1, [1, 2]] value5 = value3 print(id(value3), id(value4), id(value5)) print(&quot;-----------------------&quot;) print(value3 is value4) print(value3 is not value5) print(value4 is not value5)if __name__ == &#x27;__main__&#x27;: test() 返回 bool 运算符python 一切对象都有对应的 bool 值 and ，or，not，in，not in （其中 in， not in 表示是否在序列中） 其中 and 和 or 拥有短路性。即 a and b a为false，b不再进行。同理 a or b，a为真 b不再进行 123456789101112131415161718192021m = [1, 2, 3]def test1(): m.clear() print(m) return Truedef test2(): m.append(1) print(m) return Falsedef test_bool(): a = True b = False print(b and test1()) print(a or test2())if __name__ == &#x27;__main__&#x27;: test_bool() 返回 注意 a and b 其中 a，b不一定是bool 类型。a and b 返回值也不一定是 bool 类型 123456789def test(): print(None and 5) print(1 and &#x27;hello&#x27;) print(None or None) print(&quot;hello&quot; or None)if __name__ == &#x27;__main__&#x27;: test() 返回 实际中不确定 a，b 类型情况下想返回 bool 类型建议 bool(a) and bool(b) 这样能确定100%返回 bool 类型 位运算符&amp; 按位与。| 按位或。&gt;&gt; 按位右移。&lt;&lt;按位左移。^为异或。~为按位取反 以下为运算规则 123456789def test(): print(3 &amp; 6) print(3 | 6) print(3 &gt;&gt; 2) print(3 &lt;&lt; 1)if __name__ == &#x27;__main__&#x27;: test() 返回 注意，参与运算要按照补码进行计算 原码，反码，补码规则如下 正数 原码，反码，补码相同。符号位都为0 负数 原码符号位为1.反码是符号位不变，其余按位取反。补码是反码 + 1 根据以上规则我们可以计算出负数的 按位与 和 按位或 123456789def test(): print(-3 &amp; -6) print(-3 | -6) print(-3 &gt;&gt; 1) print(-3 &lt;&lt; 1)if __name__ == &#x27;__main__&#x27;: test() 返回 验算 同理可以算出其他值。 注意移位运算符符号位补位为当前符号。即符号位永远保持同号 ~ 按位取反值得注意的是按位取反符号位要参与 1234567def test(): print(~-3) print(~5)if __name__ == &#x27;__main__&#x27;: test() 返回 ^异或即A^B &#x3D; （A and !B）or (!A and B) 123456def test(): print(5 ^ -2)if __name__ == &#x27;__main__&#x27;: test() 返回 异或可以不借助第三方参数进行交换值 1234567891011def exchange(a, b): print(a, b) print(&quot;-----------------&quot;) a = a ^ b b = a ^ b a = a ^ b print(a, b)if __name__ == &#x27;__main__&#x27;: exchange(6, 5) 返回 证明 运算符优先级运算符优先级参考如下： python3 官方参考","tags":"python 运算符"},{"title":"Python pytest 模块单元测试","url":"/2022/12/05/python/pytest/","text":"pytest 准备工作准备 requirements.txt 写入以下插件和包， 123456`pytest``pytest-html``pytest-xdist``pytest-ordering``pytest-rerunfailures``allure-pytest` 安装插件 pip install -r requirements.txt 编写一个简单的测试脚本 test.py 1234567import pytestclass TestCase: def test_number(self): assert True is False 运行 pytest pytest -vs test.py 运行结果如下 pytest 使用方法运行python test.py 脚本下 写入 main 方法调用 pytest.main() 去执行 12if __name__ == &#x27;__main__&#x27;: pytest.main([&#x27;-s&#x27;, &#x27;./test_number.py&#x27;]) 终端模式下也可以通过 pytest 命令执行 pytest -vs test.py 参数默认不加参数即运行 12if __name__ == &#x27;__main__&#x27;: pytest.main() pytest test.py 以上默认运行以下测试用例 名字带有 test 开头或 test 结尾的 python 模块 名字以 Test 开头且不能含有 init 方法的类 名字以 test 开头的方法 常用的参数解释-s 打印输出调试信息 -v 输出更详细的信息 -n number (输入几个线程) 多线程或分布式运行 --reruns number (输入重跑次数) 运行用例失败重跑 -x 只要一个用例失败那么停止测试 --maxfail=number 出现 number 次用例失败就停止测试 -k string 根据测试用例的部分字符串(string)指定 -rA 测试结果的简单统计 -m 指定被 pytest.mark 标记过的方法 编辑配置文件编辑 pytest.ini 配置文件达到命令行运行的效果。配置好后 只需要 pytest 即可一键运行 系统根目录下创建 pytest.ini 配置文件 touch pytest.ini 修改该文件编码格式为 ANSI 格式，创建好需要更改编码格式 作用 改变 pytest 的默认行为，无需命令行输出冗余命令 运行规则 pytest 自动读取 pytest.ini 配置文件并按照配置文件规则执行 一些具体参数如下 pytest.ini 12345678910111213`[pytest]``#encoding = ANSI``#命令行参数，用空格分隔``addopts = -vs` `#测试用例的文件路径``testpaths = .``#配置测试搜素的 python 文件名称``python_files = test*.py#配置测试搜索的测试类名python_classes = Test*``#配置测试搜索的测试函数名``python_functions = test*` 常用的装饰器有时候我们希望某个方法有专门的作用和不同的作用那么就可以采用 pytest装饰器修饰 @pytest.mark.yourname 用该装饰器装饰的方法可以用 pytest -m &quot;yourname&quot;进行操作 多个被 mark 过的方法 可以使用逻辑运算符and or not进行连接 如 pytest -m &quot;first or second&quot; 表示 first 方法 和 second 方法都被执行 @pytest.mark.skip(reason=yourreasons) 用该装饰器装饰的方法会被 pytest 无条件跳过 @pytest.mark.skipif(condition=yourcondition, reason=yourreasons) 用该装饰器装饰的方法会被 pytest 判定:如果 condition 表达式为 True，则跳过该测试，反之则不跳过 @pytest.mark.run(order=number) 用该装饰器装饰的方法会被 pytest 识别并依照 number 的值的顺序跑测试用例 @pytest.fixture(scope=scope, params=params, autouse=bool, ids=ids, name=name) 用fixtrue标记的方法一般用于前置和后置处理，类似 setup &amp; teardown 的功能 其中 scope 参数有以下四个值: “function” 代表着作用于 方法 “class” 代表着作用于 类 “modules” 代表着作用于一个 python 文件 “sessions” 代表着作用于整个 pytest 测试流程 其中 autouse 参数有 True 和 False 两个 bool 值 如果 autouse&#x3D;True，那么默认测试用例方法都会执行fixture，前提是在自己的scope里 1234567891011121314@pytest.fixture(scope=&quot;function&quot;, autouse=True, params=[(&quot;这是&quot;, &quot;first&quot;), (&quot;这是&quot;, &quot;second&quot;)])def sayhello(request): print(&quot;测试开始&quot;) yield request.param print(&quot;测试结束&quot;)class TestCase: @pytest.mark.run(order=3) # @pytest.mark.first def test_number(self): pass 如果 autouse&#x3D;Flase，那么测试用例方法参数需要添加 fixture 修饰的方法名字 123456789101112131415@pytest.fixture(scope=&quot;function&quot;, autouse=False, params=[(&quot;这是&quot;, &quot;first&quot;), (&quot;这是&quot;, &quot;second&quot;)])def sayhello(request): print(&quot;测试开始&quot;) yield request.param print(&quot;测试结束&quot;)class TestCase: @pytest.mark.run(order=3) # @pytest.mark.first def test_number(self, sayhello): pass params 参数控制着传参 params=[(&quot;这是&quot;, &quot;first&quot;), (&quot;这是&quot;, &quot;second&quot;)] 其中 params 可以等于一个 列表或字典，或者 字典列表与元祖列表 如果要获得 params 的参数，则fxiture修饰的方法需要添加固定的 request 参数，且返回request.param 用于测试方法接受 如果测试方法要接收 params 参数，即时autouse&#x3D;True，也要在测试方法参数上添加需要的fixture方法名 未加方法名结果 添加方法名结果 借助python yeild 生成器控制前置和后置输出 123456@pytest.fixture(scope=&quot;function&quot;, autouse=True, params=[(&quot;这是&quot;, &quot;first&quot;), (&quot;这是&quot;, &quot;second&quot;)])def sayhello(request): print(&quot;测试开始&quot;) yield request.param print(&quot;测试结束&quot;) 实际使用情况 一般情况下 pytest 有一个机制:即把 fixture 集中放入一个名叫 conftest.py 的文件下，pytest会自动识别该文件并作出相应的响应作用域 该文件可以存放在任何目录下且只对当前目录及当前路径以下的目录下起作用 @pytest.mark.parametrize(argsname，argsvalues) 用该装饰器修饰的方法可以进行参数化 argsname 代表着参数名，argsvalues代表参数值 12345678import pytestclass TestCase2:​ @pytest.mark.parametrize(argnames=&quot;a&quot;, argvalues=[&quot;FIRST&quot;, &quot;SECOND&quot;])​ def test_number(self, a: list):​ print(a) 结果","tags":"python pytest 测试工具"},{"title":"docker","url":"/2022/12/05/linux/docker/","text":"docker详解","tags":"continer"},{"title":"测试用例设计方法","url":"/2022/12/05/测试/测试用例设计方法/","text":"测试用例的分类分为黑盒测试和白盒测试两种 黑盒测试 白盒测试 设计测试用例的方法等价类划分法（简称等价类）等价类划分法的定义将输入（输出）域划分成若干个子集合中，从划分的子集合中选取代表数据进行测试，如果选取的数据测试没有问题，就认为其他数据测试的效果是等价的 等价类划分法的分类有效等价类 无效等价类 等价类划分原则 如果输入（输出）是一个取值范围或者某个值的个数时，则划分成一个有效等价类和两个无效等价类 举例 某个大厦招聘保安，年龄要求18~60周岁（包括18和60） 一个有效等价类：18~60 两个无效等价类：&lt;18；&gt;60 并且从以上区间选取带有标志性的数据测试 如有效等价类区间里选取 18 60 50…..，无效等价类里选取 10 70 80 ….. 如果输入（输出）是一个有限集合或者必须如何的条件，则划分成一个有效等价类和一个无效等价类 举例 一个集合：以下城市进入上海需要提供核酸检测报告（沈阳；大连；深圳；广州；合肥；六安；营口；瑞丽） 一个有效等价类：集合内； 一个无效等价类：集合外（菏泽） 并且从以上区间选取带有标志性的数据测试 如有效等价类选取大连……，无效等价类选取 菏泽…… 如果输入（输出）是一个布尔量，则划分成一个有效等价类和一个无效等价类 举例 某个问卷调查 App 如果性别选项选择男请转到第五题： 一个有效：男 一个无效：女 如果性别选项选择女请转到第二题： 一个有效：女 一个无效：男 很明显布尔类型是第二种等价类的特殊情况 如果输入（输出）已经划分出有效和无效等价类，针对有效等价类部分不同的取值处理方式不一样，细分成多个有效等价类和一个无效等价类 举例 某个认证考试百分制；60分及格可以获得认证证书 一个有效等价类：&gt;&#x3D;60分 细化等价类： 6069分—合格；7079分—中等；8089分—良好；9099分—优秀；100分—完美 一个无效等价类：&lt;60分 如果输入（输出）要同时满足多个条件，则划分成一个有效等价类和多个无效等价类 举例 学习系统登录密码修改：6~12位； 一个有效等价类：大小写字母与数字的组合满足所有要求 多个无效等价类：少于6位；大于12位；缺少数字；缺少小写字母；缺少大写字母；含有其他字母 很明显从以上看出当有限集合数量过于庞大时，我们不采用第二种等价类划分法，采用当前的划分方法 等价类划分法使用步骤 分析需求 将软件需求规格说明书划分成需求子片段 分析需求子片段，找出输入条件 分析输入条件，判定是否需要结合等价类划分原则划分等价，需要则继续 为了防止测试遗漏，为划分的等价类进行编号 从划分的等价类中选取代表数据进行测试，直到所有的等价类全部被覆盖 将选取的数据结合测试用例写作格式完成最终测试用例的编写 等价类的注意事项 一条测试用例尽量覆盖多个有效等价类； 一条测试用例只覆盖一个无效等价类； 这符合之前等价类设计方法的最后一条，因为实际输入要么是庞大的集合，要么是无穷的区间。总之应该以有效等价类覆盖越多越好 边界值对于等价类划分法的问题是等价类划分法追求有效等价类覆盖率和数量，然而拥有无穷数的区间却使用一个等价类设计思路，这显然和宗旨相悖。基于以上问题，那么边界值设计方法可以对以上问题进行补充 边界值的三个重要的参数 上点：区间边界的点 离点：离区间边界点最近的点 如果是开区间离点落在区间内，如果是闭区间离点落在区间外 即离点不能落在区间里 内点：落在区间内任意的点 举例 某个大厦招聘保安，年龄要求[18，60]周岁 上点：18；60 离点：17；61 内点：30 边界值的选取原则 如果输入（输出）是一个取值范围时，则以边界和边界附近的值作为测试用例数据优先选取 这就是对等价类不足的设计手段，因为等价类不能精确地锁定哪些数据需要拿来测试。 如果输入（输出）是一个有序的集合，则以第一个元素和最后一个元素作为测试用例 这个是基于对第二种等价类划分原则进行补充。 如果输入（输出）的值的个数是个取值范围，则以最大个数、最大个数+1、最小个数、最小个数-1作为测试用例数据优先选取； 这个是对以上两条内容的补充 边界值的使用步骤 分析需求 将软件需求规格说明书划分成需求子片段 分析需求子片段，找出输入条件 分析输入条件，判定是否需要边界值法，如果需要结合等价类划分原则划分等价类 很明显，边界值划分法是基于等价类划分法的补充，一定要优先择取等价类划分，根据划分情况选择合适的数据 判断是否需要边界值和需要哪种边界值方法 分析等价类，是否需要边界值补充 结合边界值数据选取原则确定边界值的选取 将选取的数据结合测试用例写作格式完成最终测试用例的编写 等价类和边界值适用范围 特点：不测试各种组合。测试效率比较高，效果一般。比较容易理解和易于使用的一种方法 适用范围：功能测试；性能测试；界面测试（GUI测试）；兼容测试 注意接口测试一般不选取等价类划分法去测试，一般功能测试可以使用等价类划分法 判定表分析和表达多种输入条件下完成不同动作的一种工具，这种方法能够将具有复杂逻辑关系和多种条件组合的情况表达清晰。 很显然，判定表是针对有限布尔集合或者输入是处于多个有限集合而言的。而一般功能的输出的集合一般只有一两个元素，然后由于有 switch-case 这种情况的出现，我们就可以考虑由判定表方法完成 判定表的四个重要参数 条件桩：输入条件 表示输入取值的集合 条件项：输入条件的取值 表示具体输入的集合元素 动作桩：输出结果 表示输出的取值集合 动作项：输出结果的取值 表示具体输出的集合元素 判定表的使用步骤 分析需求 将软件需求规格说明书划分成需求子片段； 分析输入条件，判定是否需要判定表设计方法，如果需要则继续 找出条件桩、条件项、动作桩、动作项； 将条件项进行组合，确定测试组合数量（条件项的个数相乘），得出测试规则； 分析生成的规则，对相似规则进行合并化简（合并有风险，化简需谨慎—对软件系统内部的逻辑结构非常了解；资源有限）； 分析每条生成的规则，必要时结合等价类边界值生成最终的测试用例。 判定表的适用范围从以上分析我们不难发现，判定表只使用输入输出为一个少元素或者布尔值的集合，因为如果输入输出量太大，那么根据组合数原理，测试用例量将会特别多影响测试效率。 所以适合功能测试，如修改密码成功与否，登录成功与否，下单成功与否。 判定表的特点 条件桩的顺序对生成规则没有影响 动作桩的顺序对生成的规则没有影响 每条规则都是独立的相互之间没有影响 判定表的写法 以上不难分析出理论上有 2**条件项的测试用例产生。 因果图因果图属于对判定表的一种补充。如果边界值法是对等价类划分法无穷转化为有穷的补充，那么因果图就是对判定表复杂的逻辑输入输出到简化的逻辑输入输出的补充 因果图的三个重要参数因果图顾名思义为 因—果 键值对，那么它有三个重要参数 原因 : C（course） 结果: R（result） 中间项：当多个原因之间不是单纯的与和或的关系，可以利用中间节点存取中间结果，使得因果图更加清晰 因果图的因果关系 逻辑关系 恒等 与 或 非 制约关系 互斥 Exclusive 有多个输入(原因)，至多只能有一个为真，不可以同时都为真，可以同时都为假 包容 Inclusive 有多个输入(原因)，至少有一个为真，可以同时都为真，不可以同时都为假 唯一 Only 有多个输入(原因)，有且只能有一个为真，不可以同时都为真，不可以同时都为假 要求 Require 有两个输入(原因)，A为真，B为真；A为假，B不做要求 强制 Mandatory 有两个输入(原因)，A为真，B为假；A为假，B不做要求 因果图的使用步骤 分析需求 将软件需求规格说明书划分成需求子片段； 分析输入输出，判定是否需要判定表设计方法，如果需要则是否需要借助因果图，如果需要则继续 分析原因和结果之间的关系，画出因果图 分析原因之间是否存在制约关系，做出标识 根据有因果图生成判定表 分析判定表，进行合并和化简 必要时结合等价类、边界值生成最终的测试用例 因果图画法 正交表正交表起源于伽罗瓦的数学理论。因为输入的是一组有限集合，那么多组输入可以简化。所以正交表是对判定表和因果测试用例数的简化 正交表的使用步骤 需求分析 将软件需求规格说明书划分成需求子片段 分析输入输出，看是否需要用到判定表和因果图，如果需要：找出因子和状态，构造一张因子状态表 使用正交表工具 allpairs 进行输出测试用例 正交表工具使用方法参考 正交表工具使用方法 必要时可以结合等价类边界值生成最终的测试用例 正交表的特点和适用范围很明显正交表极大地简化了判定表的测试用例量，所以基本判定表都会使用正交表。特别适合做兼容性测试，表单，配置测试等 状态迁移图在给定的条件下状态能够正确的跳转以及是否有非法转移和未可达的状态 状态迁移图的关键词 有限状态机 拥有有限个数量的状态，每个状态可以迁移到零个或多个状态 状态 某一时刻的表现 跳转条件 输入（使得状态发生变化的操作） 迁移 状态变化的过程 状态迁移图的使用步骤 将软件需求规格说明书划分成需求子片段 分析需求子片段，找出状态和条状条件 假定一个初始状态，以圆圈（代表状态）为节点以箭线（输入）为跳转条件画出状态迁移图 根据状态迁移图得出状态事件转换表（第一列代表上一状态；第二列代表跳转条件；第三列代表下一状态；第四列代表输出结果） 通过状态转换事件表得出状态转换树（矩形框代表状态） 通过状态转换树找出测试路径 添加一些非法测试 必要时可以结合等价类和边界值进行测试 场景测试法 pass","tags":"测试用例 测试用例设计"},{"title":"正交表工具使用方法","url":"/2022/12/05/测试/正交表工具使用方法/","text":"参考链接 https://blog.csdn.net/qq_54444533/article/details/124828947 官方网站 https://www.satisfice.com/download/allpairs 使用步骤 下载后解压 将该目录添加至环境变量 PATH 输入 allpairs 命令显示以上则安装成功 使用方法 第一步 对需要正交表的条件项目依次填入 csv 中，格式如下 第二步 复制全部内容到 txt 文档 注意不要在意 txt 文档格式混乱，allpairs 会自动识别。并且最后一行不能有换行符。否则会报错 第三步 用如下命令 allpiars 测试数据.txt &gt; 你需要生成的testcase.xlsx 表格中 最后查看结果 注意点 表格下方是所有笛卡尔积结果。上方才是需要测试的数据 其中前缀为~的项表示无关数据，可以任意取值","tags":"测试工具"},{"title":"软件质量模型","url":"/2022/12/05/测试/软件质量模型/","text":"参考链接 https://cloud.tencent.com/developer/article/1457805 官方软件质量模型是现在 ISO&#x2F;IEC25010:2011 或 ISO&#x2F;IEC9126 发布的软件质量保证的模型 它可以用官方的解释来判断一个软件质量的好坏与否 质量模型质量模型涉及6大特性和27个子特性 功能性定义 软件产品提供明确、隐含要求的能力 2.适合性 软件产品为指定的任务和用户提供一组合适的功能的能力（投入运行后，功能是否合适、正确、完整等） 3.准确性 软件产品提供具有所需精度的正确或相符的结果或效果的能力（实际与预期的差别） 4.互操作性 软件产品与一个或更多的规定系统进行交互的能力（如果与其它软件有定义接口，数据传输的正确程度） 安全保密性 软件产品保护信息和数据的能力，使未授权的人不能阅读或修改这些信息和数据，而不拒绝授权人员阅读或修改这些信息和数据(访问的可审核性（正常、病毒）、可控制性） 6.功能性的依从性 软件产品遵循与功能性相关的标准、约定或法规及类似规定的能力（非法） 可靠性 在指定条件下使用时，软件产品维持规定的性能级别的能力 成熟性 软件产品为避免由软件内部的故障而导致失效的能力（潜在的故障密度、失效的测试用例数量、故障排除） 容错性 在软件出现故障或者违反其指定接口的情况下，软件产品维持规定的性能级别的能力 易恢复性 在失效发生的情况下，软件产品重建规定的性能级别并恢复受直接影响的数据的能力（重启能力、重启时间） 可靠性的依从性 软件产品遵循与可靠性相关的标准、约定或法规的能力（非法） 易用性 在指定条件下使用时，软件产品被理解、学习、使用和在指定条件下使用时，软件产品被理解、学习、使用和吸引用户的能力 易理解性 软件产品使用户能理解软件是否合适以及如何能将软件用于特定的任务和使用条件的能力（文档、功能的初始印象） 易学性 软件产品使用户能学会其应用的能力（使用者学习满足需求的能力） 易操作性 软件产品使用户能操作和控制它的能力 吸引性 软件产品吸引用户的能力 易用性的依从性 软件产品遵循与易用性相关的标准、约定、风格指南或法规的能力（非法） 效率 在规定条件下，相对于所用资源的数量，软件产品可提在规定条件下，相对于所用资源的数量，软件产品可提供适当性能的能力 时间特性 在规定条件下，软件产品执行其功能时，提供适当的响应和处理时间以及吞吐率的能力（如响应时间） 资源利用性 在规定条件下，软件产品执行其功能时，使用合适数量和类别的资源的能力（如内存占用） 效率依从性 软件产品遵循与效率相关的标准或约定的能力（非法） 可维护性 软件产品可被修改的能力。修改可能包括修正、改进或软件对环境、需求和功能规格说明变化的适应 易分析性 软件产品诊断软件中的缺陷或失效原因或识别待修改部分的能力。 易改变性 软件产品使指定的修改可以被实现的能力（变更难易的程度） 稳定性 软件产品避免由于软件修改而造成意外结果的能力（由于软件修改而造成的意外） 易测试性 软件产品修改能被确认的能力 维护性的依从性 软件产品遵循与维护性相关的标准或约定的能力（非法） 可移植性 软件产品从一种环境迁移到另一种环境的能力 适应性 软件产品毋需采用额外的活动或手段就可适应不同指定环境的能力（屏幕大小） 易安装性 软件产品在指定环境中被安装的能力（用户在指定环境中被安装的能力，与易操作性互相影响） 共存性 软件产品在公共环境中同与其分享公共资源的其他独立软件共存的能力（共享资源的其它软件） 易替换性 软件产品在同样环境下，替代另一个相同用途的软件产品的能力（版本迭代、新旧兼容） 可移植性的依从性 软件产品遵循与可移植性相关的标准或约定的能力（非法） 软件的使用质量模型基于用户观点的软件产品用于指定的环境和使用周境时的质量。它测量用户在特定环境中能达到其目标的程度，而不是测量软件自身的属性。 基本的软件使用质量模型包括4大特性","tags":"质量模型"},{"title":"软件开发模型（SDLC)","url":"/2022/12/05/测试/软件开发模型（SDLC)/","text":"参考链接 https://cloud.tencent.com/developer/article/1724043 常用的开发模型 瀑布模型 V型 迭代和增量模型 螺旋模型 大爆炸模型 敏捷模型 原型模型 DevOps 瀑布模型 瀑布模型的特点瀑布模型（Waterfall） 是最简单的软件开发历史上第一个 SDLC 模型。在瀑布模型中，开发过程是线性的。任务和阶段按严格顺序一个接一个地完成。进度平稳地向下流动，就像瀑布上的水一样。 瀑布模型的缺点瀑布模型的主要缺点是不灵活。瀑布易于理解且易于管理。但是过早的延迟会拖延整个项目的时间表。由于一旦完成阶段，几乎没有修改的余地，因此只有进入维护阶段才能解决问题。如果需要灵活性，或者项目是长期的且正在进行的，则此模型不能很好地工作 V 型 V 形模型也称为 V 模型或验证与验证模型，是瀑布方法的扩展。使用 V 模型时，进度并不会直线移动，而是在实施和开发后逐渐上升。 对于 V 型 SDLC 项目，早期测试介入是与 瀑布模型相比的主要区别。每个开发阶段都有一个并行测试阶段，这有助于在继续下一步之前验证和验证每个步骤。 迭代和增量模型 迭代和增量 SDLC 模型将迭代设计和工作流与增量构建模型结合在一起。在这种情况下，团队将按周期开发产品，并以渐进方式构建小零件。 开发过程从简单实施一组严格限制的小型产品需求开始。然后对该产品进行增强，并使其本身成为更完整的版本，直到完成并准备好进行部署为止。每次迭代都可能包含设计更新和新功能。 迭代和增量模型的一个有价值的特点是可以在不知道所有需求的情况下开始开发。该模型包含其他 SDLC 模型的步骤-需求收集，设计，实施和测试，但要经过多次构建。开发团队可以利用先前构建中取得的成就来改善下一构建。 迭代和增量 SDLC 模型可能看起来像一组微型瀑布模型或微型 V 形模型。 螺旋模型 螺旋 SDLC 模型是原型方法和瀑布方法的结合。螺旋模型被认为是最灵活的 SDLC 方法之一。它从迭代模型及其重复中获得启发。该项目以“螺旋式”的方式反复经历四个阶段，直到完成为止，从而可以进行多轮改进。 规划 风险分析 工程 评价 螺旋模型主要用于大型项目，它允许构建高度定制的产品，并且用户反馈可以在项目的早期就被纳入。但可能有项目会形成永无止境的螺旋式发展的风险。 大爆炸模型 Big Bang 模型通常不遵循任何特定过程或说明。开发从当前可用的资源和工作开始，几乎没有计划或根本没有计划。结果，客户得到的产品甚至可能无法满足要求。功能是动态实现的。 Big Bang SDLC 模型的主要思想是将所有可用资源分配给产品本身的开发，主要是在编码方面，而不用担心满足计划。这是仅用于一两个软件工程师的小型项目的 SDLC 方法之一。 敏捷模型 敏捷（Agile） SDLC 模型是迭代和增量方法的组合，致力于通过早期交付工作软件来适应灵活的需求并满足用户和客户的需求。敏捷项目中的需求和解决方案可能会在开发过程中发展。 通过敏捷开发，该产品被分为小的增量构建，并以迭代方式交付。将所有任务划分为较小的时间范围，以便为每个版本准备工作功能。最终产品版本包含所有必需的功能。敏捷仍然是技术行业中使用最广泛的SDLC。 DevOps模型 DevOps是新手模型。DevOps来自两个趋势：敏捷方法和精益方法的应用。通常，DevOps 是通过自动化基础架构和工作流程并持续跟踪应用程序性能来执行的。DevOps方法使您可以增加部署频率，编写代码并缩短部署新代码所需的时间。 DevOps是工具，实践和方法的组合，鼓励开发人员，运维人员和 QA人员共同努力，以进行持续的开发，测试和部署活动，以加速创新并交付更高质量和更可靠的软件产品和功能。","tags":"开发模型"},{"title":"Python 虚拟环境 venv 的创建","url":"/2022/12/05/python/python venv 虚拟环境/","text":"引入原因python 项目为了类似 docker 一样隔离提供 venv 虚拟环境 使用方法python -m venv【params】venvpath 参数 一般情况python -m venv --upgrade-deps venvpath 除非需要之前的一些 site-package 否则不加 --system-site-package 建议建议加上 --upgrade-deps 这样无需手动更新 pip 造成无权限问题而导致原来的 pip 被删除 进入虚拟环境安装好以后可以打开 Scripts&#x2F; 目录下的 activate.bat 批处理文件进入虚拟环境 activate 其他方式进入虚拟环境也可以在 git-bash 里用 source 命令执行 查看是否进入虚拟环境可以用 pip list 查看包情况判断是否进入 python 虚拟环境 退出虚拟环境同样在虚环境里执行 deactivate.bat pycharm 中使用虚拟环境只需新建项目里配置虚拟环境解释器路径","tags":"python 虚拟环境"},{"title":"About me","url":"/about/index.html","text":"这是一个工作一年的测试工程师 此博客网站正在更新 ——-&gt; 敬请期待!","tags":""}]}